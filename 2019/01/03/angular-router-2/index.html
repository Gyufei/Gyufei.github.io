<!-- build time:Wed Jun 05 2019 00:10:18 GMT+0800 (CST) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="baidu-site-verification" content="jMvfaeiNGf"><link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="前端,Angular,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.0"><meta name="description" content="本篇博客是Angular路由模块的第二篇，接着上篇，主要介绍一下Angular框架中的路由模块的一些高级特性，例如路由守卫，路由懒加载，路由特性模块等。"><meta name="keywords" content="前端,Angular"><meta property="og:type" content="article"><meta property="og:title" content="Angular 的路由(二)"><meta property="og:url" content="http://yoursite.com/2019/01/03/angular-router-2/index.html"><meta property="og:site_name" content="风之处所"><meta property="og:description" content="本篇博客是Angular路由模块的第二篇，接着上篇，主要介绍一下Angular框架中的路由模块的一些高级特性，例如路由守卫，路由懒加载，路由特性模块等。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-01-03T14:05:23.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Angular 的路由(二)"><meta name="twitter:description" content="本篇博客是Angular路由模块的第二篇，接着上篇，主要介绍一下Angular框架中的路由模块的一些高级特性，例如路由守卫，路由懒加载，路由特性模块等。"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2019/01/03/angular-router-2/"><title>Angular 的路由(二) | 风之处所</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5a6294a2ef3cbf5009b895119f0909d7";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/Gyufei"><img style="position:absolute;top:0;right:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">风之处所</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/angular-router-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Gyf"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="风之处所"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Angular 的路由(二)</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T00:00:00+08:00">2019-01-03 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/Angular/" itemprop="url" rel="index"><span itemprop="name">Angular</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/01/03/angular-router-2/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/01/03/angular-router-2/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">2,555 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">10 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>本篇博客是<code>Angular路由模块</code>的第二篇，接着上篇，主要介绍一下<code>Angular</code>框架中的路由模块的一些高级特性，例如路由守卫，路由懒加载，路由特性模块等。</p></blockquote><a id="more"></a><h2 id="路由和模块"><a href="#路由和模块" class="headerlink" title="路由和模块"></a>路由和模块</h2><p>除了非常简单的应用，一般的，我们不应该直接在其他模块中混合路由配置，而应该使用专门的路由模块。<br>这样做的好处是关注点分离，易维护和测试，同时也可以更方便的添加路由守卫，解析器等。</p><blockquote><p>要记得在路由模块的<code>exports</code>中导出<code>RouterModule</code>，从而在需要导入路由模块的模块中可以使用<code>RouterModule</code>中的指令,例如<code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>和<code>routerLink</code>。</p></blockquote><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>对于同步加载的模块，导入路由模块之后，将它直接导入到根模块元数据的<code>imports</code>数组中即可。<br>要特别注意<strong>拥有路由模块的特性模块需要在根路由模块之前导入</strong>，从而防止根路由模块的通配符路由短路其他模块中的路由。</p><h3 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h3><p>惰性加载的模块不必导入到根模块中，而需要通过根模块的路由配置的<code>loadChildren</code>属性来进行惰性加载配置。<br>配置方式是需要加载的惰性模块路径加上以<code>#</code>号标识的模块类名，类似如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'test-two'</span>,</span><br><span class="line">    loadChildren: <span class="string">'./test-two/test-two.module#TestTwoModule'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>惰性加载的模块在被加载一次后，在后续就会始终可用。</p></blockquote><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>预加载不同于用户进行操作之后(例如点击导航到)才进行的惰性加载，它是在主要模块加载完毕之后立即进行加载的一种加载方式。</p><p><strong>Angular</strong> 路由内置了两种预加载策略:</p><ul><li>完全不进行预加载，<strong>Angular</strong>默认使用这种策略</li><li>对惰性加载模块进行预加载</li></ul><p>如果需要对所有惰性加载模块进行预加载，需要从路由模块中导入<code>PreloadAllModules</code>，并在<code>RouterModule.forRoot</code>方法的第二个参数中将<code>preloadingStrategy</code>属性设置为它。<br>如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouterModule, PreloadAllModules &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">RouterModule.forRoot(</span><br><span class="line">  appRoutes,</span><br><span class="line">  &#123;</span><br><span class="line">    preloadingStrategy: PreloadAllModules</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>需要注意，具有<code>CanLoad</code>守卫的惰性加载模块, 守卫会阻止惰性模块的预加载。</p></blockquote><h3 id="自定义预加载策略"><a href="#自定义预加载策略" class="headerlink" title="自定义预加载策略"></a>自定义预加载策略</h3><p>通过实现<code>PreloadingStrategy</code>接口及它的<code>preload</code>方法，来自定义加载策略。<br><code>preload</code>方法会被传递两个参数:<br>​</p><ul><li>第一个参数为<code>Route</code>类型的目标路由</li><li>第二个参数为一个返回<code>Observable</code>的加载器函数，用于异步加载模块。</li></ul><p>如果模块需要预加载，则调用第二个参数加载器函数。<br>如果模块不需要预加载，则需要返回一个最终值为<code>null</code>的<code>Observable</code>。</p><p>预加载策略服务定义类似如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PreloadingStrategy, Route &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> PreloadService <span class="keyword">implements</span> PreloadingStrategy &#123;</span><br><span class="line"></span><br><span class="line">  preload(route: Route, load: <span class="function"><span class="params">()</span> =&gt;</span> Observable&lt;<span class="built_in">any</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.data &amp;&amp; route.data.preload) &#123;</span><br><span class="line">      <span class="keyword">return</span> load()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> of(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用自定义策略的方式同样是在<code>RouterModule.forRoot</code>方法的第二个参数中将<code>preloadingStrategy</code>属性设置为它。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot(</span><br><span class="line">  appRoutes,</span><br><span class="line">  &#123;</span><br><span class="line">    preloadingStrategy: PreloadService</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>随后你可以在路由配置的<code>data</code>属性中使用<code>preload</code>属性来设置模块是否预加载。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   path: <span class="string">'jobs'</span>,</span><br><span class="line">   loadChildren: <span class="string">'./jobs/jobs.module.ts#JobsModule'</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">   preload: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="路由事件"><a href="#路由事件" class="headerlink" title="路由事件"></a>路由事件</h2><p>在导航时，<code>Router</code>服务会通过<code>Router.events</code>属性发布一系列的导航事件。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中处理路由的 NavigationStart 事件</span></span><br><span class="line">navStart: Observable&lt;NavigationStart&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.navStart = router.events.pipe(</span><br><span class="line">      filter(<span class="function"><span class="params">evt</span> =&gt;</span> evt <span class="keyword">instanceof</span> NavigationStart)</span><br><span class="line">    ) <span class="keyword">as</span> Observable&lt;NavigationStart&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.navStart.subscribe(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Navigation Started!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>具体的导航事件，可以查看文档中<code>Router.events</code>章节。</p></blockquote><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>可以在路由配置中添加导航守卫，来控制路由器的行为。<br>有以下种类的路由守卫:</p><ul><li><code>CanActivate</code> 导航到某路由时的守卫</li><li><code>CanActivateChild</code> 导航到某子路由的守卫</li><li><code>CanDeactivate</code> 离开当前路由的守卫</li><li><code>CanLoad</code> 导航到某异步加载模块的守卫</li><li><code>Resolve</code> 在路由激活之前进行路由数据获取</li></ul><h3 id="守卫的返回值"><a href="#守卫的返回值" class="headerlink" title="守卫的返回值"></a>守卫的返回值</h3><p>守卫可以返回<code>true</code>使导航继续，也可以返回<code>fasle</code>终止导航，还可以导航到其他位置。<br>对于需要进行异步操作的守卫，可以返回<code>Observable&lt;boolean&gt;</code>或者<code>Promise&lt;boolean&gt;</code>形式的值。</p><blockquote><p>如果返回<code>Observable&lt;boolean&gt;</code>, 必须保证它可以<code>complete</code>，否则，导航会一直挂起。</p></blockquote><h3 id="CanActivate"><a href="#CanActivate" class="headerlink" title="CanActivate"></a><em>CanActivate</em></h3><p><code>CanActivate</code>用于守卫路由的进入。</p><p>实现<code>CanActivate</code>的步骤如下:</p><ol><li><p>构造一个实现了<code>CanActivate</code>接口的守卫类(它是一个服务)。</p><p><code>CanActivate</code>接口需要实现<code>canActivate</code>方法，此方法会被传递两个参数:</p><ul><li>第一个参数类型为<code>ActivatedRouteSnapshot</code>，为即将激活的目标路由的快照。</li><li><p>第二个参数类型为<code>RouterStateSnapshot</code>，为即将到达的全局路由状态树的快照。</p><p>实例代码如下:</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(</span><br><span class="line">  &#123; providedIn: <span class="string">'root'</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthGuard <span class="keyword">implements</span> CanActivate &#123;</span><br><span class="line"></span><br><span class="line">  canActivate( next: ActivatedRouteSnapshot, </span><br><span class="line">               state: RouterStateSnapshot): Observable&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">Promise</span>&lt;<span class="built_in">boolean</span>&gt; | <span class="built_in">boolean</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将守卫加入路由的对应守卫配置数组中</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'admin'</span>,</span><br><span class="line">    component: HomeComponent,</span><br><span class="line">    canActivate: [AuthGuard],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="CanActivateChild"><a href="#CanActivateChild" class="headerlink" title="CanActivateChild"></a><em>CanActivateChild</em></h3><p><code>CanActivateChild</code>类似于<code>CanActivateChild</code>, 但不同的是它用于守卫当前路由的子路由的进入，它会在当前路由的任何子路由被激活之前运行。</p><p>使用<code>CanActivateChild</code>的守卫服务需要实现<code>CanActivateChild</code>接口的<code>canActivatedChild</code>方法。</p><p><code>canActivateChild</code> 会被传递与<code>canActivate</code>方法相同的参数。</p><blockquote><p><code>canActivateChild</code>方法的优势在于可以让我们不需要为每个子路由设置<code>canActivate</code>守卫，而只需要在它们的父路由设置一个<code>canActivateChild</code>守卫。</p></blockquote><p>另外，可以使用无组件路由来增加路由层级，为子路由分组，从而更方便的设置子路由守卫。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'user'</span>,</span><br><span class="line">    component: UserComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 无组件路由，用于为路由分组</span></span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        canActivateChild: [AuthGuard],</span><br><span class="line">        children: [</span><br><span class="line">          &#123; path: <span class="string">'a'</span>, component: AComponent &#125;,</span><br><span class="line">          &#123; path: <span class="string">'b'</span>, component: BComponent &#125;,</span><br><span class="line">          &#123; path: <span class="string">''</span>, component:  DashComponent &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="CanDeactivate"><a href="#CanDeactivate" class="headerlink" title="CanDeactivate"></a><em>CanDeactivate</em></h3><p><code>CanDeactivate</code>用于守卫路由的离开。通常用于防止未保存的更改被丢弃等场景。</p><p>使用<code>CanDeactivate</code>的守卫服务需要实现<code>CanDeactivate</code>接口的<code>canDeactivate</code>方法。</p><p><code>canDeactivate</code>方法会被传入四个参数。</p><ul><li><p>第一个参数为当前将离开的组件(如果需要复用此守卫，你可能需要自己定义组件的类型接口从而使守卫具有更高可用性)。</p></li><li><p>第二个参数类型为<code>ActivatedRouteSnapshot</code>，为当前路由的快照。</p></li><li><p>第三个参数类型为<code>RouterStateSnapshot</code>，为当前的全局路由状态树的快照。</p></li><li><p>第四个参数是可选的，类型为<code>RouterStateSnapshot</code>，为离开后将到达的全局路由树状态。</p></li><li><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyFormComponent <span class="keyword">from</span> <span class="string">'./MyForm.component'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LeaveGuard <span class="keyword">implements</span> CanDeactivate&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  canDeactivate(comp: MyFormComponent, next: ActivatedRouteSnapshot, state: RouterStateSnapshot) &#123;</span><br><span class="line">    <span class="comment">// 可以调用组件的数据和方法来确定守卫返回值</span></span><br><span class="line">    <span class="keyword">return</span> MyFormComponent.inputName === <span class="string">'can leave'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a><em>Resolve</em></h3><p>用于在导航进入前获取组件数据。<br>这样做有以下优点:</p><ul><li>组件不需要去处理数据为空时的表现</li><li>可以在获取数据出错时更优雅的处理</li></ul><p>充当<code>Resolve</code>守卫的服务类需要实现<code>resolve</code>方法。<br>此方法会被传递两个参数:<br>​</p><ul><li>第一个参数类型为<code>ActivatedRouteSnapshot</code>，为即将到达的目标路由的快照。</li><li>第二个参数类型为<code>RouterStateSnapshot</code>，为即将到达的全局路由状态树的快照。</li></ul><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> JobResolverGuard &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> jobService: JobService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> $router: Router</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  resolve(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Job&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> id = next.paramMap.get(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.jobService.getJob(+id).pipe(</span><br><span class="line">      take(<span class="number">1</span>),</span><br><span class="line">      mergeMap(<span class="function"><span class="params">job</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (job) &#123;</span><br><span class="line">          <span class="keyword">return</span> of(job)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$router.navigate([<span class="string">'/jobs'</span>])</span><br><span class="line">          <span class="keyword">return</span> empty()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将守卫加入到路由配置的<code>resolve</code>中,如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   path: <span class="string">':id'</span>,</span><br><span class="line">   component: JobsDetailComponent,</span><br><span class="line">   resolve: &#123;</span><br><span class="line">     job: JobResolverGuard</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>Resolve</code>守卫不需要实现某个特定的接口，当在路由器中配置之后，路由器会自动的查找守卫的<code>resolve</code>方法</p></blockquote><p>在配置后，<code>Resolve</code>方法返回的数据会被作为路由(也就是<code>ActivateRoute</code>)的<code>data</code>中对应的属性值传递，获取形式如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit() &#123;</span><br><span class="line">  <span class="keyword">this</span>.job$ = <span class="keyword">this</span>.$route.data.pipe(</span><br><span class="line">    map(<span class="function">(<span class="params">data: &#123;job: Job&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> data.job</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="CanLoad"><a href="#CanLoad" class="headerlink" title="CanLoad"></a><em>CanLoad</em></h3><p><code>CanLoad</code>守卫用于守卫异步加载模块的路由。</p><blockquote><p><code>CanLoad</code>守卫与<code>CanActivate</code>守卫不同的是，它返回的值控制的是模块的加载与否, 而<code>CanActivate</code>控制的是路由可否访问，因此会始终加载模块。</p></blockquote><p><code>CanLoad</code>守卫服务类需要实现<code>CanLoad</code>接口的<code>canLoad</code>方法，此方法会被传递目标路由作为参数。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canLoad(route: Route): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`/<span class="subst">$&#123;route.path&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url.include(<span class="string">'xxx'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p><code>Angular</code> 有两种路由风格策略:<br>​</p><ul><li><p><code>PathLocationStrategy</code> 默认策略，使用<code>HTML 5</code>的<code>history</code>路由模式，基于<code>histroy.pushState</code> API 来实现前端路由。</p></li><li><p><code>HashLocationStrategy</code> <code>hash</code>风格的路由模式</p></li></ul><p>在<code>HTML 5 history</code>风格下，必须在<code>&lt;head&gt;</code>标签中添加一个<code>&lt;base href&gt;</code>标签来设置基路径，从而指引浏览器从何处加载资源。</p><blockquote><p>如果无法添加此标签，则有以下两种方式解决:</p><ul><li>使用<code>APP_BASE_HREF</code>令牌注入<figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;APP_BASE_HREF&#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">    providers: [&#123;provide: APP_BASE_HREF, useValue: <span class="string">'/my/app'</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>所有资源(CSS, 图片，脚本，模板)的引用都使用绝对路径</li></ul></blockquote><p>如果需要使用传统的<code>hash</code>模式, 则需要在<code>RouterModule.forRoot</code>中将第二个参数的<code>useHash</code>属性设置为<code>true</code>。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouterModule.forRoot(routes, &#123; useHash: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>需要注意，哈希模式下是无法进行服务端渲染的，所以需要在项目初期就慎重考虑选用。</p></blockquote><p>以上就是关于<code>Angular</code>模块的一些进阶知识，通过这两篇博客，基本覆盖了<code>Angular</code>模块的各个方面，当然，只是很走马观花的进行了一下总结，具体的细节上的东西，每个方面要真写起来估计都得几篇博客，因此也不需要太深入，在使用到的时候再去查阅就好。</p><p>感谢阅读。</p></div><div></div><div><div style="text-align:center;color:#ccc;font-size:14px">----本文结束<i class="fa fa-star-o" style="color:#c40000"></i>感谢阅读----</div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/前端/" rel="tag"><i class="fa fa-tag"></i> 前端</a> <a href="/tags/Angular/" rel="tag"><i class="fa fa-tag"></i> Angular</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/01/02/angular-router-1/" rel="next" title="Angular 的路由(一)"><i class="fa fa-chevron-left"></i> Angular 的路由(一)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/01/27/rxjs-4-in_common_operator/" rel="prev" title="RxJs系列（四）：常用操作符">RxJs系列（四）：常用操作符 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Gyf"><p class="site-author-name" itemprop="name">Gyf</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">87</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">20</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Gyufei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/afei-7701" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎 </a></span><span class="links-of-author-item"><a href="http://weibo.com/1865042755/profile" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#路由和模块"><span class="nav-number">1.</span> <span class="nav-text">路由和模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步加载"><span class="nav-number">1.1.</span> <span class="nav-text">同步加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性加载"><span class="nav-number">1.2.</span> <span class="nav-text">惰性加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预加载"><span class="nav-number">1.3.</span> <span class="nav-text">预加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义预加载策略"><span class="nav-number">1.4.</span> <span class="nav-text">自定义预加载策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由事件"><span class="nav-number">2.</span> <span class="nav-text">路由事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由守卫"><span class="nav-number">3.</span> <span class="nav-text">路由守卫</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#守卫的返回值"><span class="nav-number">3.1.</span> <span class="nav-text">守卫的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CanActivate"><span class="nav-number">3.2.</span> <span class="nav-text">CanActivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CanActivateChild"><span class="nav-number">3.3.</span> <span class="nav-text">CanActivateChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CanDeactivate"><span class="nav-number">3.4.</span> <span class="nav-text">CanDeactivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resolve"><span class="nav-number">3.5.</span> <span class="nav-text">Resolve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CanLoad"><span class="nav-number">3.6.</span> <span class="nav-text">CanLoad</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由模式"><span class="nav-number">4.</span> <span class="nav-text">路由模式</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Gyf</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'R8P4WPUO7InstdDE6XwcqVrX-gzGzoHsz',
        appKey: 'iQ1KQlQNe09VHxuX34voY8FV',
        placeholder: '请随便说点什么吧^_^',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,s=r.title.trim().toLowerCase(),o=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),n=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=s&&a.forEach(function(e,t){i=s.indexOf(e),l=o.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+n+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;0>u&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body><script>$(document).ready(function(){var e=function(e){var o,n,t=document,i=e;t.body.createTextRange?(o=document.body.createTextRange(),o.moveToElementText(i),o.select()):window.getSelection&&(n=window.getSelection(),o=document.createRange(),o.selectNodeContents(i),n.removeAllRanges(),n.addRange(o))};$(".code").each(function(){var o=$(this).get(0),n="<div style=\"position: fixed;right: 3%;margin-top: 5px;font-family: consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size: 10px;cursor: pointer;color: #e31436;\"><span><i class=\"fa fa-copy fa-lg\"></i></span></div>",t=$(n);$(t).click(function(){e(o)}),$(t).insertBefore(this)})})</script></html><!-- rebuild by neat -->