<!-- build time:Sat Mar 09 2019 18:19:38 GMT+0800 (CST) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="baidu-site-verification" content="jMvfaeiNGf"><link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="前端,Angular,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.0"><meta name="description" content="在前面的有两篇博客中对 Vue-Router的相关内容进行了总结，在写那两篇博客的时候，本想着对比着Angular能触类旁通一下，没想到大半年不写，很多细碎的东西已经记得不太真切了。真的是佩服自己。因此也趁着空闲把以前的零碎的有关Angular Router的笔记做了个整理，总的来说，相比Vue Router, Angular的路由模块概念和约定是真的多的不止一点点。虽说很多时候吧，其实把官方教程"><meta name="keywords" content="前端,Angular"><meta property="og:type" content="article"><meta property="og:title" content="Angular 的路由(一)"><meta property="og:url" content="http://yoursite.com/2019/01/02/angular-router-1/index.html"><meta property="og:site_name" content="风之处所"><meta property="og:description" content="在前面的有两篇博客中对 Vue-Router的相关内容进行了总结，在写那两篇博客的时候，本想着对比着Angular能触类旁通一下，没想到大半年不写，很多细碎的东西已经记得不太真切了。真的是佩服自己。因此也趁着空闲把以前的零碎的有关Angular Router的笔记做了个整理，总的来说，相比Vue Router, Angular的路由模块概念和约定是真的多的不止一点点。虽说很多时候吧，其实把官方教程"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-01-02T15:06:52.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Angular 的路由(一)"><meta name="twitter:description" content="在前面的有两篇博客中对 Vue-Router的相关内容进行了总结，在写那两篇博客的时候，本想着对比着Angular能触类旁通一下，没想到大半年不写，很多细碎的东西已经记得不太真切了。真的是佩服自己。因此也趁着空闲把以前的零碎的有关Angular Router的笔记做了个整理，总的来说，相比Vue Router, Angular的路由模块概念和约定是真的多的不止一点点。虽说很多时候吧，其实把官方教程"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2019/01/02/angular-router-1/"><title>Angular 的路由(一) | 风之处所</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5a6294a2ef3cbf5009b895119f0909d7";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/Gyufei"><img style="position:absolute;top:0;right:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">风之处所</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/angular-router-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Gyf"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="风之处所"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Angular 的路由(一)</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T00:00:00+08:00">2019-01-02 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/Angular/" itemprop="url" rel="index"><span itemprop="name">Angular</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2019/01/02/angular-router-1/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/01/02/angular-router-1/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">3,424 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">13 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>在前面的有两篇博客中对 <code>Vue-Router</code>的相关内容进行了总结，在写那两篇博客的时候，本想着对比着<code>Angular</code>能触类旁通一下，没想到大半年不写，很多细碎的东西已经记得不太真切了。真的是佩服自己。<br>因此也趁着空闲把以前的零碎的有关<code>Angular Router</code>的笔记做了个整理，总的来说，相比<code>Vue Router</code>, <code>Angular</code>的路由模块概念和约定是真的多的不止一点点。<br>虽说很多时候吧，其实把官方教程看一遍，写起来就也就差不多用到那么多东西。很多东西不去追根究底的话其实也不会有什么大的影响。但我还是喜欢自己能够完全对使用的类库也好，框架也好，那种知根知底的感觉。<br>这两篇博客的相关知识，如果只是使用<code>Angular</code>框架，已经完全够用了，再深一步就牵扯到具体实现，对工程实践影响不大了。</p></blockquote><a id="more"></a><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><ol><li><p>定义根 URL</p><p>在<code>index.html</code>的<code>&lt;head&gt;</code>标签中使用<code>&lt;base&gt;</code>标签定义合成导航路径使用的根<code>URL</code>。</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义路由配置并导入路由模块和路由器服务</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要从 @angular/router 中导入路由模块和所需的其他结构功能</span></span><br><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由配置</span></span><br><span class="line"><span class="keyword">const</span> appRoutes: Routes = [</span><br><span class="line">  &#123;path: <span class="string">'a'</span>, component: AComp &#125;</span><br><span class="line">  &#123;path: <span class="string">'b'</span>, component: BComp &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由配置传递给路由模块并导入到主模块</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    <span class="comment">// 对于子模块路由需使用 forChild</span></span><br><span class="line">    RouterModule.forRoot(</span><br><span class="line">      appRoutes,</span><br><span class="line">      &#123; enableTracing: <span class="literal">true</span> &#125;       <span class="comment">// 打开路由的调试模式(应仅在开发模式使用)</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// other imports here</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>每个带路由的<code>Angular</code>应用都有一个<code>Router</code>路由器服务的单例对象，用于确定<code>URL</code>和组件之间的映射关系。<br>使用路由模块的<code>forChild</code>来在根模块导入它一次，在子模块中要使用<code>forChild</code>,从而保证它不会被二次导入。</p></blockquote></li><li><p>定义路由出口</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// template</span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>路由配置用于将<code>URL</code>的<code>path</code>映射到组件的一个对象数组。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appRoutes: Routes = [</span><br><span class="line">  &#123; path: <span class="string">'a'</span>, component: AComp &#125;,</span><br><span class="line">  &#123; path: <span class="string">'b'</span>, component: BComp &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>path</code>不能以<code>/</code>开头</p></blockquote><h3 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="comment">// '' 代表应用的默认路径，即URL为空时的访问位置</span></span><br><span class="line">  path: <span class="string">''</span>,</span><br><span class="line">  redirectTo: <span class="string">'/heroes'</span>,</span><br><span class="line">  pathMatch: <span class="string">'full'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>redirectTo</code>属性来将一个路由重定向到另一个路由。<br><code>pathMatch</code>属性用于设置路由重定向的匹配模式，有以下两个值可选:</p><ul><li><code>full</code> 路径完全匹配当前路由时才进行跳转</li><li><code>prefix</code> 路由以当前路由开头时就进行跳转</li></ul><p>重定向时同样可以包含可选参数，查询参数和锚点片段。如下:<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: <span class="string">'old'</span>, redirectTo: <span class="string">'/new'</span> &#125;,</span><br><span class="line">&#123; path: <span class="string">'old/:id'</span>, redirectTo: <span class="string">'/new/:id'</span> &#125;,</span><br></pre></td></tr></table></figure><p></p><blockquote><p>当使用绝对地址的重定向时，路由器会使用<code>redirectTo</code>属性中设置的查询参数和片段。<br>当使用相对地址的重定向时，路由器会使用跳转前的源地址的查询参数和片段</p></blockquote><p><strong>需要注意，为了避免无限循环的重定向，重定向在一层路由配置中只会被处理一次，</strong></p><h3 id="通配符路由"><a href="#通配符路由" class="headerlink" title="通配符路由"></a>通配符路由</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    path: <span class="string">'**'</span>, </span><br><span class="line">    component: PageNotFoundComponent </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>**</code>通配符来配置当访问路由不匹配前面定义的所有路由时的访问位置(一般重定向到<code>404</code>页面）</p><blockquote><p>路由器采用<strong>先匹配者优先</strong>策略，因此通配符路由应该放在路由配置数组的最后，防止造成其他路由短路。</p></blockquote><h3 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h3><p>通过<code>children</code>属性来配置子路由，在<code>children</code>属性所属对象对应的组件中放置<code>RouterOutlet</code>来作为子路由出口。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'user-home'</span>,</span><br><span class="line">    <span class="comment">// 在此组件中设置路由出口来展示子路由组件</span></span><br><span class="line">    component: UserHomeComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'users'</span>,</span><br><span class="line">        component: UsersComponent,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="路由数据"><a href="#路由数据" class="headerlink" title="路由数据"></a>路由数据</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'C'</span>,</span><br><span class="line">    component: CComp,</span><br><span class="line">    data: &#123; title: <span class="string">'c page title'</span> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以使用路由中的<code>data</code>属性来存放与路由有关的任意信息(例如页面标题，权限配置等等)。</p><h3 id="命名出口"><a href="#命名出口" class="headerlink" title="命名出口"></a>命名出口</h3><p>命名出口可以让一个模板中除了无名主路由出口外，还可以存在多个命名的路由出口。<br>使用命名出口的步骤如下:</p><ol><li><p>在模板中，使用<code>name</code>属性来为<code>router-outlet</code>指令命名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span> <span class="attr">name</span>=<span class="string">"tipBox"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在路由配置中，使用<code>outlet</code>属性来配置组件及其对应的命名出口和路径。</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'messageOne'</span>,</span><br><span class="line">    component: MessageOneComponent,</span><br><span class="line">    outlet: <span class="string">'tipBox'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'messageTwo'</span>,</span><br><span class="line">    component: MessageTwoComponent,</span><br><span class="line">    outlet: <span class="string">'tipBox'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在路由链接中进行导航<br>在链接参数数组中指定命名出口和其对应的路径。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">"[&#123; outlets: &#123;tipBox: ['messageOne']&#125; &#125;]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">"[&#123; outlets: &#123;tipBox: ['messageTwo']&#125; &#125;]"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以编码式的通过<code>navigate</code>使用同样的链接参数数组来进行命名出口路由的导航。</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.router.navigate([&#123; outlets: &#123; tipBox: [<span class="string">'messageTwo'</span>] &#125;&#125;])</span><br></pre></td></tr></table></figure></blockquote></li><li><p>通过将命名出口对应的路径设置为<code>null</code>来关闭命名出口</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.router.navigate([&#123; outlets: &#123; tipBox: <span class="literal">null</span> &#125;&#125;])</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取应用路由配置"><a href="#获取应用路由配置" class="headerlink" title="获取应用路由配置"></a>获取应用路由配置</h3><p>通过路由器<code>Router</code>的<code>config</code>属性，可以方便的获取到应用的路由器配置。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">router: Router</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> replacer = <span class="function">(<span class="params">key, value</span>) =&gt;</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) ? value.name : value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Routes: '</span>, <span class="built_in">JSON</span>.stringify(router.config, replacer, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h2><p>在路由路径中，可以携带参数, 通过动态的路由参数，来将多个路由映射到一个组件。</p><h3 id="必选路径参数"><a href="#必选路径参数" class="headerlink" title="必选路径参数"></a>必选路径参数</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// id 即为路由参数的令牌token</span></span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    component: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选路径参数"><a href="#可选路径参数" class="headerlink" title="可选路径参数"></a>可选路径参数</h3><p>可选路径参数不需要在路径中模式匹配，具有更高的灵活性。<br>可选路径参数类似于传统 URL 中的<code>query</code>。不同的是，它在<code>URL</code>中不是使用<code>?</code>和<code>&amp;</code>号分割，而是使用<code>;</code>分割。<br>这种方式称作 <strong><em>矩阵URL标记法</em></strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.sss.cn/users;id=15;foo=foo</span><br></pre></td></tr></table></figure><p></p><h3 id="获取路径参数"><a href="#获取路径参数" class="headerlink" title="获取路径参数"></a>获取路径参数</h3><p>路由器会构建一个属于当前路由的路由状态<code>ActivatedRoute</code>。<br>可以通过注入<code>ActivatedRoute</code>路由服务来获取路由参数和其他有用的信息。</p><h4 id="通过ParamMap"><a href="#通过ParamMap" class="headerlink" title="通过ParamMap"></a>通过<code>ParamMap</code></h4><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;...&#125;)</span><br><span class="line"><span class="keyword">class</span> MyComponent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> route: ActivatedRoute</span>) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.user$ = <span class="keyword">this</span>.route.paramMap.pipe(</span><br><span class="line">        switchMap(<span class="function">(<span class="params">params: ParamMap</span>) =&gt;</span></span><br><span class="line">            <span class="keyword">this</span>.service.getUser(params.get(<span class="string">'id'</span>)))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivatedRoute</code>的<code>paramMap</code>属性是参照<code>URLSearchparams</code>接口设计的，用来处理路由参数和查询参数的。<br>它包含以下几个方法:</p><ul><li><code>has(name)</code> 检查参数是否存在于参数列表中</li><li><code>get(name)</code> 获取对应的参数, 若无，则返回<code>null</code></li><li><code>getAll(name)</code> 获取对应的参数的所有的值的数组(用于一个参数名对应多个值时)</li><li><code>keys</code> 获取所有参数名组成的字符串数组</li></ul><blockquote><p>通过<code>paramMap</code>可观察对象的形式获取路由参数，在路由参数变化时可以方便的响应变化和实现组件复用。</p></blockquote><h4 id="通过Snapshot"><a href="#通过Snapshot" class="headerlink" title="通过Snapshot"></a>通过<code>Snapshot</code></h4><p>当确定组件<strong>不会也不需要被复用</strong>时，可以使用<code>ActivatedRoute</code>的<code>snapshot</code>属性来简便的获取路由参数。<br><code>snapshot</code>是<code>activatedRoute</code>的一个初始值快照。<br></p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngOnInit() &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="keyword">this</span>.route.snapshot.paramMap.get(<span class="string">'id'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.user$ = <span class="keyword">this</span>.service.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="获取查询参数"><a href="#获取查询参数" class="headerlink" title="获取查询参数"></a>获取查询参数</h3><p>当路径携带查询参数时，可以使用<code>ActivatedRoute</code>的<code>queryParamMap</code>来进行订阅和获取。<br>方法和获取路径参数基本相同。</p><h3 id="全局查询参数和片段"><a href="#全局查询参数和片段" class="headerlink" title="全局查询参数和片段"></a>全局查询参数和片段</h3><p><em>全局查询参数</em>可以用来定义一些在所有路由中均可用的可选参数。<br><em>片段</em> 可以引用页面中带有特定<code>id</code>属性的元素，从而自动滚动跳转到页面特定位置。</p><h4 id="通过指令"><a href="#通过指令" class="headerlink" title="通过指令"></a>通过指令</h4><p>在<code>HTML</code>中通过<code>routerLink</code>指令导航时</p><ul><li>通过指令的<code>queryParams</code>输入属性传递查询参数</li><li>通过指令的<code>fragment</code>输入属性传递片段</li><li><p>通过指令的<code>queryParamsHandling</code>设置查询参数的保留方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此输入属性可以取以下三个值:</span><br><span class="line">  `&apos;merge&apos;`  将老查询参数合并到新的查询参数中</span><br><span class="line">  `&apos;preserve&apos;`  保持当前的查询参数</span><br><span class="line">  `&apos;&apos;`      只使用当前的查询参数</span><br></pre></td></tr></table></figure></li><li><p>通过指令的<code>preserveFragment</code>输入属性设置片段在导航时保留。</p></li></ul><h4 id="通过编码"><a href="#通过编码" class="headerlink" title="通过编码"></a>通过编码</h4><p>在类中通过<code>Router.navigate</code>方法导航时, 可以通过向方法传递<code>NavagationExtras</code>类型的配置对象来设置和控制查询参数和片段。</p><ul><li><p>传递查询参数和片段</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NavagationExtras 类型可以从 router 库导入</span></span><br><span class="line"><span class="keyword">let</span> navigationExtras: NavigationExtras = &#123;</span><br><span class="line">  queryParams: &#123; <span class="string">'session_id'</span>: <span class="number">123</span> &#125;,</span><br><span class="line">  fragment: <span class="string">'anchor'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.router.navigate([<span class="string">'/login'</span>], navigationExtras);</span><br></pre></td></tr></table></figure></li><li><p>控制查询参数的保留方式</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> navigationExtras: NavigationExtras = &#123;</span><br><span class="line">  queryParamsHandling: <span class="string">'preserve'</span>,</span><br><span class="line">  preserveFragment: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.router.navigate([redirect], navigationExtras);</span><br></pre></td></tr></table></figure><blockquote><p><code>queryParamsHandling</code> 可取的值和与通过指令导航时相同</p></blockquote></li></ul><h3 id="ActivatedRoute"><a href="#ActivatedRoute" class="headerlink" title="ActivatedRoute"></a><em>ActivatedRoute</em></h3><p><code>ActivatedRoute</code> 有以下几个比较有用和常用的属性。</p><ul><li><p><code>snapshot</code> 当前路由的快照</p></li><li><p><code>url</code> 路由路径的Observable对象</p></li><li><code>data</code> 路由对应的<code>data</code>的Observable对象</li><li><code>paramMap</code> 路由的必须参数和可选参数组成的map类型的Observable对象</li><li><code>queryParamMap</code> 路由查询参数组成的map类型的Observable对象</li><li><p><code>fragment</code> 路由的fragment的Observable对象</p></li><li><p><code>routeConfig</code> 路由的配置信息</p></li><li><code>root</code> 路由状态树的根节点</li><li><code>parent</code> 该路由父级的<code>ActivatedRoute</code></li><li><code>patchFromRoot</code> 从根节点开始到当前路由的完整路径</li><li><code>firstChild</code> 该路由子路由列表中第一个<code>ActivatedRoute</code></li><li><code>children</code> 该路由下所有已激活的子路由<code>ActivatedRoute</code>数组。</li><li><code>component</code> 该路由对应的组件，是个常量。</li><li><code>outlet</code> 路由渲染到的RouterOutlet的名字(对于无名路由是primary)</li></ul><blockquote><p>路由器会在导航的每个生命周期完成时构建一个由<code>ActivatedRoute</code>组成的树，包含了当前路由器的所有状态。<br>可以通过路由器服务<code>Router</code>的<code>routerState</code>属性来访问这个状态树。</p></blockquote><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><h3 id="链接参数数组"><a href="#链接参数数组" class="headerlink" title="链接参数数组"></a>链接参数数组</h3><p>链接参数数组包含了指向目标组件的路由路径，还可以包含路由参数。</p><blockquote><p>链接参数数组可以包含任意级数的路由拼接和路由参数序列。</p></blockquote><p>链接参数数组既可以用在指令式导航，也可以用在编码式导航。</p><ul><li>用在<code>RouteLink</code>指令式导航时，它可以作为指令输入属性<code>routerLink</code>的输入值。</li><li>用在<code>Router.navigate</code>方法的编码式导航时，它可以作为方法的第一个参数。</li></ul><h3 id="指令式导航"><a href="#指令式导航" class="headerlink" title="指令式导航"></a>指令式导航</h3><p>在<code>HTML</code>中，可以通过<code>RouterLink</code>指令来让路由器控制元素<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/a"</span>&gt;</span>A Comp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 如果需要动态的导航，将一个**链接参数数组**绑定到 routerLink 指令即可</span><br><span class="line">// 传递必选参数</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">"['/user', idData]"</span>&gt;</span>User comp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 可以传递可选参数</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">"['/user', &#123;name: 'sss', foo: 'bar'&#125;]"</span>&gt;</span>User comp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p><code>RouterLink</code>指令可以接受多个输入属性来配置导航，具体如下:</p><ul><li>routerLink 导航目标的链接参数数组</li><li>skipLocationChange 是否改变历史记录</li><li>replaceUrl 是否替换当前历史记录</li><li>queryParams 查询参数</li><li>fragment 路由携带的锚点片段</li><li>queryParamsHandling 保留查询参数的方式，详见路由二笔记</li><li>preserveFragment 是否保留锚点片段</li></ul></blockquote><h4 id="路由激活状态"><a href="#路由激活状态" class="headerlink" title="路由激活状态"></a>路由激活状态</h4><p>当<code>RouterLink</code>附着的元素对应路由激活时，<code>RouterLinkActive</code>指令可以为此元素添加对应的<code>CSS</code>类。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/a"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span>&gt;</span>A comp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 只有路由链接完全匹配时才激活`CSS`类(防止父链接被同时激活)</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/a"</span> <span class="attr">routerLinkActive</span>=<span class="string">"active"</span> [<span class="attr">routerLinkActiveOptions</span>]=<span class="string">"&#123; exact: true &#125;"</span>&gt;</span>A comp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="编码式导航"><a href="#编码式导航" class="headerlink" title="编码式导航"></a>编码式导航</h3><p>在类代码中，可以通过路由器<code>Router</code>的方法进行导航。</p><h4 id="navigate"><a href="#navigate" class="headerlink" title="navigate"></a><em>navigate</em></h4><p><code>navigate</code>方法接受两个参数。</p><ul><li>第一个参数是链接参数数组</li><li>可选的第二个参数是一个<code>NavigationExtras</code>对象，用于配置导航的功能和表现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.router.navigate([&apos;/users&apos;, idProperty], &#123; skipLocationChange: true &#125;);</span><br><span class="line">this.router.navigate([&apos;/users&apos;, &#123;name: &apos;sss&apos;, foo: &apos;bar&apos;&#125;], &#123; skipLocationChange: true &#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>NavigationExtras 对象的可配置属性和<code>RouterLink</code>指令的输入属性基本相同,除了多了一个<code>relativeTo</code>属性用于支持相对其他路由导航。<br>如下。</p></blockquote><blockquote><ul><li>skipLocationChange 是否改变历史记录</li><li>replaceUrl 是否替换当前历史记录</li><li>queryParams 查询参数</li><li>fragment 路由携带的锚点片段</li><li>queryParamsHandling 保留查询参数的方式，详见路由二笔记</li><li>preserveFragment 是否保留锚点片段</li><li>relativeTo 相对此属性对应路由进行导航</li></ul></blockquote><h4 id="navigateByUrl"><a href="#navigateByUrl" class="headerlink" title="navigateByUrl"></a><em>navigateByUrl</em></h4><p>此方法同样接受两个参数。<br>第一个参数是导航目标路径，第二个参数和<code>navigate</code>方法相同。</p><h3 id="相对导航"><a href="#相对导航" class="headerlink" title="相对导航"></a>相对导航</h3><p>可以使用相对于当前<code>URL</code>路径的方式进行导航，从而避免绝对路径导航对父路由结构的依赖。</p><h4 id="指令式的相对导航"><a href="#指令式的相对导航" class="headerlink" title="指令式的相对导航"></a>指令式的相对导航</h4><p>在HTML中使用链接参数数组进行导航时，有如下规则:</p><ul><li><code>/</code>表示根路径</li><li><code>./</code>或无斜杠开头表示当前级别的<code>URL</code>路径</li><li><code>../</code>表示上级路径</li></ul><blockquote><p><code>routeLink</code>进行相对导航不需要指定<code>relativeTo</code>，因为它默认相对于当前组件的<code>ActivatedRoute</code>。</p></blockquote><h4 id="编码式的相对导航"><a href="#编码式的相对导航" class="headerlink" title="编码式的相对导航"></a>编码式的相对导航</h4><p><code>Router</code>的<code>navigate</code>方法也可以进行相对导航，通过它的<code>NavigationExtras</code>对象参数的<code>relativeTo</code>属性设置相对导航路径是相对于哪个路由，例如使用当前组件的<code>ActivatedRoute</code>表示相对于当前路径。</p><blockquote><p><code>navigateByUrl</code>只能以绝对路径的方式导航</p></blockquote><p>关于<code>Angular</code>的<code>Router</code>模块的基础知识大概就是这些，在了解了上面的内容之后，基本日常的开发是没有什么问题。<br>在下篇博客会介绍一下<code>Angular</code>路由模块的一些进阶特性，这些特性会更复杂一些，主要用于</p></div><div></div><div><div style="text-align:center;color:#ccc;font-size:14px">----本文结束<i class="fa fa-star-o" style="color:#c40000"></i>感谢阅读----</div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/前端/" rel="tag"><i class="fa fa-tag"></i> 前端</a> <a href="/tags/Angular/" rel="tag"><i class="fa fa-tag"></i> Angular</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/12/01/module&tree_sharking/" rel="next" title="前端模块概述"><i class="fa fa-chevron-left"></i> 前端模块概述</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/01/03/angular-router-2/" rel="prev" title="Angular 的路由(二)">Angular 的路由(二) <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Gyf"><p class="site-author-name" itemprop="name">Gyf</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">86</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">20</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Gyufei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://www.zhihu.com/people/afei-7701" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎 </a></span><span class="links-of-author-item"><a href="http://weibo.com/1865042755/profile" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础使用"><span class="nav-number">1.</span> <span class="nav-text">基础使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由配置"><span class="nav-number">2.</span> <span class="nav-text">路由配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重定向路由"><span class="nav-number">2.1.</span> <span class="nav-text">重定向路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通配符路由"><span class="nav-number">2.2.</span> <span class="nav-text">通配符路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子路由"><span class="nav-number">2.3.</span> <span class="nav-text">子路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由数据"><span class="nav-number">2.4.</span> <span class="nav-text">路由数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名出口"><span class="nav-number">2.5.</span> <span class="nav-text">命名出口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取应用路由配置"><span class="nav-number">2.6.</span> <span class="nav-text">获取应用路由配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径参数"><span class="nav-number">3.</span> <span class="nav-text">路径参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#必选路径参数"><span class="nav-number">3.1.</span> <span class="nav-text">必选路径参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选路径参数"><span class="nav-number">3.2.</span> <span class="nav-text">可选路径参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取路径参数"><span class="nav-number">3.3.</span> <span class="nav-text">获取路径参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过ParamMap"><span class="nav-number">3.3.1.</span> <span class="nav-text">通过ParamMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Snapshot"><span class="nav-number">3.3.2.</span> <span class="nav-text">通过Snapshot</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取查询参数"><span class="nav-number">3.4.</span> <span class="nav-text">获取查询参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局查询参数和片段"><span class="nav-number">3.5.</span> <span class="nav-text">全局查询参数和片段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过指令"><span class="nav-number">3.5.1.</span> <span class="nav-text">通过指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过编码"><span class="nav-number">3.5.2.</span> <span class="nav-text">通过编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ActivatedRoute"><span class="nav-number">3.6.</span> <span class="nav-text">ActivatedRoute</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由导航"><span class="nav-number">4.</span> <span class="nav-text">路由导航</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链接参数数组"><span class="nav-number">4.1.</span> <span class="nav-text">链接参数数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令式导航"><span class="nav-number">4.2.</span> <span class="nav-text">指令式导航</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#路由激活状态"><span class="nav-number">4.2.1.</span> <span class="nav-text">路由激活状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码式导航"><span class="nav-number">4.3.</span> <span class="nav-text">编码式导航</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#navigate"><span class="nav-number">4.3.1.</span> <span class="nav-text">navigate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#navigateByUrl"><span class="nav-number">4.3.2.</span> <span class="nav-text">navigateByUrl</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对导航"><span class="nav-number">4.4.</span> <span class="nav-text">相对导航</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令式的相对导航"><span class="nav-number">4.4.1.</span> <span class="nav-text">指令式的相对导航</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编码式的相对导航"><span class="nav-number">4.4.2.</span> <span class="nav-text">编码式的相对导航</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Gyf</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'R8P4WPUO7InstdDE6XwcqVrX-gzGzoHsz',
        appKey: 'iQ1KQlQNe09VHxuX34voY8FV',
        placeholder: '请随便说点什么吧^_^',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!1,s=r.title.trim().toLowerCase(),o=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),n=decodeURIComponent(r.url),i=-1,l=-1,p=-1;if(""!=s&&a.forEach(function(e,t){i=s.indexOf(e),l=o.indexOf(e),(i>=0||l>=0)&&(c=!0,0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+n+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;0>u&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body><script>$(document).ready(function(){var e=function(e){var o,n,t=document,i=e;t.body.createTextRange?(o=document.body.createTextRange(),o.moveToElementText(i),o.select()):window.getSelection&&(n=window.getSelection(),o=document.createRange(),o.selectNodeContents(i),n.removeAllRanges(),n.addRange(o))};$(".code").each(function(){var o=$(this).get(0),n="<div style=\"position: fixed;right: 3%;margin-top: 5px;font-family: consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size: 10px;cursor: pointer;color: #e31436;\"><span><i class=\"fa fa-copy fa-lg\"></i></span></div>",t=$(n);$(t).click(function(){e(o)}),$(t).insertBefore(this)})})</script></html><!-- rebuild by neat -->