<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Git worktree</title>
      <link href="/2018/09/16/Git-worktree/"/>
      <url>/2018/09/16/Git-worktree/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在<code>Git</code>的工作流中，我们经常会遇到需要从当前分支临时切换到其他分支的情况，如果此时我们有未提交的改动的话，<code>Git</code>就会告诉我们无法切换分支。一般的，我们都是通过<code>git stash</code>命令来将改动先暂存起来，或者临时的进行一个<code>commit</code>在随后再<code>reset</code>回来。</p><p>但这种在同一个工作目录中切来切去，伴随着文件的修改新增删除，非常麻烦，如果不注意的话，还容易出错。</p><p>在更极端的情况下，如果我们正在当前分支下跑测试或者编译，我们想一边测试或者编译一边<code>code</code>呢，要怎么办，<code>git</code>办不到吗？</p><p>其实完全可以，<code>git worktree</code>命令，就是为了解决分支切来切去问题的。</p><p>它可以让我们为同一个仓库开多个工作目录，每个工作目录盛放不同的分支，同时它还可以自动的做好多分支的同步，在需要同时处理多个分支时，十分的便捷和好用。</p><p>这篇博客，就主要来介绍一下这条<code>git</code>命令。</p><p>ps: 大部分内容翻译自官方文档，有的地方为了便于理解，进行了内容的整理和优化。</p></blockquote><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>git worktree</code>命令可以使一个<code>git</code>仓库同时存在多个工作目录，从而使你可以在同一时间将不同的两个分支分配在在两个不同的工作目录中。<br>具体的，通过<code>git worktree add</code>可以为当前所在仓库添加一个新的目录并迁出一个分支到其中，相对于我们通过<code>git init</code>或<code>git clone</code>初始化的<code>git</code>仓库所在的主工作目录，这个工作目录也可以称作<strong><em>关联工作目录</em></strong>。<br>对于一个非空的<code>git</code>仓库而言，只能有一个主工作目录，但可以有任意个关联工作目录。关于工作目录的相关信息，都在<code>.git/worktrees</code>目录下。</p><p>当你在关联工作目录中完成了需要的分支修改之后，不再需要它时，可以通过<code>git worktree remove</code>来移除它。<code>git</code>会自动的将分支信息和改动同步到所有存在的工作目录中去。</p><p>当使用<code>git worktree remove</code>移除关联工作目录后，其在<code>.git/worktrees</code>中相应的工作目录记录文件也会在三个月后被自动的清除，或者你也可以在任意的工作目录中使用<code>git worktree prune</code>来清理已不存在的关联工作目录的记录文件。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git worktree add -b hotfix ../temp master</span><br><span class="line"><span class="meta">$</span> cd ../temp</span><br><span class="line"><span class="meta">#</span> ... 进行一些修改 ...</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'hot fix for boss'</span><br><span class="line"><span class="meta">$</span> cd ../main</span><br><span class="line"><span class="meta">$</span> git worktree remove ../temp</span><br></pre></td></tr></table></figure><p>通过<code>git worktree add</code>命令新建一个工作目录，在其中进行一些修改并提交后，切回主工作目录，直接删除新建的关联工作目录即可，关联工作目录中的分支信息和提交会自动的合并到主工作目录中。</p><h3 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h3><h4 id="add-–lock-b"><a href="#add-–lock-b" class="headerlink" title="add [–lock]  [-b ]  []"></a><strong><em>add [–lock] [-b<branch>]<path></path>[<commit-ish>]</commit-ish></branch></em></strong></h4><p>创建<code>&lt;path&gt;</code>目录并迁出从当前工作仓库中对应的<code>&lt;commit-ish&gt;</code>分支中创建的新分支<code>&lt;branch&gt;</code>到其中。<br>如果不传递<code>&lt;commit-ish&gt;</code>，同时也未指定<code>-b</code>或者<code>-B</code>新分支名，则会从当前分支新建一个以<code>path</code>命名的新分支迁出到关联工作目录中。<br>可选的<code>commit-ish</code>选项, 若无则默认使用当前主目录所在的分支来新建迁出到关联工作目录的分支。<br>可选的<code>-b branch</code>选项，指定新分支的分支名，若无则使用关联工作目录<code>path</code>的目录名作为新分支名。<br>可选的<code>--lock</code>选项，用于在创建工作目录之后自动<code>lock</code>。</p><h4 id="list-–porcelain"><a href="#list-–porcelain" class="headerlink" title="list [–porcelain]"></a><strong><em>list [–porcelain]</em></strong></h4><p>列出当前仓库的所有工作目录。主工作目录始终位于第一条，其他关联工作目录跟随在其后。<br>可选的<code>--porcelain</code>选项，用于显示详细的工作目录信息。</p><h4 id="lock-–reason"><a href="#lock-–reason" class="headerlink" title="lock [–reason ] "></a><strong><em>lock [–reason<string>]<worktree></worktree></string></em></strong></h4><p>如果一个关联工作目录被放置在移动存储设备或类似的会被移除的设备上，你可以使用<code>git worktree lock</code>来锁定工作目录记录文件防止git发现工作目录不存在时会自动清除掉它的记录文件。<br>可选的<code>--reason</code>选项，注解锁定工作目录的原因。</p><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock "></a><strong><em>unlock<worktree></worktree></em></strong></h4><p>解除一个关联工作目录的记录文件的锁定</p><h4 id="move"><a href="#move" class="headerlink" title="move  "></a><strong><em>move<worktree><new-path></new-path></worktree></em></strong></h4><p>移动关联工作目录到其他目录位置。</p><h4 id="prune-n-v-–expire"><a href="#prune-n-v-–expire" class="headerlink" title="prune [-n] [-v] [–expire ]"></a><strong><em>prune [-n] [-v] [–expire <time>]</time></em></strong></h4><p>删除所有无用的关联工作目录记录文件(位于<code>$GIT_DIR/worktrees</code>下)<br>可选的<code>-n</code>选项，用于只显示将要删除哪些工作目录记录文件，而不执行真正的删除。<br>可选的<code>-v</code>选项，用于显示详细的删除信息。<br>可选的<code>--expire &lt;time&gt;</code>选项，用于只删除此时间之前的无用关联工作目录。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a><strong><em>remove</em></strong></h4><p>删除一个关联工作目录。<br><code>-f</code>选项，如果工作目录中有未提交的改动时，必须使用<code>-f</code>才能删除。</p><p>以上就是关于<code>git worktree</code>命令的一些介绍，感谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>requestAnimationFrame是什么？</title>
      <link href="/2018/09/15/requestAnimationFrame/"/>
      <url>/2018/09/15/requestAnimationFrame/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>对于<code>web</code>应用来说，实现动画的方式有很多。在<code>CSS3</code>的动画效果已经非常强大的前提下，我们一般是不推荐使用<code>JS</code>来实现动画效果的，一是因为<code>JS</code>动画通常性能上都非常不乐观，二是写起来也十分麻烦，而且不易维护。</p><p>但在某些场景下，当<code>CSS3</code>动画不能满足需求时，我们就不得不借助于<code>JS</code>来实现了。在以前我们一般使用<code>setTimeout</code>通过定时来控制元素的位置，角度，透明度，显隐等属性实现动画的过渡效果。</p><p>今天要介绍的主角<code>requestAnimationFrame</code>，通过名字也可以看出，它与动画有关(废话！！要不我上面扯半天动画干嘛)。那么<code>requestAnimationFrame</code>相比于<code>setTimeout</code>又有哪些突出的优势呢？</p><p>让我们通过这篇博客来一一解释。</p></blockquote><a id="more"></a><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>大家一定还记得，小时候我们看电影，放映员都是拿着一大盘的胶片，装在投影灯上来播放电影的，这也就是老式的胶片电影。通过将电影的一幕幕画面先洗在胶片上，然后将胶片快速的从投影灯前移动来打到大影幕上，从而在荧幕上显出连贯的画面来。胶片上的一个画面，就叫做一帧。</p><p>科技在发展，目前的显示器已经从老式的电子管到液晶，再到<code>LED</code>等材料，但不管显示器的科技如何更新，它基本的原理仍然是利用人眼的暂留效应，通过快速呈现出一帧帧静止的画面来实现基本的动态显示的。这个快速有多块呢？一般来说，普通显示器的显示频率是60Hz,也就是每16.7ms(1000/60)一帧。当然，现在有很多显示器早已达到了<code>144HZ</code>甚至更高。</p><p>再回到我们的正题，动画其实归根结底，也是更新每一帧的对应位置，从而形成一系列连贯平滑的屏幕显示图像，在人眼中表现出流畅的过渡效果。</p><h3 id="实现动画的几种方式"><a href="#实现动画的几种方式" class="headerlink" title="实现动画的几种方式:"></a>实现动画的几种方式:</h3><p>在网页中，我们实现动画主要有以下几种方式:</p><ul><li><code>html5</code>的<code>canvas</code></li><li><code>css3</code>的<code>transition</code>和<code>animation</code></li><li><code>JavaScript</code>的<code>setTimeout</code></li></ul><p>具体的来说，这几种方式都有相应的优势和局限性。</p><h4 id="html5的canvas"><a href="#html5的canvas" class="headerlink" title="html5的canvas"></a><strong><em>html5<code>的</code>canvas</em></strong></h4><p><code>canvas</code>的功能相当强大，可以实现很多酷炫的效果。但因为它本身是用来提供<code>web</code>的扩展支持和自主绘制的，除非在某些特定领域，大部分时间里对于我们平常需要动画效果来说，是不会用到它的。</p><h4 id="css3的transition和animation"><a href="#css3的transition和animation" class="headerlink" title="css3的transition和animation"></a><strong><em>css3的transition和animation</em></strong></h4><p><code>CSS3</code>动画的优点在于实现简单，维护容易，可复用性高，同时也可以挖掘出很多相当强大的动画效果。所以一般的，我们都推荐使用<code>CSS3</code>来进行网页的动画开发。<br>但在某些场景下，使用<code>CSS3</code>是无法达到我们的需求的。典型的有以下两个场景：</p><ul><li><p>需要逻辑判断和复杂的前置条件处理的动画，例如与元素的<code>scrollTop</code>值相关的动画，例如根据不同条件进行不同表现的动画。</p></li><li><p>非标准曲线的动画，因为<code>CSS3</code>只支持标准的贝塞尔曲线，所以它是无法实现很多复杂特殊的动画效果曲线的。</p></li></ul><p>对于以上两种不适合<code>CSS3</code>的动画，我们通常会使用<code>JS</code>来实现。那下面我们就来看一下<code>setTimeout</code>的优缺点。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong><em>setTimeout</em></strong></h4><p><code>setTimeout</code>通过设定一个时间间隔来不断的更新屏幕图像，从而完成动图。<br>它的优点是可控性高，可以进行编码式的动画效果实现。<br>但是有以下几个缺点:</p><ul><li>执行时间因为<code>JS</code>的线程和事件循环问题会不准确</li><li>执行的时间间隔是固定的，在屏幕刷新的两帧间隔中无论<code>setTimeout</code>的回调函数执行了几次，都只会有最后一次有用，显示器只会更新最后一次执行结果对应的图像。<br>造成无用的函数运行开销，也就是过度绘制，同时因为更新图像的频率和屏幕的刷新重绘制步调不一致，会产生丢帧，在低性能的显示器动画看起来就会卡顿。</li><li>当网页标签或浏览器置于后台不可见时，仍然会执行，造成资源浪费。</li></ul><p>而<code>requestAnimationFrame</code>相比<code>setTimeout</code>，比较好的解决了以上的几个缺点。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong><em>requestAnimationFrame</em></strong></h3><p>翻译过来就是请求动画帧，简称<code>rAF</code>,它是浏览器全局对象<code>window</code>的一个方法。</p><p>相比于<code>setTimeout</code>的在固定时间后执行对应的动画函数，<code>rAF</code>用于指示浏览器<strong><em>在下一次重新绘制屏幕图像时</em></strong>, 执行其提供的回调函数。</p><p>这也是<code>rAF</code>的最大优势–它能够保证我们的动画函数的每一次调用都对应着一次屏幕重绘，从而避免<code>setTimeout</code>通过时间定义动画频率，与屏幕刷新频率不一致导致的丢帧。<br>它的另一个优点就是在页面被置于后台或隐藏时，会自动的停止，不进行函数的执行，当页面激活时，会重新从上次停止的状态开始执行，因此在性能开销上也会相比<code>setTimeout</code>小很多。<br>总的来说，<code>requestAnimationFrame</code>的优点就是:</p><ul><li>使浏览器画面的重绘和回流与显示器的刷新频率同步</li><li>节省系统资源，提高性能和视觉效果</li></ul><h4 id="详细语法"><a href="#详细语法" class="headerlink" title="详细语法"></a>详细语法</h4><p>它的基本用法类似于<code>setTimeout</code>如下:<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'#theEle'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toLeftAnimation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  element.style.left = ++i + <span class="string">'px'</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(toLeftA)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(toLeftA)</span><br></pre></td></tr></table></figure><p></p><p>在每一次屏幕显示图像的更新中，都将元素向左移动<code>1px</code>。<br>具体语法如下:</p><blockquote><p>window.requestAnimationFrame(callback)</p></blockquote><p><code>requestAnimationFrame</code>方法接收一个函数参数<code>callback</code>，这个函数参数会在浏览器下次绘制前执行。<br><code>callback</code>函数会被传入一个参数<code>DOMHighResTimeStamp</code>,这个参数的含义是指<code>callback</code>的执行时间，也就是下一次屏幕绘制发生的时间。<br><code>requestAnimationFrame</code>方法返回一个长整数，作为本次方法调用的唯一标志<code>ID</code>，可以将这个<code>ID</code>传递给<code>window.cancelAnimationFrame()</code>来取消掉对应的回调函数。</p><h3 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h3><p>目前的时间点上，几乎所有的浏览器现行版本都支持了<code>rAF</code>函数。但在一部分浏览器上还需要加上兼容性前缀。<br>下面是一个比较简单的兼容<code>polyfill</code>函数用来使<code>requestAnimation</code>兼容各浏览器:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimationFrame = (function()&#123;</span><br><span class="line">  return window.requestAnimationFrame ||</span><br><span class="line">         window.webkitRequsetAnimationFrame ||</span><br><span class="line">         window.mozRequestAnimationFrame  ||</span><br><span class="line">         function(callback) &#123;</span><br><span class="line">           window.setTimeout(callback, 16.7)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中，当浏览器不支持此<code>API</code>时，我们代替的使用了<code>setTimeout</code>来保证了方法的向后兼容。<br>当然，这个<code>polyfill</code>没有考虑到需要连带使用<code>cancelAnimationFrame</code>的情况。如果有需要的同学，可以自己去搜索一下，在此就不再多言。</p><p>OK，关于<code>requestAnimationFrame</code>的相关内容，比较简单，就介绍到这里，多谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Momnet.js API 文档翻译整理</title>
      <link href="/2018/09/08/Momnet.js%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/"/>
      <url>/2018/09/08/Momnet.js%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>Moment.js</code>是一个用来处理日期和时间的<code>JS</code>库，功能相当强大，为日常开发中的时间相关处理提供了很多便利。</p><p><code>Moment.js</code>模仿了<code>jQuery</code>的链式调用方法和合并<code>getter</code>和<code>setter</code>方法，使用起来还是十分的高效直观的。各种形式提供便利的<code>API</code>也不少。</p><p>但官网上的文档相当省事，只是把标题翻译成了中文就当做中文文档了。你说你要全英文我也就不说了，你光把标题和章节名翻译成中文然后就说这是中文文档然后放在官方中文网也太敷衍了把！！要逼死强迫症吗？</p><p>所幸这个库的<code>API</code>还算比较简明和直观，并没有太多的需要费力理解的地方，需要翻译的地方也不算特别多，因此我就花了一天时间，把它的文档翻译整理了一下，便于以后查阅，也顺带看一下在以前的使用过程有没有哪些功能没有涉及到或者注意到。</p><p>偷懒了一下，关于<code>i18n</code>国际化的自定义设置语言这一部分，只是简单的总结了一下，并没有详细的翻译，因为并没有多少机会能用到。。。。</p></blockquote><a id="more"></a><p><strong><em>Moment.js</em></strong>是一个用于处理<code>Js</code>的日期和时间的类库。适用于<code>IE8</code>以上浏览器环境和<code>node</code>环境。</p><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Moment.js</code>将<code>Date</code>对象包装成一个<code>moment</code>对象从而实现各种操作和处理。<br>构造函数<strong><em>moment()</em></strong>，用来创建一个<code>moment</code>对象。类似于<code>new Date()</code>方法，但可以接收更多的参数格式。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">moment()                <span class="comment">// 无参数，相当于moment(new Date())</span></span><br><span class="line">moment(<span class="built_in">Number</span>)          <span class="comment">// 数字参数，从距标准时间的Number毫秒来进行格式化。相当于new Date(Number)</span></span><br><span class="line">moment(<span class="built_in">Date</span>)            <span class="comment">// Date对象参数，从一个Date对象中初始化</span></span><br><span class="line"></span><br><span class="line">moment(string)          <span class="comment">// 字符串参数，可接受多种形式的字符串。如`1980-12-25`,`19990302`,`2013-02-08 09:30:26`等。</span></span><br><span class="line">moment(string, format)  <span class="comment">// 字符串参数和一个格式化字符串，形如`moment("2010-10-20 4:30","YYYY-MM-DD HH:mm")`</span></span><br><span class="line">moment(string, formats] <span class="comment">// 字符串参数和一个格式化字符串数组，会在格式化数组中进行匹配，形如`moment("12-25-1995", ["MM-DD-YYYY", "YYYY-MM-DD"])`</span></span><br><span class="line"></span><br><span class="line">moment(<span class="built_in">Object</span>)          <span class="comment">// 接收一个对象，形如`moment(&#123; year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123&#125;)`</span></span><br><span class="line"></span><br><span class="line">moment(<span class="built_in">Number</span>[])        <span class="comment">// 整数数组初始化，类似于new Date(Number[])</span></span><br><span class="line"></span><br><span class="line">moment(moment)          <span class="comment">// 复制一个moment对象完成初始化,也可以使用m.clone()来进行复制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建moment时，可以只指定一些时间单位，其他未指定的单位则会使用当前时间的对应值</span></span><br><span class="line">moment(&#123;<span class="attr">hour</span>: <span class="number">5</span>, <span class="attr">minute</span>: <span class="number">10</span>&#125;);  <span class="comment">// 今天的 5:10.00.000</span></span><br><span class="line">moment(<span class="number">3</span>, <span class="string">"MM"</span>);  <span class="comment">// 今年的第4个月 (April)</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="moment-utc"><a href="#moment-utc" class="headerlink" title="moment.utc()"></a><strong><em>moment.utc()</em></strong></h3><p><code>Moment</code>默认使用本地时间。<br>使用<code>moment.utc()</code>创建一个<code>UTC</code>模式的<code>moment</code>对象，这个对象的所有时间操作和展示都会使用<code>UTC</code>模式。<br>方法的参数与<code>moment()</code>构造函数相同。</p><h3 id="moment-unix-Number"><a href="#moment-unix-Number" class="headerlink" title="moment.unix(Number)"></a><strong><em>moment.unix(Number)</em></strong></h3><p>从一个<code>Unix</code>的秒级时间戳中创建一个<code>moment</code>对象</p><h3 id="moment-parseZone-string"><a href="#moment-parseZone-string" class="headerlink" title="moment.parseZone(string)"></a><strong><em>moment.parseZone(string)</em></strong></h3><p>进行时区设置。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment.parseZone(<span class="string">"2013-01-01T00:00:00-13:00"</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id="moment-max-Moment-Moment"><a href="#moment-max-Moment-Moment" class="headerlink" title="moment.max(Moment[,Moment])"></a><strong><em>moment.max(Moment[,Moment])</em></strong></h3><p>返回接收的所有<code>moment</code>实例参数中的最大值</p><h3 id="moment-min-Moment-Moment"><a href="#moment-min-Moment-Moment" class="headerlink" title="moment.min(Moment[,Moment])"></a><strong><em>moment.min(Moment[,Moment])</em></strong></h3><p>返回接收的所有<code>moment</code>实例参数中的最小值</p><h3 id="moment-isMoment-obj"><a href="#moment-isMoment-obj" class="headerlink" title="moment.isMoment(obj)"></a><strong><em>moment.isMoment(obj)</em></strong></h3><p><code>moment.isMoment(obj)</code>用于检查传入的参数是否是<code>moment</code>对象。</p><h3 id="moment-isDate-obj"><a href="#moment-isDate-obj" class="headerlink" title="moment.isDate(obj)"></a><strong><em>moment.isDate(obj)</em></strong></h3><p><code>moment.isDate(obj)</code>用于检查传入的参数是否是<code>Js</code>的<code>Date</code>对象。</p><h3 id="moment-duration"><a href="#moment-duration" class="headerlink" title="moment.duration"></a><strong><em>moment.duration</em></strong></h3><p>用于创建时间段，关于时间段的具体操作可以查看实例方法中的时间段一节。<br>有以下四种调用方式<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">moment.duration(<span class="built_in">Number</span>, <span class="built_in">String</span>);</span><br><span class="line">moment.duration(<span class="built_in">Number</span>);</span><br><span class="line">moment.duration(<span class="built_in">Object</span>);</span><br><span class="line">moment.duration(<span class="built_in">String</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">moment.duration(<span class="number">100</span>)  <span class="comment">// 100 毫秒</span></span><br><span class="line">moment.duration(<span class="number">2</span>, <span class="string">'hours'</span>)</span><br><span class="line">moment.duration(&#123;</span><br><span class="line">    seconds: <span class="number">2</span>,</span><br><span class="line">    minutes: <span class="number">2</span>,</span><br><span class="line">    hours: <span class="number">2</span>,</span><br><span class="line">    days: <span class="number">2</span>,</span><br><span class="line">    weeks: <span class="number">2</span>,</span><br><span class="line">    months: <span class="number">2</span>,</span><br><span class="line">    years: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">moment.duration(<span class="string">'7.23:59:59.999'</span>) <span class="comment">// 7为天数,999为毫秒数</span></span><br></pre></td></tr></table></figure><p></p><h3 id="moment-isDuration-obj"><a href="#moment-isDuration-obj" class="headerlink" title="moment.isDuration(obj)"></a><strong><em>moment.isDuration(obj)</em></strong></h3><p><code>moment.isDuration(obj)</code>用于检验对象是否为有效的时间段对象<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment.isDuration(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">moment.isDuration(moment.duration()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><h3 id="moment-normalizeUnits-string"><a href="#moment-normalizeUnits-string" class="headerlink" title="moment.normalizeUnits(string)"></a><strong><em>moment.normalizeUnits(string)</em></strong></h3><p>获取传入字符串的时间单位全名<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment.normalizeUnits(<span class="string">'y'</span>);      <span class="comment">// 'year'</span></span><br><span class="line">moment.normalizeUnits(<span class="string">'YeARS'</span>);  <span class="comment">// 'year'</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p><code>moment.fn</code>代理了<code>moment</code>的原型，可以通过其来为<code>moment</code>添加自定义的实例方法。同时<code>moment</code>对象使用了连接接口模式，因此我们可以对它的实例方法进行链式调用。</p><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a><strong><em>检验</em></strong></h3><p><strong><em>moment().isValid()</em></strong><br>检验<code>moment</code>对象的有效性，返回布尔值。</p><h3 id="设置和取值"><a href="#设置和取值" class="headerlink" title="设置和取值"></a><strong><em>设置和取值</em></strong></h3><p><code>moment</code>有关值的方法类似于<code>jQuery</code>，当不传递参数时为获取，传递参数时为设置。类似如下:<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment().date()         <span class="comment">// 获取moment对象的几号</span></span><br><span class="line">moment().date(<span class="built_in">Number</span>)   <span class="comment">// 设置moment对象的几号</span></span><br></pre></td></tr></table></figure><p></p><p>具体的，<code>moment</code>对象有以下常用的一些取值和设置方法：<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">moment().year()         <span class="comment">// 年</span></span><br><span class="line">moment().years()</span><br><span class="line"></span><br><span class="line">moment().quarter()      <span class="comment">// 季度,设置时值范围为1-4</span></span><br><span class="line"></span><br><span class="line">moment().month()        <span class="comment">// 月,设置时值范围为0-11，如果超过11，则会冒泡到年</span></span><br><span class="line">moment().months()</span><br><span class="line"></span><br><span class="line">moment().week()         <span class="comment">// 一年中的第几周</span></span><br><span class="line">moment().weeks()</span><br><span class="line">moment().isoWeek()      <span class="comment">// iso周</span></span><br><span class="line"></span><br><span class="line">moment().weeksInYear()  <span class="comment">// 一年中的第几周</span></span><br><span class="line"></span><br><span class="line">moment().date()         <span class="comment">// 日期(号),设置时值范围为1-31，如果超过31，则会冒泡到月</span></span><br><span class="line">moment().dates()</span><br><span class="line"></span><br><span class="line">moment().dayOfYear()    <span class="comment">// 一年中的第几天，超出将冒泡到年</span></span><br><span class="line"></span><br><span class="line">moment().day()          <span class="comment">// 星期，设置范围为周日到周六，分别为0-6，超出将溢出到其他星期</span></span><br><span class="line">moment().days()  </span><br><span class="line">moment().weekday()      <span class="comment">// 本地化的星期,超出同样会溢出</span></span><br><span class="line">moment().isoWeekday()   <span class="comment">// iso星期，1表示周一，7表示周日</span></span><br><span class="line"></span><br><span class="line">moment().hour()         <span class="comment">// 小时,设置时值范围为0-23，如果超过23，则会冒泡到天</span></span><br><span class="line">moment().hours()</span><br><span class="line"></span><br><span class="line">moment().minute()       <span class="comment">// 分钟,设置时值范围为0-59，如果超过59，则会冒泡到小时</span></span><br><span class="line">moment().minutes()</span><br><span class="line"></span><br><span class="line">moment().second()       <span class="comment">// 秒,设置时值范围为0-59，如果超过59，则会冒泡到分钟</span></span><br><span class="line">moment().seconds()</span><br><span class="line"></span><br><span class="line">moment().millisecond()  <span class="comment">// 毫秒，设置时值范围未0-999,如果超过999，则会冒泡到秒</span></span><br><span class="line">moment().milliseconds()</span><br></pre></td></tr></table></figure><p></p><p>以上的所有方法，我们都可以通过<code>moment().get</code>和<code>method().set</code>来进行取值和赋值。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().get(<span class="string">'year'</span>)</span><br><span class="line">moment().get(<span class="string">'minute'</span>)</span><br><span class="line"></span><br><span class="line">moment().set(<span class="string">'year'</span>, <span class="number">2013</span>)</span><br><span class="line">moment().set(<span class="string">'minute'</span>, <span class="number">20</span>)</span><br><span class="line">moment().set(&#123;<span class="string">'year'</span>: <span class="number">2013</span>, <span class="string">'month'</span>: <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong><em>操作</em></strong></h3><h4 id="加操作"><a href="#加操作" class="headerlink" title="加操作"></a><strong><em>加操作</em></strong></h4><p><code>moment().add()</code>用于时间增加操作。有以下三种调用方式:</p><ul><li><code>moment().add(Number, String)</code><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment().add(<span class="number">7</span>, <span class="string">'days'</span>)  <span class="comment">// 增加七天</span></span><br><span class="line">moment().add(<span class="number">7</span>, <span class="string">'d'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>可以使用以下这些时间单位进行对应加减, 他们均有对应的简写模式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">years         y</span><br><span class="line">quarters      Q</span><br><span class="line">months        M</span><br><span class="line">weeks         w</span><br><span class="line">days          d</span><br><span class="line">hours         h</span><br><span class="line">minutes       m</span><br><span class="line">seconds       s</span><br><span class="line">milliseconds  ms</span><br></pre></td></tr></table></figure><p></p><ul><li><p><code>moment().add(Duration)</code></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duration = moment.duration(&#123;<span class="string">'days'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">moment().add(duration)</span><br></pre></td></tr></table></figure></li><li><p><code>moment().add(Object)</code></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().add(&#123;<span class="attr">days</span>:<span class="number">7</span>,<span class="attr">months</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>当增加月时，如果目标的号天数超出当月最大值，则回变为目标月最后一天</p></blockquote><h4 id="减操作"><a href="#减操作" class="headerlink" title="减操作"></a><strong><em>减操作</em></strong></h4><p><code>moment.subtract()</code>跟<code>moment.add()</code>具有相同的调用方式和调用参数，不同的只是它用来减少时间。</p><h4 id="开始时间"><a href="#开始时间" class="headerlink" title="开始时间"></a><strong><em>开始时间</em></strong></h4><p><code>moment.startOf()</code>将<code>moment</code>的时间设置为某个时间单位的起始时间。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().startOf(<span class="string">'year'</span>);       <span class="comment">// 设置为今年1月第一天的 12:00 am</span></span><br><span class="line">moment().startOf(<span class="string">'month'</span>);      <span class="comment">// 设置为本月第一天的 12:00 am</span></span><br><span class="line">moment().startOf(<span class="string">'quarter'</span>);    <span class="comment">// 设置为本季度第一个月第一天的 12:00 am</span></span><br><span class="line">moment().startOf(<span class="string">'week'</span>);       <span class="comment">// 设置为本周第一天的 12:00 am</span></span><br><span class="line">moment().startOf(<span class="string">'isoWeek'</span>);    <span class="comment">// 设置为ISO本周的第一天的 12:00 am</span></span><br><span class="line">moment().startOf(<span class="string">'day'</span>);        <span class="comment">// 设置为今天的 12:00</span></span><br><span class="line">moment().startOf(<span class="string">'hour'</span>);       <span class="comment">// 设置为当前时间的小时的0分0秒0毫秒</span></span><br><span class="line">moment().startOf(<span class="string">'minute'</span>);     <span class="comment">// 设置为当前的时间的分钟的0秒0毫秒</span></span><br><span class="line">moment().startOf(<span class="string">'second'</span>);     <span class="comment">// 类似 moment().milliseconds(0);</span></span><br></pre></td></tr></table></figure><p></p><h4 id="结束时间"><a href="#结束时间" class="headerlink" title="结束时间"></a><strong><em>结束时间</em></strong></h4><p><code>moment.endOf()</code>将<code>moment</code>的时间设置为某一时间单位的结束时间。与<code>moment.startOf</code>相似。</p><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a><strong><em>最大值</em></strong></h4><p><code>moment().max(Moment)</code>将当前<code>moment</code>与另一个<code>moment</code>比较，并取两者中最大的值作为当前<code>moment</code>的值。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.max(b)    <span class="comment">// 相当于 a = moment.max(a,b)</span></span><br></pre></td></tr></table></figure><p></p><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a><strong><em>最小值</em></strong></h4><p>将当前<code>moment</code>与另一个<code>moment</code>比较，并取两者中最小的值作为当前<code>moment</code>的值。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.min(b)    <span class="comment">// 相当于 a = moment.min(a,b)</span></span><br></pre></td></tr></table></figure><p></p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a><strong><em>本地化</em></strong></h4><p><code>moment().local()</code>用于标示<code>moment</code>内部使用本地时间模式</p><h4 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a><strong><em>UTC</em></strong></h4><p><code>moment().UTC()</code>用于表示<code>moment</code>内部使用<strong><em>UTC</em></strong>模式。</p><h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a><strong><em>展示</em></strong></h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a><strong><em>格式化</em></strong></h4><p><code>moment().format()</code>用于格式化展示当前<code>moment</code>时间对象。<br>它可以接受各种时间格式化标识的字符串来格式化返回时间字符串。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment().format()   <span class="comment">// "2014-09-08T08:02:17-05:00" (ISO 8601)</span></span><br><span class="line">moment().format(<span class="string">"dddd, MMMM Do YYYY, h:mm:ss a"</span>) <span class="comment">// "Sunday, February 14th 2010, 3:25:50 pm"</span></span><br><span class="line">moment().format(<span class="string">"ddd, hA"</span>)                       <span class="comment">// "Sun, 3PM"</span></span><br></pre></td></tr></table></figure><p></p><p>基本的标示字符串如下：<br>标识 | 格式化输出<br>——– | —<br><strong>月</strong> |<br>M | 1 2 … 11 12<br>Mo | 1st 2nd … 11th 12th<br>MM | 01 02 … 11 12<br>MMM | Jan Feb … Nov Dec<br>MMMM | January February … November December<br>——– | —<br><strong>季</strong> |<br>Q | 1 2 3 4<br>——– | —<br><strong>天数(月)</strong> |<br>D | 1 2 … 30 31<br>Do | 1st 2nd … 30th 31st<br>DD | 01 02 … 30 31<br>——– | —<br><strong>天数 (年)</strong> |<br>DDD | 1 2 … 364 365<br>DDDo | 1st 2nd … 364th 365th<br>DDDD | 001 002 … 364 365<br>——– | —<br><strong>天数 (星期)</strong> |<br>d | 0 1 … 5 6<br>do | 0th 1st … 5th 6th<br>dd | Su Mo … Fr Sa<br>ddd | Sun Mon … Fri Sat<br>dddd | Sunday Monday … Friday Saturday<br>——– | —<br><strong>星期（本地）</strong> |<br>e | 0 1 … 5 6<br>——– | —<br><strong>星期（ISO）</strong> |<br>E | 1 2 … 6 7<br>——– | —<br><strong>周数</strong> |<br>w | 1 2 … 52 53<br>wo | 1st 2nd … 52nd 53rd<br>ww | 01 02 … 52 53<br>——– | —<br><strong>周数（ISO）</strong> |<br>W | 1 2 … 52 53<br>Wo | 1st 2nd … 52nd 53rd<br>WW | 01 02 … 52 53<br>——– | —<br><strong>年</strong> |<br>YY | 70 71 … 29 30<br>YYYY | 1970 1971 … 2029 2030<br>——– | —<br><strong>周、年</strong> |<br>gg | 70 71 … 29 30<br>gggg | 1970 1971 … 2029 2030<br>——– | —<br><strong>周、年（ISO）</strong> |<br>GG | 70 71 … 29 30<br>GGGG | 1970 1971 … 2029 2030<br>——– | —<br><strong>AM/PM</strong> |<br>A | AM PM<br>a | am pm<br>——– | —<br><strong>时</strong> |<br>H | 0 1 … 22 23<br>HH | 00 01 … 22 23<br>h | 1 2 … 11 12<br>hh | 01 02 … 11 12<br>——– | —<br><strong>分</strong> |<br>m | 0 1 … 58 59<br>mm | 00 01 … 58 59<br>——– | —<br><strong>秒</strong> |<br>s | 0 1 … 58 59<br>ss | 00 01 … 58 59<br>——– | —<br><strong>分数秒</strong> |<br>S | 0 1 … 8 9<br>SS | 00 01 … 98 99<br>SSS | 000 001 … 998 999<br>SSSS … SSSSSSSSS | 000[0..] 001[0..] … 998[0..] 999[0..]<br>——– | —<br><strong>时区</strong> |<br>Z | -07:00 -06:00 … +06:00 +07:00<br>ZZ | -0700 -0600 … +0600 +0700<br>——– | —<br><strong>UNIX时间戳（秒级）</strong>|<br>X | 1360013296<br>——– | —<br><strong>UNIX时间戳（毫秒级)</strong>|<br>x | 1360013296123</p><p>对于不同地区来说，<code>Moment.js</code>还提供了一些特殊标识用于直接获取当前地区的格式化时间串。<br>标识|格式化输出<br>——– | —<br><strong>时间</strong> |<br>LT | 8:30 PM<br>——– | —<br><strong>时间和秒</strong>|<br>LTS | 8:30:25 PM<br>——– | —<br><strong>数字月、日、年</strong> |<br>L | 09/04/1986<br>l | 9/4/1986<br>——– | —<br><strong>月名、日、年</strong> |<br>LL | September 4 1986<br>ll | Sep 4 1986<br>——– | —<br><strong>月名、日、年、时间</strong> |<br>LLL | September 4 1986 8:30 PM<br>lll | Sep 4 1986 8:30 PM<br>——– | —<br><strong>月名、日、星期、年、时间</strong>|<br>LLLL | Thursday, September 4 1986 8:30 PM<br>llll | Thu, Sep 4 1986 8:30 PM</p><blockquote><p>如果想在格式化后的字符串中加入自定义的字符，可以使用方括号将字符包括起来。如下:<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'[today] dddd'</span>) <span class="comment">// 'today Sunday'</span></span><br></pre></td></tr></table></figure><p></p></blockquote><h4 id="当月天数"><a href="#当月天数" class="headerlink" title="当月天数"></a>当月天数</h4><p><code>moment().daysInMonth()</code>返回当前<code>moment</code>对象所在月的天数<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">"2012-02"</span>, <span class="string">"YYYY-MM"</span>).daysInMonth() <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p></p><h4 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a><strong>时间差</strong></h4><p><strong><em>moment.fromNow()</em></strong><br><code>moment().fromNow()</code>用于显示<code>moment</code>对象的对应时间距现在已经过去了过久。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment().subtract(<span class="number">3</span>, <span class="string">'s'</span>)           <span class="comment">// 几秒前</span></span><br><span class="line">moment([<span class="number">2007</span>, <span class="number">0</span>, <span class="number">29</span>]).fromNow()     <span class="comment">// 11年前</span></span><br></pre></td></tr></table></figure><p></p><p>如果向<code>fromNow</code>传递一个布尔值<code>true</code>，则格式化出的时间差不带后缀词。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment([<span class="number">2007</span>, <span class="number">0</span>, <span class="number">29</span>]).fromNow(<span class="literal">true</span>)     <span class="comment">//11年</span></span><br></pre></td></tr></table></figure><p></p><p><strong><em>moment.toNow()</em></strong><br><code>moment().toNow()</code>用于显示<code>moment</code>对象的对应时间距现在还要多久。<br>与<code>fromNow</code>类似，它也接受一个布尔值<code>true</code>为参数，从而不带后缀词。<br>显而易见，<code>m.fromNow() = - m.toNow()</code>。</p><p><strong><em>moment.from(moment-like)</em></strong><br>接受一个时间格式参数，并返回其距当前<code>moment</code>对象时间已过去了多久。<br>同样可以接受第二个<code>true</code>参数来取消后缀。<br><code>moment-like</code>参数可以是一个<code>moment</code>对象，也可以是时间字符串或者 js 的 <code>Date</code>对象或者时间数组。</p><p><strong><em>moment.to(moment-like)</em></strong><br>与<code>from</code>方法其他的都相同，只是返回接受的时间格式参数距现在还要多久。</p><p><strong><em>moment.diff(moment-like)</em></strong><br>接受一个时间格式参数，返回其和当前<code>moment</code>对象的毫秒为单位的事件差。<br>可以接受第二个参数，用于定义返回的时间差的单位。<br>可以接受第三个参数为true，则取消返回值的后缀词。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment([<span class="number">2018</span>, <span class="number">1</span>, <span class="number">29</span>]).diff(<span class="string">'2018-1-29'</span>)  <span class="comment">// 86400000</span></span><br><span class="line">moment([<span class="number">2018</span>, <span class="number">1</span>, <span class="number">29</span>]).diff(<span class="string">'2018-1-29'</span>, <span class="string">'day'</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><h3 id="转换值"><a href="#转换值" class="headerlink" title="转换值"></a>转换值</h3><h4 id="JS-Date-对象"><a href="#JS-Date-对象" class="headerlink" title="JS Date 对象"></a><strong><em>JS Date 对象</em></strong></h4><p><code>moment().toDate()</code>可以得到当前<code>moment</code>包装的<code>Js Data</code>对象。<br>需要注意的是浅复制，因此对<code>Date</code>对象的改变都会反映在<code>moment</code>对象上。<br>如果想要避免这种情况，可以在<code>toDate</code>方法之前先调用<code>momnet().clone()</code>方法。</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a><strong><em>Array</em></strong></h4><p><code>moment().toArray()</code>返回一个数组，即<code>new Date()</code>参数的镜像。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toArray()  <span class="comment">// [2013, 1, 4, 14, 40, 16, 154];</span></span><br></pre></td></tr></table></figure><p></p><p>####<strong><em>对象</em></strong><br><code>moment().toObject()</code>返回一个包括年月日时分秒毫秒的对象。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().toObject()  <span class="comment">// &#123;</span></span><br><span class="line">                     <span class="comment">//     years: 2015</span></span><br><span class="line">                     <span class="comment">//     months: 6</span></span><br><span class="line">                     <span class="comment">//     date: 26,</span></span><br><span class="line">                     <span class="comment">//     hours: 1,</span></span><br><span class="line">                     <span class="comment">//     minutes: 53,</span></span><br><span class="line">                     <span class="comment">//     seconds: 14,</span></span><br><span class="line">                     <span class="comment">//     milliseconds: 600</span></span><br><span class="line">                     <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p></p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><strong><em>JSON</em></strong></h4><p><code>moment.toJSON()</code><br>将<code>moment</code>对象序列化为JSON。</p><h4 id="ISO-8601字符串"><a href="#ISO-8601字符串" class="headerlink" title="ISO 8601字符串"></a><strong><em>ISO 8601字符串</em></strong></h4><p><code>moment().toISOString()</code>返回一个ISO 8601的字符串<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toISOString() <span class="comment">// 2013-02-04T22:44:30.652Z</span></span><br></pre></td></tr></table></figure><p></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="是否之前"><a href="#是否之前" class="headerlink" title="是否之前"></a>是否之前</h4><p><code>moment().isBefore(moment-like)</code>检查当前<code>moment</code>是否在另一个时间之前。<br><code>moment-like</code>时间格式参数可以是一个<code>moment</code>对象，也可以是时间字符串或者 js 的 <code>Date</code>对象或者时间数组。<br>同时可以接受第二个参数表示比较的最小精度，可以是以下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year month week day hour minute second</span><br></pre></td></tr></table></figure><p></p><h4 id="是否之后"><a href="#是否之后" class="headerlink" title="是否之后"></a>是否之后</h4><p><code>moment().isAfter(moment-like)</code>检查当前<code>moment</code>是否在另一个时间之后。<br><code>moment-like</code>时间格式参数可以是一个<code>moment</code>对象，也可以是时间字符串或者 js 的 <code>Date</code>对象或者时间数组。<br>同时可以接受第二个参数表示比较的最小精度，可以是以下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year month week day hour minute second</span><br></pre></td></tr></table></figure><p></p><h4 id="是否相同"><a href="#是否相同" class="headerlink" title="是否相同"></a>是否相同</h4><p><code>moment().isAfter(moment-like)</code>检查当前<code>moment</code>是否与另一个时间相同。<br><code>moment-like</code>时间格式参数可以是一个<code>moment</code>对象，也可以是时间字符串或者 js 的 <code>Date</code>对象或者时间数组。<br>同时可以接受第二个参数表示比较的最小精度，可以是以下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year month week day hour minute second</span><br></pre></td></tr></table></figure><p></p><h4 id="是否之间"><a href="#是否之间" class="headerlink" title="是否之间"></a>是否之间</h4><p><code>moment().isBetweeen(moment-like, moment-like)</code>比较当前<code>mometn</code>是否在两个时间之间。<br>可以接受第三个参数表示最小比较精度。</p><h4 id="是否闰年"><a href="#是否闰年" class="headerlink" title="是否闰年"></a>是否闰年</h4><p><code>moment().isLeapYear()</code>比较当前<code>moment</code>的年份是否为闰年，是返回<code>true</code>,否则返回<code>false</code></p><h4 id="检查夏令时"><a href="#检查夏令时" class="headerlink" title="检查夏令时"></a>检查夏令时</h4><p><code>moment().isDST()</code>检查是否夏令时<br><code>moment().isDSTShifted()</code>检查是否被夏令时转换</p><h3 id="时间段"><a href="#时间段" class="headerlink" title="时间段"></a>时间段</h3><p>时间段表示一段长度的时间,通过静态方法<code>moment.duration()</code>创建。</p><h4 id="人性化展示"><a href="#人性化展示" class="headerlink" title="人性化展示"></a>人性化展示</h4><p><code>moment.duration().humanize()</code>用于友好的展示一个时间段<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment.duration(<span class="number">1</span>, <span class="string">"minutes"</span>).humanize()  <span class="comment">// a minute</span></span><br></pre></td></tr></table></figure><p></p><p>可以接受一个参数true，用于增加前缀词<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment.duration(<span class="number">1</span>, <span class="string">"minutes"</span>).humanize(<span class="literal">true</span>)  <span class="comment">// in a minute</span></span><br></pre></td></tr></table></figure><p></p><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>以下方法，可以返回时间段的相应时间单位值<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">moment.duration().milliseconds()        <span class="comment">// 时间段毫秒单位上的值</span></span><br><span class="line">moment.duration().asMilliseconds()      <span class="comment">//　时间段以毫秒为单位的值</span></span><br><span class="line"></span><br><span class="line">moment.duration().seconds()             <span class="comment">//　时间段秒单位上的值</span></span><br><span class="line">moment.duration().asSeconds()           <span class="comment">//　时间段以秒为单位的值</span></span><br><span class="line"></span><br><span class="line">moment.duration().minutes()             <span class="comment">// 时间段分单位上的值</span></span><br><span class="line">moment.duration().asMinutes()           <span class="comment">//　时间段以分为单位的值</span></span><br><span class="line"></span><br><span class="line">moment.duration().hours()               <span class="comment">// 时间段小时单位上的值</span></span><br><span class="line">moment.duration().asHours()             <span class="comment">// 时间段小时单位上的值</span></span><br><span class="line"></span><br><span class="line">moment.duration().days()                <span class="comment">// 时间段天单位上的值</span></span><br><span class="line">moment.duration().asDays()              <span class="comment">// 时间段天单位上的值</span></span><br><span class="line"></span><br><span class="line">moment.duration().months()              <span class="comment">// 时间段月单位上的值</span></span><br><span class="line">moment.duration().asMonths()            <span class="comment">// 时间段月单位上的值(一个月被定义为30天</span></span><br><span class="line"></span><br><span class="line">moment.duration().years()               <span class="comment">// 时间段年单位上的值</span></span><br><span class="line">moment.duration().asYears()             <span class="comment">// 时间段年单位上的值(一个月被定义为365天</span></span><br></pre></td></tr></table></figure><p></p><p><strong><em>get()</em></strong><br>用于替代上面的各种<code>Duration#X</code>方法。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duration.get(<span class="string">'hours'</span>);</span><br><span class="line">duration.get(<span class="string">'minutes'</span>);</span><br><span class="line">duration.get(<span class="string">'seconds'</span>);</span><br></pre></td></tr></table></figure><p></p><p><strong><em>as()</em></strong><br>用于替代上面的各种<code>Duration#asX</code>方法。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duration.as(<span class="string">'hours'</span>);</span><br><span class="line">duration.as(<span class="string">'minutes'</span>);</span><br><span class="line">duration.as(<span class="string">'seconds'</span>);</span><br></pre></td></tr></table></figure><p></p><h4 id="增加时间"><a href="#增加时间" class="headerlink" title="增加时间"></a>增加时间</h4><p><code>moment.duration().add()</code>用于增加时间段的时间，与<code>moment().add()</code>类似<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moment.duration().add(<span class="built_in">Number</span>, <span class="built_in">String</span>);</span><br><span class="line">moment.duration().add(<span class="built_in">Number</span>);</span><br><span class="line">moment.duration().add(Duration);</span><br><span class="line">moment.duration().add(<span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p></p><h4 id="减少时间"><a href="#减少时间" class="headerlink" title="减少时间"></a>减少时间</h4><p><code>moment.duration().subtract()</code>与<code>add()</code>对应，用于减少时间。</p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p><code>moment.duration().toJSON()</code>用于将时间段对象转换为<code>JSON</code></p><h2 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h2><h3 id="全局语言设置"><a href="#全局语言设置" class="headerlink" title="全局语言设置"></a>全局语言设置</h3><p>使用静态方法<code>moment.locale()</code>来进行全局的语言设置。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">momnet.locale() 　  <span class="comment">//　获取当前的语言设置</span></span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>)     <span class="comment">// 设置全局语言,支持字符串的模糊匹配,也会返回当前的语言设置</span></span><br><span class="line">moment.locale([<span class="string">'tq'</span>, <span class="string">'fr'</span>]); </span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">'cn'</span>, &#123;</span><br><span class="line">  <span class="comment">// 接受各种配置，具体可以查看官方文档</span></span><br><span class="line">  months: [<span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>,</span><br><span class="line">        <span class="string">"August"</span>, <span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><a href="http://momentjs.cn/docs/#/customization/" target="_blank" rel="noopener">官方文档传送门</a></p><h3 id="局部语言设置"><a href="#局部语言设置" class="headerlink" title="局部语言设置"></a>局部语言设置</h3><p>使用实例方法`moment().locale(string)来进行单个实例的语言设置。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> localLocale = moment();</span><br><span class="line">localLocale.locale(<span class="string">'en'</span>); <span class="comment">// 默认语言 英语</span></span><br><span class="line"></span><br><span class="line">moment().locale()           <span class="comment">//　同样返回当前的语言设置</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>在momentJs 2.8.1版本之前的语言设置，需要通过<code>moment.lang()</code>和<code>moment().lang()</code>。<br>在浏览器中加载语言只需要引入对应的类似<code>locale/zh.js</code>。语言文件即可。<br>在<code>Node.js</code>中则需要保证在<code>moment-root/locale</code>中存在需要加载的语言文件，然后使用<code>moment.locale()</code>来加载。</p></blockquote><h3 id="获取语言数据"><a href="#获取语言数据" class="headerlink" title="获取语言数据"></a>获取语言数据</h3><p>使用<code>localeData()</code>的各种方法来获取语言数据<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">localeData.months(aMoment);         <span class="comment">// 指定时间月份的全名</span></span><br><span class="line">localeData.monthsShort(aMoment);    <span class="comment">// 指定时间月份的缩写</span></span><br><span class="line">localeData.monthsParse(longOrShortMonthString);  <span class="comment">// 返回输入月份的序号 (0 〜 11) </span></span><br><span class="line">localeData.weekdays(aMoment);  <span class="comment">// 指定时间星期的全名</span></span><br><span class="line">localeData.weekdaysShort(aMoment);  <span class="comment">// 指定时间星期的缩写</span></span><br><span class="line">localeData.weekdaysMin(aMoment);  <span class="comment">// 指定时间星期的缩写</span></span><br><span class="line">localeData.weekdaysParse(minShortOrLongWeekdayString);  <span class="comment">// 返回输入星期的序号 (0 〜 6) </span></span><br><span class="line">localeData.longDateFormat(dateFormat);  <span class="comment">// 返回指定日期时间缩写格式的全写，如：LT, L, LL等</span></span><br><span class="line">localeData.isPM(amPmString);  <span class="comment">// 是否 AM、PM 字符串</span></span><br><span class="line">localeData.meridiem(hours, minutes, isLower);  <span class="comment">// 返回指定日期大小写形式的 am/pm 字符串</span></span><br><span class="line">localeData.calendar(key, aMoment);  <span class="comment">// 返回日历格式。Key可以是：'sameDay', 'nextDay', 'lastDay', 'nextWeek', 'prevWeek', 'sameElse'</span></span><br><span class="line">localeData.relativeTime(number, withoutSuffix, key, isFuture);  <span class="comment">// 返回一个相对时间的字符串。Key可以是：'s', 'm', 'mm', 'h', 'hh', 'd', 'dd', 'M', 'MM', 'y', 'yy'</span></span><br><span class="line">localeData.pastFuture(diff, relTime);  <span class="comment">// 转换实际时间 relTime 到过去或未来的 diff的值</span></span><br><span class="line">localeData.ordinal(number);  <span class="comment">// 转换数字到序数 1 -&gt; 1st</span></span><br><span class="line">localeData.preparse(str);  <span class="comment">// 调用转换之前的字符串</span></span><br><span class="line">localeData.postformat(str);  <span class="comment">// 调用格式之后的字符串</span></span><br><span class="line">localeData.week(aMoment);  <span class="comment">// 返回指定时间年中的周数</span></span><br><span class="line">localeData.invalidDate();  <span class="comment">// 返回 'Invalid date'</span></span><br><span class="line">localeData.firstDayOfWeek();  <span class="comment">// 0-6 (周日到周六)</span></span><br><span class="line">localeData.firstDayOfYear();  <span class="comment">// 0-15</span></span><br></pre></td></tr></table></figure><p></p><h3 id="返回当前语言包的月份和周的数据"><a href="#返回当前语言包的月份和周的数据" class="headerlink" title="返回当前语言包的月份和周的数据"></a>返回当前语言包的月份和周的数据</h3><p>以下几个<code>moment</code>的静态方法用于返回当前语言包的各种数据。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">moment.months()         <span class="comment">//　所有月份的数组</span></span><br><span class="line"><span class="comment">// [ 'January',</span></span><br><span class="line">  <span class="string">'February'</span>,</span><br><span class="line">  <span class="string">'March'</span>,</span><br><span class="line">  <span class="string">'April'</span>,</span><br><span class="line">  <span class="string">'May'</span>,</span><br><span class="line">  <span class="string">'June'</span>,</span><br><span class="line">  <span class="string">'July'</span>,</span><br><span class="line">  <span class="string">'August'</span>,</span><br><span class="line">  <span class="string">'September'</span>,</span><br><span class="line">  <span class="string">'October'</span>,</span><br><span class="line">  <span class="string">'November'</span>,</span><br><span class="line">  <span class="string">'December'</span> ]</span><br><span class="line">moment.monthsShort()        <span class="comment">//　所有月份缩写的数组</span></span><br><span class="line">moment.weekdays()           <span class="comment">//　所有星期的数组</span></span><br><span class="line">moment.weekdaysShort()      <span class="comment">// 所有星期缩写的数组 ['周日','周一'...]</span></span><br><span class="line">moment.weekdaysMin()        <span class="comment">// 所有星期最小缩写的数组 ['日','一']</span></span><br></pre></td></tr></table></figure><p></p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于<code>Moment.js</code>，大概也就这么多东西，关于语言的自定义设置方面，没有详细的翻译和总结，只是说了个大概，因为实在是有些繁琐同时用处也不大，同时，官方文档中还专门有一节提及了一些配合其使用的插件，在此也不多做整理，有需要的同学直接去<a href="http://momentjs.cn/docs/#/plugins/" target="_blank" rel="noopener">官网</a>进行查阅即可。</p><p>另外，有一个类似于<code>Moment.js</code>，但更轻量级的库<a href="https://github.com/iamkun/dayjs/blob/master/docs/zh-cn/README.zh-CN.md" target="_blank" rel="noopener">Day.js</a>，如果只需要简单的时间处理，又不想为了一个时间处理增加项目体积的同学可以考虑。</p><p>ok，这篇博客就到这里，多谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJs系列（二）：Observable和Observer</title>
      <link href="/2018/09/05/RxJs%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AObservable/"/>
      <url>/2018/09/05/RxJs%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AObservable/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>Observable</code>是<code>RxJs</code>中的核心概念，也是<code>RxJs</code>最为基础的构造类。我们通过将数据流封装为<code>Observable</code>，来进一步处理事件流程和状态分发等行为。</p><p>将值封装为<code>Observable</code>之后，我们就需要提供一个<code>Observer</code>来对值形成的数据流进行订阅，从而对每个值进行处理。</p><p>本篇博客，主要就<code>Observable</code>和<code>Observer</code>这两个概念进行一个介绍。</p><p>理解了<code>Observable</code>和<code>Observer</code>，对<code>RxJs</code>也就理解了一大部分，后续的深入学习也会更加的得心应手和轻松，所以我会尽可能详细的进行说明，同时也尽量保证文章的通俗易懂。</p><p>对于文中涉及到的<code>RxJs</code>的其他概念，如果不明白也不要紧，先跳过去，后续博客我会再进行介绍。</p><p>Ok，废话不多说。下面进入正题。</p></blockquote><a id="more"></a><p><code>Observable</code>，在<code>RxJs</code>中又被称作<strong><em>可观察对象</em></strong>。表示的是一系列值或事件的集合。这些值和事件，可以是<strong><em>HTTP</em></strong>请求，可以是<strong><em>DOM</em></strong>事件，可以是一个迭代器函数，甚至可以是一个简单的数组。归根结底的来说，其实<code>RxJs</code>并不是非常关心你的值是如何产生的，是同步还是异步。它更关注的部分是在这些值随着时间线需要进行哪些处理，通过关注时间线上值的状态和对时间轴的丰富操作性，自然而然的将异步消化。</p><p><code>Observer</code>，又被称为<strong><em>观察者</em></strong>，用于接受经过处理后的值，就像一个数据管道的最末端。</p><p>笼统的来说，<code>Observable</code>就相当于一个生产者，不停的生产出新的商品，也就是我们数据流中的值。而<code>Observer</code>就相当于一个消费者，来接收并使用这个商品。</p><p>我们来看一个最简单的表达两者关系的一个例子：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    observer.next(<span class="number">1</span>)</span><br><span class="line">    observer.next(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    next: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable.subscribe(observer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>很多同学看到这个例子，可能会觉得似曾相识，看起来跟<code>Promise</code>很像啊。我们来用<code>Promise</code>重写一下这个例子：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>看出区别了吧 ？虽然看起来形式很相近，两者也都是以推送的形式发送值，但不同的是，<code>RxJs</code>可以推送多个值到观察者，而<code>Promise</code>在推送一个值以后，就会进入<code>resolved</code>状态，不会再有后续值的推送了。</p><p>可能又有同学要问了，那<code>Rxjs</code>跟我们普通的事件广播和事件观察者有什么区别呢？主要区别是以下两点:</p><ol><li><code>Event</code> 触发时，<code>EventEmitters</code> 会向所有观察者广播同一个副作用，而<code>Rxjs</code>对每个观察者的推送都是单独的，每个观察者都各自触发一个单独的副作用，就像我们调用一个函数多次一样。</li><li><code>Event</code>的执行与是否有观察者无关，而<code>Observable</code>是惰性的，只有当观察者存在时，它才会执行。</li></ol><p><code>Rxjs</code>通过连续推送和强大的操作符以及惰性机制相结合，可以动态的处理多个时间轴上的连续值，并为每个观察者提供单独的值推送，这种情况使用<code>Promise</code>或者<code>eventemmiter</code>是难以实现或者实现起来非常复杂的。</p><p>在<code>Observable</code>的生命周期中，直观的有以下四个比较重要的核心关注点：</p><ul><li>创建</li><li>订阅</li><li>执行</li><li>清理</li></ul><p>我们按顺序的来说明一下这四部分的内容。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在上面例子中，我们使用<code>Rx.Observable.create</code>创建了一个<code>Observable</code>。<code>Rx.Observable.create</code>只是<code>Observable</code>构造函数的一个别名。</p><p><code>Observable.create</code>接受一个<code>subscribe</code>函数作为参数，<code>subscribe</code>函数的参数为<code>observer</code>，通过<code>observer</code>的<code>next</code>，<code>complete</code>，<code>error</code>方法分别可以传递值信息，完成信息和错误信息。</p><p>我们可以调用任意次的<code>next</code>方法来传递多个值，但一旦调用了<code>complete</code>传递完成消息或者调用<code>error</code>传递错误消息，则意味着推送结束，<code>Observable</code>后续就不会再推送任何值了。</p><p>如下所示:</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      observer.next(<span class="number">1</span>)</span><br><span class="line">      observer.complte()</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      observer.error(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    next: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x),</span><br><span class="line">    complte: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'complete'</span>),</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure><p>可以看出，<code>Observable</code>通过它的约定和实现，将我们提供的观察者对象<code>observer</code>的回调方法对应到了我们在构造函数中使用的<code>observer</code>参数的方法，通过这种方式解决了回调函数的位置造成的难以维护的问题。</p><p>当然，一般的，我们并不会通过这种方式来进行<code>Observable</code>的创建，而是更多的通过创建操作符来进行<code>Observable</code>的创建，这些创建操作符内部封装了各种各样的从不同数据类型中创建<code>Observable</code>的方法，使我们可以方便快速的创建一个<code>Observable</code>。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个数组或者类数组对象中创建一个Observable</span></span><br><span class="line">Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个给定的事件类型中创建一个Observable</span></span><br><span class="line">Rx.Observable.fromEvent($(<span class="string">'button'</span>), <span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个Promise中创建一个Observable</span></span><br><span class="line">Rx.Observable.fromEvent($.ajax(<span class="string">'a/b'</span>))</span><br></pre></td></tr></table></figure><p>还有许多的创建操作符，在这里就不一一列举了。</p><p>通过这些操作符，我们就几乎具有了从任意的数据形式中快速创建<code>Observable</code>的能力。</p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>像上面的例子中一样，我们通过<code>Observable</code>的<code>subscribe</code>方法来对其进行订阅。</p><p>我们还需要向<code>subscribe</code>传递一个观察者对象作为参数来对接受到的值进行处理。</p><p>所谓观察者对象，也就是一个拥有<code>next</code>，<code>complte</code>，<code>error</code>方法的对象，作为<code>Observable</code>推送值的消费者，它这三种方法分别对应<code>Observable</code>发送的三种消息。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">observable = Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">observable.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x),</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'complete'</span>)</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们也可以只传递一个回调函数，此时<code>Observable</code>会使用内部方法创建一个观察者并使用此回调函数作为观察者的<code>next</code>方法。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x))</span><br></pre></td></tr></table></figure><p>我们也可以直接传递三个函数，这三个函数同样会被当做内部创建出的观察者的<code>next</code>，<code>error</code>，<code>complete</code> 方法。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(</span><br><span class="line">  x =&gt; <span class="built_in">console</span>.log(x),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.error(err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'complete'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>在上面我们提到一句，<code>Observable</code>是惰性的，这是什么意思呢？</p><p>其实就是一句话而已，<code>Observable</code>只有在每个观察者订阅之后才会执行。如果没有观察者，<code>Observable</code>内部的代码永远不会被执行。</p><p>同时，<code>Observable</code>的执行可以是同步的，也可以是异步的。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    observer.next(<span class="number">1</span>)</span><br><span class="line">    observer.next(<span class="number">2</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    next: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable.subscribe(observer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>如上所示，<code>Observerable</code>的内部执行是同步还是异步并无关紧要。重要的是，只有观察者存在时，它才会执行。</p><p>需要注意的是，订阅在同一个<code>Observable</code>的观察者之间是不共享的，每个订阅都会触发针对当前观察者的独立的设置和独立执行。这也是<code>Rxjs</code>与传统的事件和观察者模式之间最大的区别。</p><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>对于使用创建操作符进行创建的<code>Observable</code>，在订阅时，会返回一个<code>Subscription</code>，直白的说，就是订阅关系，在<code>Rxjs 4.0</code>之前，也叫做<code>disposable</code>，翻译过来就是<strong><em>可清理对象</em></strong>。</p><p>我们可以调用<code>Subscription</code>的<code>unsubscribe</code>方法，来取消订阅，<code>Observable</code>内部会自动的进行相关的资源清理和关闭。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个间隔一秒推送一个值的Observable</span></span><br><span class="line">observable = Rx.Observable.interval(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅并得到Subscription</span></span><br><span class="line"><span class="keyword">var</span> subscription = observable.subscribe(&#123;(x) =&gt; <span class="built_in">console</span>.log(x)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">subscription.unsubscribe()</span><br></pre></td></tr></table></figure><p><code>Subscription</code>还有一个<code>add</code>方法，用于将其他的<code>Subscription</code>合并进当前<code>Subscription</code>，当调用<code>unsubscribe</code>方法时，被合并进来的<code>subscription</code>也会被取消。</p><p>对应<code>add</code>还有一个<code>remove</code>方法，用于撤销已经添加进去的子<code>Subscription</code>。</p><p>对于通过构造函数创建的<code>Observable</code>，我们需要显式的返回一个自定义函数<code>unsubscribe</code>来进行相应的清理执行资源和取消执行。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">observable = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(intervalID);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过以上的介绍，相信大家对于<code>Observable</code>已经有了相对清晰和简单的认识。万事开头难，只要跨过了这个门槛，你会很快的发现<code>RxJs</code>特别的魅力，它是如此优雅和高效，其中蕴含的编程思想和智慧在某些时刻让人喜悦不已。</p><p>我想这大概也是计算机科学最大的魅力，一句简单的大道至简背后，是无数功力和智慧才铸就的举重若轻，实在让我这等凡夫俗子愚笨之徒艳羡。</p><p>ok，这篇博客就到这里，夜已深，不多说废话啦。多谢阅读，我们下篇博客再见^_^。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> RxJs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJs系列（一）：概述</title>
      <link href="/2018/09/04/RxJs%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/04/RxJs%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>异步编程作为代码世界中一个绕不开的话题，其与人类直观的同步思维相违背的代码执行顺序再加上复杂的状态管理，异常处理，控制权交接，数据传递，事件循环等等，经常让初入其中的程序员头昏脑涨，拐不过弯，屡屡翻车。</p><p>对<code>Js</code>来说，因为处在浏览器这个特殊语言环境和其单用户线程的特性，异步编程更是随处可见，在<code>Js</code>中具有举足轻重的地位。更别说在以异步无阻塞著称的<code>nodeJS</code>中，更是大部分的<code>API</code>都是异步的。异步编程的场景越来越复杂，异步处理的机制也越来越抽象。</p><p>从最早的回调函数，到类似<code>jQuery</code>的<code>eventemmiter</code>事件广播，再到<code>ES6</code>中的迭代器和<code>Promise</code>，再到<code>Es7</code>中的<code>async/await</code>函数，我们对<code>js</code>中异步的处理工具也日益丰富。今天要介绍的<code>rxjs</code>，也是用来处理<code>js</code>的异步编程问题的。不过，相比上面的那些异步处理机制，<code>rxjs</code>的适用场景更广，也更抽象，对使用者对异步问题的归纳和梳理能力，要求也更高，当然，学习曲线也是相当陡峭。</p><p>不过话又说回来，只要认真努力坚持不懈，我还没见过有什么技术是啃不下来的。今天看不懂就明天再看一遍，明天看不懂就大后天再看一遍(中间要休息一天，劳逸结合撒….),总是会大彻大悟之类的。</p><p>好啦，不闲扯了，进入正题。</p></blockquote><a id="more"></a><p>在最早的<code>js</code>中，我们使用回调函数来处理异步编程，但在存在条件判断和逻辑嵌套的异步场景中，回调函数可读性差，难以维护的问题(回调地狱）随之而来。</p><p>随后，又出现了事件机制，如<code>jQuery</code>中的<code>on</code>方法，<code>js</code>中的<code>trigger</code>，<code>addEventListener</code>等，但紧接着，我们发现，使用事件机制需要将程序改造成事件驱动，代码的运行流程会变得模糊和难以控制。</p><p>再接着，<code>Es6</code>的<code>Generator</code>和<code>Promise</code>出现了，通过语言特性层面的扩张，使我们对异步问题的处理更上了一个台阶，再加上<code>async/await</code>函数将<code>Generator</code>和<code>Promise</code>整合在一起，大家都以为<code>js</code>中的异步问题终于有了终极的解决方案。<br>但问题总比方法多，我们很快的发现，对于复杂的异步场景，例如多个异步请求的并行，串行，合并等等，我们仍然无法显著降低它们的复杂度，仍然需要用大量的代码来兜住这些场景。</p><p>这正是<code>Rxjs</code>所要解决的问题。</p><p><code>Rxjs</code>，具体的来说，就是<code>ReactiveX API</code>的<code>js</code>实现。</p><p><code>ReactiveX</code>，即<code>Reactive Extensions</code>的简写，一般我们称之为<code>Rx</code>，是由微软领导开发的一个异步编程模型，通过提供统一一致的编程接口，来帮助开发者更方便的处理<strong><em>异步数据流</em></strong>。它具有多种编程语言实现，例如<code>RxJava</code>，<code>Rx.NET</code>等等，</p><p>当然，<code>js</code>的实现，就是<code>Rxjs</code>。</p><p>在前端<code>Angular</code>框架的官方标配大礼包中，就包括了<code>Rxjs</code>，想用好<code>Angular</code>的同学，很有必要对它进行一些了解。当然，它的应用场景非常广泛，只要有复杂异步问题的地方，都是它大显身手的地方。同时因为在各种语言中的实现都比较类似，可以说是学会了一个，就会了所有，真正的学不了吃亏，学不了上当。。。。</p><p>在<code>Rxjs</code>中，所有的数据都被视为<code>stream</code>，也就是数据流。我们通过对数据流的订阅，来对其进行查询，过滤，归并等操作。<br>本质来说，数据流，对应的就是迭代器模式，订阅，显而易见对应的观察者模式，再通过函数式编程型的过滤归并查找删除。根据上面这段话，我们就可以对<code>Rxjs</code>下定义了:</p><blockquote><p><strong>一个结合了观察者模式，迭代器模式和函数式编程的异步事件管理库。</strong></p></blockquote><h3 id="安装和引入"><a href="#安装和引入" class="headerlink" title="安装和引入"></a>安装和引入</h3><p>首先来说一下<code>Rxjs</code>的安装和引入，像其他的<code>npm package</code>一样，<code>Rxjs</code>的安装和引入也十分简单。<br>执行下面命令即可安装。<br></p><figure class="highlight shell"><figcaption><span>Shell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rxjs</span><br></pre></td></tr></table></figure><p></p><p>引入完整的<code>Rxjs</code>包后，项目的打包体积大概会增加50KB左右，还是比较重的一个库。因此我们也可以选择性的引入我们需要的部分，例如特定的操作符等等。<br>当然，在我们学习的阶段，完整引入即可。打包体积这些东西，是我们到熟练掌握它的时候才需要去碰的。<br>下面分别是通过<code>Es6</code>方式引入和通过<code>CommonJs</code>方式引入的方式。<br><strong><em>ES6</em></strong><br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个核心功能</span></span><br><span class="line"><span class="keyword">import</span> Rx <span class="keyword">from</span> <span class="string">'rxjs/Rx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分功能引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs/Observable'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'rxjs/add/observable/of'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'rxjs/add/operator/map'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只引入特定操作符</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">of</span> &#125; <span class="keyword">from</span> <span class="string">'rxjs/observable/of'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operator/map'</span>;</span><br></pre></td></tr></table></figure><p></p><p><strong><em>CommonJs</em></strong><br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个核心功能</span></span><br><span class="line"><span class="keyword">var</span> Rx = <span class="built_in">require</span>(<span class="string">'rxjs/Rx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分引入</span></span><br><span class="line"><span class="keyword">var</span> Observable = <span class="built_in">require</span>(<span class="string">'rxjs/Observable).Observable</span></span><br><span class="line"><span class="string">require('</span>rxjs/add/observable/<span class="keyword">of</span><span class="string">')</span></span><br><span class="line"><span class="string">require('</span>rxjs/add/operator/map<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">只引入特定操作符</span></span><br><span class="line"><span class="string">var of = require('</span>rxjs/observable/<span class="keyword">of</span><span class="string">').of;</span></span><br><span class="line"><span class="string">var map = require('</span>rxjs/operator/map<span class="string">').map;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><p><code>Rxjs</code>以流的形式来处理数据，这个数据是抽象意义的，可以是<code>ajax</code>请求，可以是<code>DOM Event</code>，也可以是个普通数组。<br>数据流是通过<code>Observable</code>可观察对象来体现的，我们通过对<code>Observable</code>进行<code>subscribe</code>来获取它其中的数据。<br>我们以一个简单的输入框事件来举例Rxjs的应用:<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</span><br><span class="line"></span><br><span class="line">Rx.Observable.fromEvent(input, <span class="string">'input'</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">    .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p></p><p>在上面这个例子中，我们通过<code>Rx.Observable.fromEvent</code>这个创建操作符方法生成了一个<code>Observable</code>，并通过<code>map</code>操作符获取到了输入的值，并随之<code>subscribe</code>了这个<code>Observable</code>，在每次输入事件发生时打印出输入的值。<br>你可能会觉得，这也没什么神奇的嘛，不就是我们平常普通的事件回调换了一个写法嘛。<br>的确，在普通的单个异步事件处理中，Rxjs并没有什么特别的地方。别忘了我们前面提到的，Rxjs以流的形式处理数据，对于单次的事件来说，并不能形成时间线维度上流的概念，所以Rxjs并没有可以大展身手的地方<br>。<br>现在我们来更进一步，我们想实现一个比较常见的需求，在输入停止两秒后才进行响应，防止用户在输入过程中不停触发响应造成的性能浪费。<br>如果是普通的回调函数形式，我们可能需要自己来写一个<code>debounce</code>函数或者引入提供此功能的相关类库，来对用于响应的回调函数进行封装。<br>但在<code>Rxjs</code>中，我们非常容易的通过一个操作符就可以实现这一需求。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(input, <span class="string">'input'</span>)</span><br><span class="line">    .debounceTime(<span class="number">200</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">    .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p></p><p>通过<code>debounceTime</code>操作符，我们顺利的实现了这个功能。<br>你可能觉得，这也只是一个小小的功能嘛，有什么神奇的。<br>那现在我们又来了一个需求，我们需要对输入的字符进行去重操作。此时如果你还是普通的回调形式来处理事件的话，可能回调函数已经嵌套了三层了。<br>但是使用<code>Rxjs</code>，非常简单的再加一个操作符：<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(input, <span class="string">'input'</span>)</span><br><span class="line">    .debounceTime(<span class="number">200</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">    .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p></p><p>是不是觉得<code>Rxjs</code>有点厉害了，但其实处理输入事件这种东西，还只是<code>Rxjs</code>功能的冰山一角而已。<br>我们来一个更复杂的需求，举例来说，我们有<code>api/a</code>，<code>api/b</code>,<code>api/c</code>三个<code>AJAX</code>请求,现在我们需要它们串行的发出，也就是前一个结束再发出下一个。<br>如果使用普通的回调函数形式，我们要这样写:<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'api/a'</span>, () =&gt; &#123;</span><br><span class="line">  ajax(<span class="string">'api/b'</span>, () =&gt; &#123;</span><br><span class="line">    ajax(<span class="string">'api/c'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'complete'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>显而易见，在实际项目中处理请求结果的逻辑会相当复杂，这样一层套一层太恐怖了。比如现在我们需要在<code>api/b</code>和<code>api/c</code>请求之间再加一个<code>api/o</code>请求，你看着一堆叠罗汉一样的代码，肯定心里想的是，这可咋整啊？<br>有的同学可能会说，用<code>Promise</code>不就得了。那我们就用<code>Promise</code>形式再重构一下上面这个回调地狱。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'api/a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ajax(<span class="string">'api/b'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ajax(<span class="string">'api/c'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'complete'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>可以看出，使用<code>Promise</code>大大提升了我们代码的可维护性，但是连续的<code>then</code>链也不是那么美观和易读。而且，它也并不是完美的。举例来说，现在我们突然接到需求，需要将三个串行的请求改成并行的，你会想，改成<code>Promise.all</code>不就行了。<br>但要明白的是，在实际项目中，我们每个请求的处理逻辑可不单单是这几行的代码量。你需要将每个请求的代码粘出来，再拼装成一个数组传递给<code>Promise.all</code>。面对着一两百行的代码，你心里又开始想了。好嘛！这可咋整。<br>那如果使用<code>Rxjs</code>是怎么解决的呢？看代码<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ob1 = Observable.ajax(<span class="string">'api/a'</span>)</span><br><span class="line"><span class="keyword">const</span> ob2 = Observable.ajax(<span class="string">'api/b'</span>)</span><br><span class="line"><span class="keyword">const</span> ob3 = Observable.ajax(<span class="string">'api/c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obs = [ob1, ob2, ob3]</span><br><span class="line"></span><br><span class="line"><span class="comment">//串行</span></span><br><span class="line">Observable.concat(...obs).subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行</span></span><br><span class="line">Observable.merge(...obs).subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p></p><p>是不是非常优雅，非常NB？这就是Rxjs的强大之处，它通过引入<code>Js</code>中比较少见的流这个概念，将异步，队列，回调等等完美的归纳融合在一起形成了一个统一的异步事件处理模型。<br>当然，极高的抽象程度也意味者陡峭的学习曲线。不过不用担心，只要理解了<code>Rxjs</code>的思想，具体的细节语法，还是十分的统一和易懂的。</p><p>通过上面两个<code>Rxjs</code>在<code>DOM</code>事件和<code>HTTP</code>请求中的两个小场景，大家应该在心里对<code>Rxjs</code>有了一个基本的概念和印象。这也是作为<code>Rxjs</code>系列博客的第一篇主要想达到的目的。先不去探究和深入它的具体细节，而是大概了解一下它的相关背景和一些基础的适用场景。<br>至于<code>Rxjs</code>是如何在代码层面实现这些看起来非常酷炫的展现出极高的抽象色彩的功能的呢？带着好奇心的学习总是会带来极高的效率。<br>我将会在下一篇博客中，重点介绍<code>Rxjs</code>的核心概念————<strong><em>Observable</em></strong>, 就是通过它，我们将所有的数据都转换为数据流的形式，从而优雅高效的以完全同步编程的方式来处理异步，极大简化了在时间线上错综复杂纠缠不清令人头疼的异步编程问题。<br>ok，谢谢阅读，我们下篇博客再见^-^。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> RxJs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十七）：Vue Router基础</title>
      <link href="/2018/08/22/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%83%EF%BC%9AVue%20Router%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/22/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%83%EF%BC%9AVue%20Router%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>Vue Router 作为官方的路由器库，基本涵盖了一个前端<code>SPA</code>项目路由所需的所有功能。从路由的动态参数，嵌套路由，命名路由以及重定向等基础功能到懒加载，路由守卫等高阶功能，这一个库都可以说完全够用了。</p><p>作为一个<code>Vue</code>的官方指定库，风格肯定跟<code>Vue</code> 是兄弟俩，上手非常简单，只要理解了前端<code>SPA</code>路由的基本概念和逻辑，就可以愉快的使用起来。</p><p>跟<code>Vue</code>一样，简单容易上手的代价，就是当项目代码增长到一定规模，路由开始变得复杂起来时，它的各种路由子路由命名视图的嵌套，各种路由钩子，重定向，路径参数等等，再加上权限控制，路由动态跳转等等，混杂在一起，还是非常考验项目成员的维护和管理水平的。再加上没有类似<code>Angular</code>那样细致到模块的路由控制粒度，在多人开发情况下，还是比较容易造成混乱的。</p><p>当然，<code>Vue</code>本来的缺点，也不应该全怪罪到<code>Vue Router</code>身上。</p><p>从自身做起，对代码负责，提高自己对框架和库的了解程度以及技术水平，来尽量写出易维护的代码，才是应该去认真思考的问题，与大家共勉。</p><p>好了，不多说废话。这篇博客，就主要来介绍一下<code>Vue-router</code>的基本知识和使用。</p></blockquote><a id="more"></a><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>一个最基础的vue router 配置的例子，如下所示：</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过HTML进行路由导航</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/a"</span>&gt;</span>Go to A<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/b"</span>&gt;</span>Go to B<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 路由出口</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span>  <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'./A'</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'./B'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　使用模块化而不是通过`script`标签引入vue和vue-router时需要如下调用</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//　定义路径到组件映射</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A&#125;</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/b'</span>, <span class="attr">component</span>: B&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 路由器 router 实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由器实例注入到 Vue 根实例中</span></span><br><span class="line"><span class="comment">// 这样在所有子组件中都可以使用`this.$router`来得到路由器实例</span></span><br><span class="line"><span class="comment">// 而不必在每个子组件中都引入`router`实例。</span></span><br><span class="line"><span class="comment">// 同时我们还可以通过`this.$route`来访问当前页面的路由对象。</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h3 id="路由定义"><a href="#路由定义" class="headerlink" title="路由定义"></a>路由定义</h3><p>路由也就是路径到组件的映射关系对象组成的数组，将其传递给<code>VueRouter</code>来生成路由实例。<br>基础的路由数组如下:<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">      &#123;<span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A&#125;</span><br><span class="line">      &#123;<span class="attr">path</span>: <span class="string">'d'</span>, <span class="attr">component</span>: D&#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>嵌套路由中，每一层路由对应一层嵌套的组件,可嵌套多层。<br>通过路由表中的<code>children</code>属性来定义路由的嵌套子层级，属性值为子层级的路由表<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">    routers: [</span><br><span class="line">    　<span class="comment">// 带 / 的会被当做根路径，不会自动跟随到父路径之后</span></span><br><span class="line">      &#123;<span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A,</span><br><span class="line">       children: [</span><br><span class="line">       </span><br><span class="line">         <span class="comment">//　当基于'/a'的路径无匹配时(例如/a和/a/z)渲染到出口的默认组件</span></span><br><span class="line">         &#123;<span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: B&#125;</span><br><span class="line">         &#123;<span class="attr">path</span>: <span class="string">'c'</span>, <span class="attr">component</span>: C&#125;</span><br><span class="line">         &#123;<span class="attr">path</span>: <span class="string">'d'</span>, <span class="attr">component</span>: D&#125;</span><br><span class="line">         </span><br><span class="line">       ]&#125;</span><br><span class="line">    ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>某些路由的路径比较长时，我们在导航到其时会比较麻烦。可以通过为路径配置一个标志名称<code>name</code>来为路由命名。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/user'</span>, </span><br><span class="line">        name: <span class="string">'user'</span></span><br><span class="line">        component: User</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><p>通过配置<code>redirect</code>属性来实现访问某个路径时重定向到另一个路径。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以重定向到一个命名路由</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/c'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'d'</span> &#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通过函数值来实现更复杂的重定向</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>关于重定向有一个需要注意的地方是路由的导航守卫只会作用在重定向的目标路径上，在被重定向的路径上不会触发。</p><h4 id="路由别名"><a href="#路由别名" class="headerlink" title="路由别名"></a>路由别名</h4><p>可以通过<code>alias</code>属性为路由起一个别名,从而实现多个URL路径访问一个路由的效果。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">    <span class="comment">// 绝对路径别名</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'foo'</span>, <span class="attr">component</span>: Foo, <span class="attr">alias</span>: <span class="string">'/foo'</span> &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相对路径别名</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'bar'</span>, <span class="attr">component</span>: Bar, <span class="attr">alias</span>: <span class="string">'bar-alias'</span> &#125;,</span><br><span class="line">    </span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'baz'</span>, <span class="attr">component</span>: Baz, <span class="attr">alias</span>: [<span class="string">'/baz'</span>, <span class="string">'baz-alias'</span>] &#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>通过命名视图，可以将一个路径对应到多个组件，来实现多个组件的渲染<code>代码</code>。如下:<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routers: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'homePage'</span>, <span class="attr">component</span>: &#123;</span><br><span class="line">      <span class="keyword">default</span>: HomePage,</span><br><span class="line">      sidebar: SideBar,</span><br><span class="line">      navbar: NavBar</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//　默认default组件的渲染出口</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 命名为navbar组件的渲染出口</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"navbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 命名为sidebar的组件的渲染出口</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"sidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p>通过<code>meta</code>属性可以为路由设置元信息，来使路由携带一些与路由自身有关的属性值，类似权限属性，页面<code>title</code>，面包屑中的路由名称等。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'foo'</span>, <span class="attr">component</span>: Foo, <span class="attr">meta</span>: &#125;,</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><p>随后，我们可以通过当前页面对象<code>this.$route</code>的<code>matched</code>属性, 或者路由守卫中的<code>to</code>参数的<code>to.matched</code>来获取当前路由及其子路由的路由定义数组,再遍历得到路由的<code>meta</code>元信息,形如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$route.matched.meta</span><br><span class="line"></span><br><span class="line">// 路由守卫的参数`to`也就是路由前往目标页面的`this.$route`。</span><br><span class="line">to.matched.meta</span><br></pre></td></tr></table></figure><p></p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>在路由的路径中，我们经常会带上一些参数。例如<code>user/22</code>用于显示<code>id</code>为22的用户,<code>user/33</code>用于显示<code>id</code>为33的用户。通过动态路由参数，我们将一个组件映射到多个路由。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User&#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><h4 id="路径匹配规则"><a href="#路径匹配规则" class="headerlink" title="路径匹配规则"></a>路径匹配规则</h4><p>除了使用<code>/:id</code>来通配路径，还可以通过更高级的高级匹配模式来定义更复杂的路径到组件的映射关系。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> VueRouter([</span><br><span class="line">  routers: [</span><br><span class="line">     <span class="comment">//  仅匹配数字</span></span><br><span class="line">     &#123;<span class="attr">path</span>: <span class="string">'/user/:id(\\d+)'</span>, <span class="attr">component</span>: User&#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 匹配任意路径</span></span><br><span class="line">     &#123; <span class="attr">path</span>: <span class="string">'/a/*'</span>, <span class="attr">component</span>: a&#125;,</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//　可选路径</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/c/:foo?'</span>, <span class="attr">component</span>: c&#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/d/(foo/)?bar'</span>, <span class="attr">component</span>: d&#125;</span><br><span class="line">  ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><p>具体可参考<code>vue-router</code>所使用的 <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>路径匹配引擎的介绍。<br>对于路径的模式匹配来说，如果URL可以匹配到多个路径，先定义的路径具有更高的优先级。</p><h4 id="获取路径参数"><a href="#获取路径参数" class="headerlink" title="获取路径参数"></a>获取路径参数</h4><p>通过当前页面的路由对象<code>this.$route</code>可以得到当前页面的路由路径参数。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $route.params 为一个`key/value`对象，包含所有动态匹配的路由参数(也就是带冒号的路径</span></span><br><span class="line"><span class="comment">// 若路径无参数，则为空对象</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="keyword">this</span>.$route.params.id</span><br></pre></td></tr></table></figure><p></p><p>除了<code>params</code>属性，路由对象<code>$route</code>还有以下属性:</p><ul><li><code>path</code><br>当前路由的路径字符串(不包含查询参数和锚点信息</li><li><p><code>query</code><br>当前路由的查询参数对象<br>若无查询参数，则为空对象</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　例如路径/user?age=3,有以下query</span></span><br><span class="line"><span class="keyword">this</span>.$route.query.age === <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><code>hash</code><br>路由携带的锚点信息字符串</p></li><li><p><code>fullPath</code><br>完整的包含查询参数和锚点信息的路径字符串</p></li><li><p><code>name</code><br>当前路由的名称(若当前路由无名称则为<code>undefined</code></p></li><li><p><code>redirectedForm</code><br>当前路由的重定向来源路由名称</p></li><li><p><code>matched</code><br>当前路由和它的嵌套的子路由的路由定义值数组（即我们传递给<code>new VueRouter</code>数组中与当前路由有关的部分组成的数组</p></li></ul><p>另外需要注意的一点是，路由对象<code>$route</code>是只读的。</p><h4 id="使用props将路由与组件解耦"><a href="#使用props将路由与组件解耦" class="headerlink" title="使用props将路由与组件解耦"></a>使用<code>props</code>将路由与组件解耦</h4><p>通过<code>URL</code>传递参数，在组件中使用<code>this.$route.params</code>获取参数，意味着我们将路由和组件耦合在了一起。在其他路由的地方，我们就无法复用组件了。<br>可以通过路由定义中的<code>props</code>参数，来将路由参数和<code>$route</code>解除耦合。<br>使得我们在路由中携带的参数，作为组件的<code>props</code>的一个值传入，从而使我们在其他任何地方都可以使用该组件。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'user'</span>,</span><br><span class="line">  </span><br><span class="line">  props: [id]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">     <span class="comment">//　当设置props属性为true时，路由中的参数将作为props传递给路由映射到的组件</span></span><br><span class="line">     &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 也可以将props属性的值设置为一个对象</span></span><br><span class="line">     <span class="comment">// 此时对象中的值会原封不动的传递给组件的props作为prop</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: &#123;<span class="attr">aprop</span>: a&#125; &#125;,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 还可以将路由props属性设置为返回一个对象的函数</span></span><br><span class="line">    <span class="comment">// 从而组合路由相关值或静态值作为组件props的prop</span></span><br><span class="line">    ｛　path: <span class="string">'/user'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;<span class="attr">aprop</span>: route.query.prop&#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>有两种路由的导航方式,　分别是在<code>HTML</code>中和在<code>JS</code>中。</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><strong><em>HTML</em></strong></h4><p>在 HTML 中，通过<code>&lt;router-link&gt;&lt;/router-link&gt;</code>组件来定义路由跳转导航。如下:<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/foo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 导航可以携带参数和查询参数</span></span><br><span class="line">&lt;router-link :to="&#123;path: '/user/33', query: &#123;age: 20&#125;&#125;"&gt;</span><br></pre></td></tr></table></figure><p></p><p><code>router-link</code>组件的<code>to</code>属性，可以接收的参数格式与<code>router</code>实例的路由导航方法<code>push</code>和<code>replace</code>相同。</p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong><em>JavaScript</em></strong></h4><p>在JS中，可以通过路由实例<code>router</code>的方法，来进行更复杂的导航:<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.push(<span class="string">'/foo'</span>)</span><br><span class="line"></span><br><span class="line">router.replace(<span class="string">'/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//　倒退３步</span></span><br><span class="line">router.go(<span class="number">-3</span>)</span><br></pre></td></tr></table></figure><p></p><p>如果将<code>router</code>实例注入了根组件，可以在组件中使用<code>this.$router</code>来访问<code>router</code>实例:<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'home'</span>)</span><br></pre></td></tr></table></figure><p></p><p><code>router</code>实例有以下几种导航方法:</p><ul><li><code>push</code><br>接收一个路由地址作为参数。路由地址可以是一个路径字符串，也可以是一个地址对象,如下:<figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"></span><br><span class="line">router.push(&#123;<span class="attr">path</span>: <span class="string">'home'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 携带查询参数</span></span><br><span class="line">router.push(&#123;<span class="attr">path</span>: <span class="string">'user/10'</span>, <span class="attr">query</span>: &#123; <span class="attr">age</span>: <span class="number">33</span>&#125; &#125;)</span><br><span class="line">router.push(&#123;<span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">10</span>&#125;,  <span class="attr">query</span>: &#123; <span class="attr">age</span>: <span class="number">33</span>&#125; &#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>需要注意如果路由对象中有<code>path</code>属性，那么就意味着<code>params</code>已经被携带在了路径里，如果对象中还定义了<code>params</code>，则会被忽略。</p></blockquote><p>在上面的<code>HTML</code>导航中我们提到的<code>router-link</code>组件的导航方式，导航时就是调用的<code>push</code>方法。因此它的<code>to</code>属性可以接受的参数格式和<code>push</code>方法完全一致。</p><p><code>push</code>方法还可以接受两个可选的函数参数<code>onComplete</code>和<code>onAbort</code>, 这两个函数分别会在导航成功完成和未成功时(即导航到相同路由或另一个非目标路由）时调用。</p><ul><li><p><code>replace</code><br><code>replace</code>与<code>push</code>的接受参数完全相同，效果也完全相同。唯一不同的时，<code>push</code>会在浏览器<code>history</code>记录中添加一条当前页面的记录，可以通过后退返回当前页。而<code>replace</code>则会直接使用导航到的目标页替换掉当前页的记录。</p></li><li><p><code>go</code><br>接受一个数字作为参数，用于在历史记录中前进(参数为正)或回退数字参数(参数为负)步。</p></li><li><p><code>back</code><br>在历史记录中后退一步</p></li><li><p><code>forward</code><br>在历史记录中前进一步。</p></li></ul><p>对于<code>Vue Router</code>的基本的知识，大概就这么多了。下篇博客中，将会介绍一下关于<code>Vue Router</code>的一些进阶功能，例如路由导航守卫，<code>transtion</code>动画等。</p><p>后续博客打算介绍一下<code>rxjs</code>，刚接触的时候觉得实在是太厉害的一套信息流动管理思想了，但这么久了，并没有看到它在前端领域像期望的一样大热起来，还是只有<code>angular</code>在用，也是蛮遗憾的。<br>当然，计划是这样，但也保不住我被别的东西吸引去注意力。比如买来很久了的《Go语言入门经典》还没怎么看哈哈。<br>好了，这篇博客就到这里啦，篇幅较长，多谢阅读，多谢多谢。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十八）：Vue Router进阶</title>
      <link href="/2018/08/22/Vue%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue-Router%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/08/22/Vue%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9AVue-Router%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在本篇博客中，主要来介绍一下　<code>Vue　Router</code>　中的一些进阶功能，例如路由守卫，懒加载等。</p><p>话说最近有在考虑自己建一个站，这样鼓捣一些东西也方便一些，同时也能把博客迁移过去。虽然一想到网站备案什么的还是蛮头疼的，但还是先提上日程再说哈哈。</p><p>要做的事情还是蛮多的，虽然自诩自制力还不错，但想要沉下心来做一些事情，也还是一件异常困难的事情啊。</p></blockquote><a id="more"></a><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><p>路由导航，即路由的前进后退跳转等，更明确的说，也就是路由改变时，进行的动作。<br>通过设置导航守卫，我们可以对路由导航进行编程式的控制，例如在离开页面时提示是否确定离开，在判断用户无<code>token</code>时跳转到登录页面等。</p><blockquote><p>路由的导航守卫仅仅是路径参数或查询参数变化时，例如<code>user/22</code>导航到 <code>user/33</code>时是不会触发的。<br>对于这种变化，可以通过<code>watch</code> 组件<code>$route</code>页面路由对象或者通过组件的路由守卫<code>beforeRouteUpdate</code>来实现。</p></blockquote><p>路由导航守卫分为全局的导航守卫，单个路由的导航守卫和组件内的守卫。</p><h4 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h4><ul><li>全局导航守卫,注册在<code>router</code>实例上，有以下三个:<ul><li><code>beforeEach</code> 全局守卫</li><li><code>beforeResolve</code> 全局解析守卫</li><li><code>afterEach</code> 全局路由后置钩子</li></ul></li></ul><p><strong><em>beforeEach((to, from, next) =&gt; {})</em></strong><br>全局的路由导航前置守卫，在路由改变,导航触发时会进行异步解析(也就是通常所说的resolve过程)。</p><p>在导航守卫解析完毕之前，路由导航会一直处于等待之中。</p><p>当有多个路由守卫时，会按照创建顺序依次调用。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;...&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span> ,next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>守卫方法会被传入如下三个参数:</p><ul><li><code>to</code>　 进入页面的页面路由对象<code>route</code></li><li><code>from</code> 离开页面的页面路由对象<code>route</code></li><li><code>next</code>　此参数的值为一个函数, 通过调用此函数来<code>resolve</code>守卫，使导航继续。根据<code>next</code>的参数不同，会有不同表现:<ul><li><code>next()</code> 无参数时，表示此守卫已解析完毕，进入下个导航钩子函数, 若无后续导航钩子，则导航完成。</li><li><code>next(&#39;/&#39;)</code> 参数为一个路径或路径对象时，则跳转到对应路径。可接受与<code>router.push</code>同样类型的参数</li><li><code>next(false)</code> 参数为<code>false</code>，终止导航，如果路径已经改变，则返回到<code>from</code>对应的页面。</li><li><code>next(error)</code> 参数为<code>Error</code>类型，则导航终止同时触发<code>router.onError</code></li></ul></li></ul><p>需要注意的是，在守卫的回调函数中必须确保调用<code>next</code>, 保证守卫被<code>resolve</code>。<br>尤其注意的是，在<code>if</code>逻辑判断的每个分支中都要调用。</p><blockquote><p><code>router.onError</code> 接受一个函数作为参数,当导航过程中出现错误时函数会被调用</p></blockquote><p><strong><em>beforeResolve((to, from , next) =&gt; {})</em></strong><br>全局解析守卫，在所有组件内守卫和异步组件加载完毕之后,路由导航即将完成之前调用。<br>接收一个函数作为参数，传入函数的参数与<code>beforeEach</code>相同，为<code>to</code>,<code>from</code>，<code>next</code>。</p><p><strong><em>afterEach((to, from) =&gt; {})</em></strong><br>全局路由导航后置钩子，在路由导航完成之后会被调用。接收一个函数作为参数，传入函数的参数是没有<code>next</code>的，因为调用时导航已经是完成状态。</p><h4 id="特定路由守卫"><a href="#特定路由守卫" class="headerlink" title="特定路由守卫"></a>特定路由守卫</h4><p>特定路由守卫只有一个:<code>beforeEnter</code>, 直接在路由配置上定义，类似于全局守卫<code>beforeEach</code>，但只作用于当前对应路由。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A, </span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; <span class="comment">// ... &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h4 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h4><p>组件内守卫有以下三个，用于守卫当前组件对用的路由:</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code></li><li><p><code>beforeRouteLeave</code><br>使用方法类似于<code>Vue</code>组件的生命周期函数，均接受三个参数<code>to</code>,　<code>from</code>，<code>next</code>。<br>可以在此守卫中获取页面的初始化数据，来代替一般使用的组件<code>created</code>声明周期函数和监听器获取数据的方式。详细可见我的<a href="https://gyufei.github.io/2018/07/20/%E5%85%B3%E4%BA%8EVue%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" target="_blank" rel="noopener">另一篇博客中</a><code>Vue</code>页面初始数据获取的相关内容</p><p><strong><em>beforeRouteEnter(to, from, next)</em></strong><br>在进入所在组件的路由时调用。<br>重要的一点是，此函数被调用时，路由还未导航完成，组件还处于未创建状态，是无法访问组件的<code>this</code>实例的。<br>如果需要访问组件实例，可以传递一个参数为组件实例的回调函数到<code>next</code>中。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    cosnt msg = fetchMsg()</span><br><span class="line">    next( <span class="function"><span class="params">vm</span> =&gt;</span> &#123; vm.msg = msg &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>也只有此守卫的<code>next</code>方法可以接受回调函数作为参数。<br>对于其他两个导航守卫<code>beforeRouteUpdate</code>和<code>beforeRouteLeave</code>来说，因为可以访问<code>this</code>，所以不能也不需要接受一个参数为组件实例的回调函数来访问组件。</p><p><strong><em>beforeRouteUpdate(to, from, next)</em></strong><br>在当前路由发生了变化，但并未重新渲染组件，而是复用当前组件时被调用。<br>在开篇我们提到，其它的路由导航守卫是不响应路由路径参数和查询参数的变化的。<br>类似于<code>user/22</code>到<code>user/33</code>这种路由变化，组件会被复用,　进而导致我们修改路由后组件的数据并不会重新响应和获取。<br>如果我们想监测路由路径参数或查询参数变化，进而重新获取数据或者进行一些操作，可以通过此守卫来实现。<br>当然，通过<code>watch</code>页面的路由对象<code>$route</code>，也可以达到相同的效果。</p><p><strong><em>beforeRouteLeave(to, from, next)</em></strong><br>当离开此组件所对应路由，导航向其他路由时触发。<br>可以在此函数中进行未保存提示等操作。<br>可以通过在守卫中调用<code>next(false)</code>来取消导航，停留在当前组件。</p><h4 id="路由守卫的调用顺序"><a href="#路由守卫的调用顺序" class="headerlink" title="路由守卫的调用顺序"></a>路由守卫的调用顺序</h4><p>在一次完整的导航中，各路由守卫的触发和调用顺序如下:</p><ol><li>导航触发</li><li>在离开的组件中调用<code>beforeRouteLeave</code></li><li>调用全局路由守卫<code>beforeEach</code></li><li>调用特定路由配置守卫<code>beforeEnter</code></li><li>导入异步组件</li><li>在激活的组件中调用<code>beforeRouterEnter</code></li><li>调用全局解析守卫<code>beforeResolve</code></li><li>导航完成</li><li>调用全局导航后置钩子<code>afterEach</code>123232</li><li>调用传递给<code>beforeRouteEnter</code>的<code>next</code>函数的回调函数</li></ol><h3 id="路由模式mode"><a href="#路由模式mode" class="headerlink" title="路由模式mode"></a>路由模式mode</h3><p><code>Vue Router</code>支持三种模式的<code>URL</code>, 分别为:</p><ul><li><code>hash</code>模式(浏览器环境下默认模式</li><li><code>history</code>模式</li><li><code>abstract</code>模式（node.js环境下默认模式</li><li>可以在<strong><em>vue-router</em></strong>的配置中定义使用何种模式:<figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: history,</span><br><span class="line">  routes: [...],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前浏览器不支持 histroy 模式时是否回退到 hash 模式,默认为 true。</span></span><br><span class="line">　<span class="comment">// 除了服务端渲染应用要工作在IE9模式下，否则一般都应该设置为 true</span></span><br><span class="line">  fallback: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a><strong><em>hash模式</em></strong></h4><p>即通过URL的<code>hash</code>来在单页面应用中模拟 URL的模式。类似<code>URL</code>如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.aaaa.com/app/#/hoempage/friends</span><br></pre></td></tr></table></figure><p></p><p><code>hash</code>模式背后的原理是浏览器的<code>onhashchange</code>事件，通过检测<code>URL</code>的哈希变化，来实现前端路由。<br>对于哈希模式来说，发送到后端的请求是始终不会包含哈希之后的前端路径内容的。项目的路由路径匹配，是始终在前端进行的。</p><h4 id="histroy模式"><a href="#histroy模式" class="headerlink" title="histroy模式"></a><strong><em>histroy模式</em></strong></h4><p>通过<code>HTML5</code>中提供的<code>history api</code>，前端路由也可以拥有完全的路径自由，不必再在路径中添加丑陋的哈希了。</p><blockquote><p>HTML History API 为开发人员提供了在不刷新整个页面下修改当前<code>URL</code>的功能。<br>有以下几个<code>API</code>:</p><ul><li>froward 前进</li><li>back　后退</li><li>go 跳转</li><li>pushState 保存历史状态, 接收三个参数，URL对应的状态数据<code>state</code>，页面<code>title</code>，和 URL</li><li>replaceState 替换历史状态</li></ul></blockquote><p>在<code>histroy</code>模式中，URL表现与正常的非SPA项目基本完全一致。<br>但与<code>hash</code>模式相比，存在一个问题，在此模式下，页面刷新时，会向服务器发起请求，但服务器并没有对应的路由，就会出现<code>404</code>错误,因此需要在后端进行相应的配置：对于任何的与前端项目有关的路径，都应该返回前端项目的根目录路径，从而让前端能够接管到路由并进行匹配。</p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>在导航到某个组件时，可以通过<strong><em>Vue Router</em></strong>的滚动行为来控制页面滚动到某个位置。<br>通过在路由配置项中定义<code>scrollBehavior</code>方法，来在路由切换时自定义控制页面滚动。<br><code>scrollBehavior</code>接受三个参数，<code>to</code>和<code>from</code>为进入和离开页面的页面路由对象。<br><code>savedPosition</code>应用于页面通过记录原生的浏览器前进后退按钮导航时的滚动位置，通过返回此值，可以模拟浏览器原生的滚动行为。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个的位置的对象信息:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &#123;x: 20, y: 20&#125;  可以是坐标形式的位置信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &#123;selector: '#mid' &#125;  也可以是选择器形式的位置信息</span></span><br><span class="line">    <span class="comment">// &#123;selector: '#mid', offset: &#123;x: 20, y: 20&#125; &#125;  还可以定义距离选择器元素的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// new Promise(...)   可以返回一个异步的`Promise`值来使滚动配合页面的过渡效果。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 false 或　空对象则不滚动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载，也就是通常所说的路由异步加载，对于某些非核心组件，只在需要组件时进行异步加载，从而提高项目的首屏加载速度。<br>在<strong><em>Vue　Router</em></strong>中，使用异步加载是非常简单的，我们只需要将组件设置为异步组件，当路由对应到此组件时，就会异步加载。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./A.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>同时我们还可以通过<strong><em>WebPack</em></strong>的<code>命名chunk</code>, 来将一些异步组件打包到同一个块中，在路由加载其中一个时，就会获取其他所有的异步组件，从而更好的组织我们的路由组件的加载。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./A.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./B.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> C = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./C.vue'</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id="router-link标签"><a href="#router-link标签" class="headerlink" title="router-link标签"></a><code>router-link</code>标签</h3><p>在上一篇博客中我们提到在<strong><em>HTML</em></strong>中，我们可以通过<code>&lt;router-link&gt;&lt;/router-link&gt;</code>标签来进行路由导航。<br>相比于<code>a</code>标签，<code>router-link</code>标签对<code>Vue Router</code>的路由跳转兼容性和配合性更好，同时它还可以接受一些属性来达到功能上的增强:</p><ul><li><code>to</code><br>在<a href="https://gyufei.github.io/2018/08/22/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%83%EF%BC%9AVue%20Router/" target="_blank" rel="noopener">上篇博客</a>的路由导航中介绍过，用于设置跳转对象，相当于<code>a</code>标签的<code>href</code>属性，不同之处在于除了可以接受路径字符串，还可以接受<code>vue-router</code>路径对象。</li><li><code>replace</code><br>布尔值属性，当添加此属性时，在点击<code>router-link</code>标签时，会调用路由器<code>router</code>的<code>replace</code>方法进行导航，而不是<code>push</code></li><li><code>append</code><br>布尔值属性，当添加此属性时，则将当前页面路径作为根路径进行跳转。</li><li><code>tag</code><br>指定<code>router-link</code>标签在真实<code>HTML</code>中渲染出的标签。可以为<code>li</code>标签，<code>span</code>标签等。在<code>router-link</code>中有<code>slot</code>内容时，非常实用。</li><li><code>active-class</code><br>当前标签对应路径匹配路由跳转路径时自动添加的<strong><em>CSS</em></strong>类名。</li><li><code>exact</code><br>布尔值属性，是否关闭路径的全包含匹配,默认是开启的，也就是说，只要路由跳转路径中包含当前标签的对应跳转路径，无论是否完全对应，都会为标签添加<code>active-class</code>指定的类名。<br>使用<code>exact</code>属性，则只有路由导航跳转路径完全匹配当前标签对应跳转路径时，才会添加类名。</li><li><code>exact-active-class</code><br>当前标签对应路径完全匹配路由跳转路径时自动添加的<strong><em>CSS</em></strong>类名。</li><li><code>event</code><br>用来触发导航的事件名。通常标签都是通过<code>click</code>来触发路由导航，当然也可以通过其他事件来触发，不过不常见，用户体验较差。</li></ul><blockquote><p>可以在<code>Router</code>的构建选项中设置<code>router-link</code>标签的的全局默认<code>active-class</code>和<code>exact-active-class</code>。<br></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">&gt; lineActiveClass: <span class="string">'active-route-link'</span>,</span><br><span class="line">&gt; linkExactActiveClass: <span class="string">'exact-route-link'</span>,</span><br><span class="line">&gt; routes: [...]</span><br><span class="line">&gt; &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 过渡效果</span><br><span class="line">`&lt;router-view&gt;&lt;/router-view&gt;`　作为路由出口组件，我们可以像添加普通的`Vue`组件过渡效果一样来为它添加过渡效果。</span><br><span class="line">​```html HTML</span><br><span class="line">&lt;transtion name=&quot;fade&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/transtion&gt;</span><br></pre></td></tr></table></figure><p>如果需要单个路由的过渡效果，直接在路由对应的组件内使用<code>transtion</code>标签即可。</p><hr><p>关于<code>Vue Router</code>的介绍就到这里，<code>Vue</code> 官方的这个路由库设计的还是非常优雅和好用的。如果有想深入研究一下<code>SPA</code>应用路由处理的同学，从这个库入手，是非常不错的选择。</p><p>好啦，本篇文章到此结束，多谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(八):高级类型</title>
      <link href="/2018/08/18/TypeScript(%E5%85%AB)%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/08/18/TypeScript(%E5%85%AB)%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>所谓<code>Ts</code>的高级类型，就是<code>Ts</code>为了能够适配<code>Js</code>中灵活多变的类型变换而给出的除基础类型外非常严谨的一些类型拓展特性。包括联合类型，交叉类型，字符串字面量类型等实际开发中经常会遇到的类型特征和诸如映射类型，<code>this</code>的多态类型等能够提供开发便利的相关类型。</p><p>本篇博客就主要介绍一下<code>Ts</code>中的这些特性，掌握这些特性之后，基本就能够将几乎所有<code>Js</code>语言的写法都改造为<code>Ts</code> 并添加严谨规律的类型检查了。</p></blockquote><a id="more"></a><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="　交叉类型"></a>　交叉类型</h3><p>首先来介绍一下交叉类型，交叉类型就是将几个类型合并为一个拥有这几个类型的<strong><em>所有特性</em></strong>的新类型。<br>使用<code>&amp;</code>符号来连接多个类型从而生成交叉类型。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Child &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Boy &#123;</span><br><span class="line">  height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me: Person &amp; Child &amp; Boy = &#123;</span><br><span class="line">  name: <span class="string">'afei'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  height: <span class="number">160</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>与交叉类型对应的，联合类型表示期望类型是被联合的几个类型中的一个。使用<code>|</code>符号连接多个类型来生成联合类型。</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> | <span class="built_in">string</span></span><br></pre></td></tr></table></figure><p>如果一个值被指定为联合类型，那么在类型真实值不确定时，我们只能访问联合的所有类型中都有的成员。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  bark();</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  climb();</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Pet: Dog | Cat</span><br><span class="line">Pet.run()  <span class="comment">// ok</span></span><br><span class="line">Pet.bark() <span class="comment">// errors</span></span><br></pre></td></tr></table></figure><p></p><h3 id="字符串字面量和数字字面量类型"><a href="#字符串字面量和数字字面量类型" class="headerlink" title="字符串字面量和数字字面量类型"></a>字符串字面量和数字字面量类型</h3><p>在某些情况下，我们可能需要不单单将变量类型限制为字符串或数字，而更进一步的想将其限制为几个特定的字符串和数字。<br>这种情况可以通过字符串或数字字面量类型来为变量指定固定的值。</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="string">'top'</span> | <span class="string">'bottom'</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'top'</span>   <span class="comment">// ok</span></span><br><span class="line">a = <span class="string">'right'</span> <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span><br><span class="line">n = <span class="number">3</span>   <span class="comment">// ok</span></span><br><span class="line">n = <span class="number">4</span>   <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>相比字符串字面量类型，数字字面量类型并不是特别常用。</p><h3 id="多态的this类型"><a href="#多态的this类型" class="headerlink" title="多态的this类型"></a>多态的<code>this</code>类型</h3><p><code>this</code>类型在类继承中是具有多态性的，从而使我们可以连贯的继承。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> a &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> b <span class="keyword">extends</span> a &#123;</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> b()</span><br><span class="line"></span><br><span class="line">c.run().next()</span><br><span class="line">c.next().run()</span><br></pre></td></tr></table></figure><p></p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在某些情况下，我们需要将对象的属性名当做值类型来使用。<br>例如下面比较常见的<code>Js</code>从对象中选取属性的子集的操作:<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subObj</span>(<span class="params">obj, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>Ts</code>中，可以借助索引类型查询操作符<code>keyof</code>来进行索引类型的声明。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subObj</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, keys: K</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>keyof T</code>的结果即<code>T</code>的所有索引属性名字面量的联合，在我们无法清楚得知对象的具体属性时，通过它来提前获得对象属性的类型联合。<br>同样，我们通过<code>T[K]</code>，索引访问操作符，来得到对象属性值的类型引用。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt; (<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p><code>Ts</code>提供了从一个旧类型中创建一个新类型的方式–映射类型。这在我们想将一个类型的所有属性转化为只读或可选时或其他转换后的形式时非常有用。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　只读</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T] : T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　可选</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T] ?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: &#123;a: <span class="built_in">number</span>, b: <span class="built_in">number</span>&#125;= &#123; a: <span class="number">1</span>, b: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readonlyObj = Readonly&lt;obj&gt;</span><br><span class="line"><span class="keyword">type</span> partialObj = Partial&lt;obj&gt;</span><br></pre></td></tr></table></figure><p></p><p>作为最常见的两种类型映射转换，<code>Ts</code>已经将<code>Readonly</code>和<code>Partital</code>加入到了标准库中，这也表示我们可以直接调用而不需要再去定义。<br>另外还有两种映射类型被加入标准库，分别是<code>Pick</code>和<code>Record</code>。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K] : T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pick 从类型 T 中选择所有类型为 K 的属性来组成一个新类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Record 创建一个属性名为 K 类型，属性值为 T 类型的新类型</span></span><br></pre></td></tr></table></figure><p></p><p>当然，我们也可以自己去定义映射类型，通过<code>keyof</code>操作符，我们可以轻易的得到对象的属性类型和属性值类型，从而将对象映射为我们想要的结构。</p><p>以上就是关于<code>Ts</code>的高级类型的一些知识。感谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(七):类型的断言,别名,推论和兼容</title>
      <link href="/2018/08/16/TypeScript(%E4%B8%83)%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%AD%E8%A8%80,%E5%88%AB%E5%90%8D,%E6%8E%A8%E8%AE%BA%E5%92%8C%E5%85%BC%E5%AE%B9/"/>
      <url>/2018/08/16/TypeScript(%E4%B8%83)%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%AD%E8%A8%80,%E5%88%AB%E5%90%8D,%E6%8E%A8%E8%AE%BA%E5%92%8C%E5%85%BC%E5%AE%B9/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>作为<code>Js</code>的超集，<code>Ts</code>肯定要兼容<code>Js</code>的动态语言特性，保证<code>Js</code>中多种多样的类型在<code>Ts</code>中都是可声明和可转换的。令人开心的是，通过一些类型特性，<code>Ts</code>的确实现了<code>Js</code>的几乎完全的类型检查覆盖，避免了灵活的<code>Js</code>中的许多类型的隐式转换问题和不可预知问题。</p><p>这篇博客，就主要来讲一下<code>Ts</code>中几个比较基础的类型特性，包括类型断言，类型推论和类型兼容。通过这三个概念，我们就可以大致理解<code>Ts</code>是如何处理大部分情况下的类型问题的。顺便的提一下类型别名这个小特性，使我们在处理复杂的类型时可以少敲一些类型声明代码。</p></blockquote><a id="more"></a><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在很多情况下，我们确定自己比程序更了解某个值的类型，因此，<code>Ts</code>提供了类型断言这个特性，将值的类型判定权交还给我们自己。</p><p>我们使用类型断言将一个值断言为比当前类型<strong>更确切</strong>的类型。(当然，如果你非要将类型断言为更不准确的类型，也随便你。。。<br>类型断言有两种语法:</p><ul><li><p>尖括号</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = &lt;<span class="built_in">string</span>&gt;a.length</span><br></pre></td></tr></table></figure></li><li><p>as</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = (a <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><h4 id="基础类型推论"><a href="#基础类型推论" class="headerlink" title="基础类型推论"></a>基础类型推论</h4><p><code>Ts</code>中比较常见的类型推论，有以下几种:</p><ul><li><p>初始化变量和成员时</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="comment">// let a: number = 3</span></span><br></pre></td></tr></table></figure></li><li><p>设置函数的默认参数值时</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a = 3</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function (a: number = 3) &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>设置函数的返回值时</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function (a:number): number &#123; return a&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>它们都是从右至左，直接了当的类型推论。</p><h4 id="上下文类型推论"><a href="#上下文类型推论" class="headerlink" title="上下文类型推论"></a>上下文类型推论</h4><p>类型推论也可以从左至右进行，这种情况常见在函数参数，赋值语句，数组的字面量和函数返回值语句。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Ts 会根据　window.onclick 的参数类型来推断　event 类型</span></span><br></pre></td></tr></table></figure><p></p><h4 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h4><p>当需要从多个类型值的组合中判断类型时，<code>Ts</code>会尽可能的推断出一个可以兼容当前所有类型的通用类型<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="comment">//因为 null 兼容于 number 类型，因此 arr 会被推断为 number[] 类型</span></span><br></pre></td></tr></table></figure><p></p><p>当无法找出更通用的类型时，<code>Ts</code>会使用联合类型来进行推断。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [0, 1, &apos;str&apos;]</span><br><span class="line">//推断 arr 类型为　(number|string)[]</span><br></pre></td></tr></table></figure><p></p><h3 id="类型兼容"><a href="#类型兼容" class="headerlink" title="类型兼容"></a>类型兼容</h3><h4 id="结构型类型兼容"><a href="#结构型类型兼容" class="headerlink" title="结构型类型兼容"></a>结构型类型兼容</h4><p>首先比较重要的一点是，在<code>Ts</code>中，<strong><em>类型的兼容性是基于结构的</em></strong>。不同于<code>java</code>和<code>C#</code>的<strong><em>名义类型兼容</em></strong>,在<code>Ts</code>中，只要两种类型的结构相同，不论它们的声明名称是否相同，两种类型就是兼容的。举例来说：<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  a: <span class="built_in">any</span>,</span><br><span class="line">  b: <span class="built_in">any</span>,</span><br><span class="line">  c: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  a: <span class="built_in">any</span>,</span><br><span class="line">  b: <span class="built_in">any</span>,</span><br><span class="line">  c: <span class="built_in">any</span>,</span><br><span class="line">  d: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: X = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> y: Y = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d:<span class="number">4</span>&#125;</span><br><span class="line">x = y</span><br></pre></td></tr></table></figure><p></p><p>如上所示，<code>Y</code>类型具有<code>X</code>类型中所需的全部属性，那么<code>Y</code>类型的值就可以被视作<code>X</code>类型，也即<code>Y</code>类型兼容于<code>X</code>类型，反之则不成立。这也就是著名的鸭式辨型法－－像鸭子一样走路并嘎嘎叫的就是鸭子。</p><h4 id="函数的类型兼容"><a href="#函数的类型兼容" class="headerlink" title="函数的类型兼容"></a>函数的类型兼容</h4><p>判断两个函数的兼容性主要基于两个函数的参数列表和返回值。对于<code>a</code>和<code>b</code>两个函数，只要满足以下条件，我们就说<code>a</code>函数是兼容于<code>b</code>函数的。</p><ul><li><code>a</code>具有<code>b</code>需要的所有<strong><em>必须参数</em></strong>(可选参数可被忽略）</li><li><code>a</code>的返回值类型与<code>b</code>的返回值类型相同或为其的子类型</li></ul><p>这种形式的函数兼容在某种情况下，使得我们在将一种类型函数赋值给另一个函数类型时，是在将具有更精确的类型声明的函数赋值给类型声明不那么精确的函数，但这在绝大部分情况下都并不会造成什么问题。</p><h4 id="类的类型兼容"><a href="#类的类型兼容" class="headerlink" title="类的类型兼容"></a>类的类型兼容</h4><p>类的兼容性判断和接口及对象字面量类似，也只要求结构兼容。<br>但需要注意，类的兼容性只存在于类的实例部分，只有实例成员会被比较，不会比较静态成员和构造函数。<br>同时，对具有私有成员的类来说，与之兼容的类也必须具有相同的私有成员(也意味与之兼容的只能是类的子类。</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>我们可以使用<code>type</code>来为类型创建一个别名从而使用一个更简短的名字引用该类型。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> MyFunc = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> MyStringOrFunc = MyString | MyFunc</span><br></pre></td></tr></table></figure><p></p><p>别名和接口看起来很相似，但不同的是别名只是对类型的一个引用，并未创建一个新的类型。同时别名不能像接口一样<code>extends</code>和<code>implements</code>其他类型，也不能被其他类型<code>extends</code>和<code>implements</code>。</p><p>以上就是本篇博客的全部内容，感谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(六):泛型</title>
      <link href="/2018/08/10/TypeScript(%E5%85%AD)%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/08/10/TypeScript(%E5%85%AD)%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>Ts</code>系列博客上一篇的时间，明晃晃的显示在17年5月13号，虽然现在把博客迁到<code>github</code>，是没什么人看，但对我自己来说，挖的坑没有填还是十分不爽的。</p><p>所以今天晚上整理博客时，时隔一年，还是打算把这个坑填上。</p><p>献上填坑第一篇，<code>Ts</code>的泛型相关。</p><p>话说当初一个前端菜鸡试图去理解泛型这个概念，还真是废了不少脑细胞啊。今天晚上在<code>angular</code>吹水群里发现一个哥们一前端竟然转做<code>JAVA</code>成功，也是让我感慨，这<code>angular</code>和<code>typescript</code>是抄了<code>JAVA</code>多少概念。但还是得说一下，泛型这个东西，<code>Ts</code>可不是抄的<code>Java</code>，我非常确定不是！(因为这次它抄的是<code>C#</code>哈哈哈)。</p><p>再说一句废话，我也想转<code>JAVA</code>！！！（逃。。。。</p></blockquote><a id="more"></a><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>泛型，从字面解释，就是广泛的类型。<br>我们知道，函数，接口，类都可以应用类型，但在很多时候，我们并不想将它们与类型强绑定，而想让它们能够适用于所有的类型，从而提高它们的扩展性，更灵活的使用它们，但我们又不想放弃所有类型验证，使它们拥有了太高的自由度，从而造成维护困难。<br>于是，泛型产生了。在类似<code>C#</code>，<code>Java</code>这些静态类型语言中，都有泛型这个概念。当然对于<code>Ts</code>这个新兴静态类型语言来说，泛型也是不可或缺的。<br>泛型可以应用于函数，接口，类。下面我们就来详细介绍一下<code>Ts</code>中的泛型。</p><h3 id="一个简单的泛型例子"><a href="#一个简单的泛型例子" class="headerlink" title="一个简单的泛型例子"></a>一个简单的泛型例子</h3><p>例如我们有下面这样一个函数，它接受一个字符串参数，什么也不做，只是简单的返回它。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span> (<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在，我们想让这个函数也能够接受数字类型的参数并返回它，你可能说，我们可以通过<code>Ts</code>的联合类型来实现。如下。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params"> value: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">string</span>|<span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>那如果我们更进一步，我们希望这个函数可以接受任意类型的参数，并返回它们。你可能很简单的就想到了，我们可以使用<code>any</code>来进行类型定义。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在这个函数可以接受任意类型的参数了，但是请注意，在上面的两次函数改动中，我们都丢失了一个重要的信息，那就是: <strong><em>函数接受的参数类型和它返回的参数类型总是相同的</em></strong>。<br>如果我们想告诉函数的调用者，函数参数和它的返回值类型总是一致的，该怎么做呢？<br>这就是泛型的用武之地了，我们使用泛型，相当于创建了一个函数的类型参数，我们在调用函数时，传入这个参数用来表明我们实际传入函数的参数的类型。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>&lt;<span class="title">T</span>&gt; (<span class="params">value: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如上所示，我们就创建出了一个泛型函数<code>doNothing</code>。它并没有太多特别的地方，只是在函数名和参数之间多了一个<code>&lt;T&gt;</code>,用于表明它也接受一个类型声明的参数。其中的<code>T</code>，就是我们新创建的一个单纯用来表示参数类型的变量，当然，如果你乐意的话，也可以使用<code>V</code>，<code>X</code>，<code>R</code>。<br>现在，我们就可以知道，<code>doNothing</code>函数接受一个类型为<code>T</code>的参数，并返回一个类型同样为<code>T</code>的值。<br>通过泛型函数这种方式，我们就极大的扩展了函数的灵活性同时也没有丢失函数必要的信息。</p><h4 id="泛型函数的使用"><a href="#泛型函数的使用" class="headerlink" title="泛型函数的使用"></a>泛型函数的使用</h4><p>在定义了一个泛型函数之后，我们可以以如下方式使用：<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDo = doNothing&lt;<span class="built_in">number</span>&gt;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p></p><p>如上所说，通过泛型，我们将类型参数化了，在调用函数时，我们不仅可以传入参数，也可以传入我们要使用的参数类型。<br>当然，别忘了<code>Ts</code>中的类型推断，因此，我们也可以不传入参数类型，而只是简单的像调用普通函数一样传入参数，<code>Ts</code>会通过传入的参数推断出我们要使用的参数类型。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDo = doNothing(<span class="string">"a string"</span>)</span><br></pre></td></tr></table></figure><p></p><p>如上所示，<code>Ts</code>通过类型推断，得出了我们传入的参数使用了<code>string</code>类型，从而判断出这个函数也应该返回<code>string</code>类型。</p><h3 id="一个更复杂一点的例子"><a href="#一个更复杂一点的例子" class="headerlink" title="一个更复杂一点的例子"></a>一个更复杂一点的例子</h3><p>仍以上面的函数来说，我们现在想给函数传入一个任意类型的值组成的数组，同样原样返回。这种形式泛型可以做到吗？<br>答案当然是可以。泛型不光能用于函数的传入参数类型定义，也可以当做函数传入参数的部分类型来定义。看下面的例子。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>&lt;<span class="title">T</span>&gt; (<span class="params">value: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面这个例子中，我们将函数定义了为接受一个任意类型组成的数组参数，并返回一个同样类型组成的数组值的泛型函数。泛型<code>T</code>只是作为了传入参数类型的一部分，也就是数组的单个组成元素。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>我们通常像下面这样定义接口的普通方法。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyI &#123;</span><br><span class="line">  doNothing(value: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的定义表明接口<code>MyI</code>要实现一个接受字符串作为参数并返回一个字符串的方法。<br>像普通函数和泛型函数的<code>&lt;T&gt;</code>类似，我们使用下面这种方式来定义一个泛型接口方法。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyI &#123;</span><br><span class="line">  doNothing&lt;T&gt;(value: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在另外的一些情况下，我们可能想将泛型应用于整个接口，而不是单独的接口方法，可以使用如下方式。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyI&lt;T&gt; &#123;</span><br><span class="line">  doNothing(value: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>需要注意的一点是，我们在使用泛型接口时,<code>Ts</code>无法再进行类型推断，所以我们必须显式的传入泛型类型参数。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: MyI&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  doNothing(val: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类与泛型接口类似。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyC&lt;T&gt; &#123;</span><br><span class="line">  val: T,</span><br><span class="line">  doNothing(value: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同样的，使用泛型类也要显式的传入泛型类型参数。<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ac: MyC&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  val: <span class="string">'aaa'</span></span><br><span class="line">  doNothing(v: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同时，类的泛型声明还有需要注意一点的是，它只适用于类的实例部分。不能用于类的静态部分，也就是带<code>static</code>前缀的类的静态属性和方法，是不能使用泛型声明的，会报错。</p><h3 id="更高级的泛型用法——泛型约束"><a href="#更高级的泛型用法——泛型约束" class="headerlink" title="更高级的泛型用法——泛型约束"></a>更高级的泛型用法——泛型约束</h3><p>还是上面的<code>doNothing</code>函数，现在，我们提出了更加苛刻的要求，我们需要它接收一个具有<code>length</code>属性的任意类型的对象，并打印出<code>length</code>属性的值之后再原样返回对象。<br>这种要求用泛型可以实现吗？当然可以，我们可以通过泛型约束来对泛型做出约束，不再是什么类型都可以了，如下：<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> haveLength &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">haveLength</span>&gt; (<span class="params">value:T</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.length)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如上所示，我们定义一个具有<code>length</code>属性的接口，使泛型<strong><em>extends</em></strong>(继承)这个接口，从而为泛型添加上了必须具有<code>length</code>属性的约束，声明了传入函数的参数不管是什么类型，都必须具有<code>length</code>属性。</p><p>从这也可以看出，泛型大大提升了我们对于<code>Js</code>这种动态类型语言的类型约束能力，也保证了我们在使用<code>Ts</code>相对使用<code>Js</code>在语言的自由度上不会受损。</p><p>好啦，到这里，关于<code>Ts</code>中泛型的相关知识基本就讲完了，希望对大家有所帮助。感谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《代码整洁之道》读书笔记(上)</title>
      <link href="/2018/08/08/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
      <url>/2018/08/08/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%8A)/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>刚进入无二的时候，就被强烈推荐过这本《代码整洁之道》，一直想着去看去看，也终于是没看。前几天又被老大提起这事，想着也是该看一看，就趁一些段段续续的零散时间看完了这本广受美誉的书。</p><p>看完掩卷，也的确觉得这本书非常不错，虽然书里面示例代码都是用<code>Java</code>写的，也有一些内容是单纯关于<code>Java</code>的，但有些内容，不管是什么编程语言，是前端还是后端，看完都会有一些感悟和收获。</p><p>毕竟，不管什么语言，保持代码的高度精炼和整洁，都是非常有必要性。或者可以更严格的说，整洁的代码不一定是好代码，但好代码一定是整洁的。</p><p>这篇博客，是我在阅读的过程中，个人总结和记录的一些比较值得思考和遵循的一些内容，也算做是读书笔记吧。</p></blockquote><a id="more"></a><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>命名，是编程过程中最常见的事情。但掌握好的命名方式和手法并不是一件容易的事情。<br>对于命名来说，最基本的原则是易读，易理解，易维护，尽可能的提高名称的准确性。<br>书中有大有小的提到了以下这些注意事项：</p><ul><li>名称要体现它本身要表达的意思或作者的意图，避免模糊不清</li><li>避免误导名称，例如那些带有类型的名称，如其实是个对象类型的<code>dataList</code>，和容易混淆字母的相近名称，如<code>loerror</code> 和 <code>Ioerror</code></li><li>使名称易读，尽量使用技术性词汇，而不是口头语和俗语，也不要使用耍宝类型的命名，例如<code>delete_yeye</code>。</li><li>尽量使用问题解决方案领域的命名，而不是业务领域的命名。因为在大多数情况下，知道这段代码做了什么比知道这段代码要解决什么业务问题重要。</li><li>使用易搜索的命名，这包括以下两点：<ul><li>非必要的情况，避免为名称加上相同前缀，而应该使用尽量小的类和函数来达到标注名称作用域的效果。</li><li>尽量避免使用易与其他词汇重复的命名，例如<code>e</code>。</li></ul></li><li>在非必要的情况下，别为命名加上类型标记。例如<code>ArrayUsers</code>这样毫无意义的废话。</li><li>类名应为名词</li><li>方法名应是动作</li><li>对同一个概念保持相同的词，例如不要混用<code>get</code>，<code>fetch</code>，<code>retrieve</code></li><li>为变量添加对应语境，例如<code>UserName</code>，<code>UserPhone</code>，而不是<code>Name</code>，<code>Phone</code>。但不要添加无意义的语境，例如为一个类中的所有属性加上类名前缀。</li></ul><blockquote><p>命名是编程过程中非常常见的一个动作，大部分人都是在不断的编程中，慢慢发现准确的表述和定义一个相关抽象的事务和操作为一个名称，其实是一件相当具有难度的事情。给一个函数一个贴切的名称，有时也会大大提高我们代码的清晰和整洁。<br>避免类似<code>isShow</code>,<code>isEdit</code>这种变量名，相比提升代码整洁度，提升后续维护这段代码的程序员的寿命大概是更直观的作用。。。。</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>尽量保持短小，缩进层级不应太多，以一层或两层为宜。</p></li><li><p>只做一件事，应只专注于一个抽象层级，而不是跨越多个。同时尽量保证自顶向下的调用顺序，从而使函数顺序和抽象层级顺序相应。</p></li><li><p>使用描述性的函数名称，精炼的表达出函数做的事。在名称贴切的前提下，不要去担心函数名称的长度。</p></li><li><p>避免函数内部的时序性耦合，即避免函数在做一件事的过程中去做另一件在函数名称和参数上完全无法体现或者并非函数本质的事。(例如在一个检查用户名是否符合规范的函数中初始化用户密码</p></li><li><p>尽量分离函数的查询和指令，避免在一个函数中过度耦合。</p></li></ul><blockquote><p>在第一遍写函数时，很难将函数的层级和长度控制的非常好。所以，解决办法是，完成功能，写好测试，然后开始重构。<br>在最理想的情况下，函数要么只进行查询，要么只进行操作。当然，很多时候我们很难将函数都控制的如此理想，对于前端来说，因为数据和操作在大部分时间都是动态绑定的，就更难实现了。但，知道了什么是好的，然后尽量靠近，也是一件非常有助于提升自我的事情啦。</p></blockquote><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ul><li><p>避免多参数函数，尽量保证函数参数在三个以下，便于阅读和测试。</p></li><li><p>避免将标示性的布尔值作为参数传入函数(传入标识符无疑是在宣布函数并不单单做一件事</p></li><li><p>如果确实需要二元参数的函数，保证其名称准确，最好能体现参数顺序。</p></li><li><p>如无确实必要，避免使用三个参数及以上的函数</p></li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li>使用异常代替返回错误码，这样可以避免对错误码的维护同时可以将错误在统一的地方捕获和处理而不是通过判断错误码来分别处理。</li><li>避免将<code>try/catch</code>和正常流程混杂在一起，尽量将<code>try/catch</code>单独抽离为一个异常处理函数。(错误处理就是一件事</li><li>尽量避免所有重复的部分，善用函数来抽象它们</li><li>在函数长度比较长时，遵循结构化规范，保证函数只有一个入口和出口。</li></ul><blockquote><p>在前端来说，封装请求层，然后在请求层统一过滤和处理错误，将异常捕捉和页面完全分离，可以大大的提升项目的可维护性。<br>千万避免在数据层，例如<code>vuex</code>中进行错误处理，否则等项目规模稍微一大，你就等着哭吧。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>注释相比代码，更容易说谎。因此，尽可能提高代码质量，从而能够减少注释量，记住，再好的注释也无法拯救烂代码。</p></li><li><p>注释最好只用来:</p><ul><li>传递必要的信息</li><li>解释意图</li><li>提供警示和告知及应被注意的重点位置</li><li>提供<code>TODO</code>(记得定期清理）</li></ul></li><li><p>避免以下类型的注释</p><ul><li>喃喃自语，不考虑阅读者的思路能否跟随</li><li>废话连篇或毫无价值</li><li>具有误导性的片面注释</li><li>刻意的遵循格式化注释</li><li>日志和署名注释或者注释掉的代码（记住我们有版本管理工具可用</li><li>位置标记，例如那种一行等号的注释，可以偶尔使用，但不能滥用。</li><li>花括号后的行内注释</li><li>相关的代码并不在注释所在位置，即非本地的注释</li></ul></li></ul><blockquote><p>在敏捷开发中其实比较推荐代码即注释的，但对于前端来说，我是真心觉得代码即注释很难实现，因为前端很难像后端那样将一些东西抽象到很高程度，毕竟你努力抽象半天，产品过来说，你在这给我再加个按钮，你的抽象可能就白抽了。所以很多时候，前端在涉及到比较细粒度的操作时，还是应该加一些注释的。</p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>保证项目文件和团队的代码格式统一</li><li>垂直格式，即文件长度，尽量不要太长。同时，代码的细节，应该自上而下逐步展开。</li><li>通过空行来进行垂直上的区隔，从而使代码和思路更清晰。</li><li>关系密切(例如互相调用的函数，处理相同任务不同状态的函数)的代码，在垂直距离上也应该距离更近。但像类的实例声明，还是应该集中于类的头部。</li><li>一行代码尽量不要超出120个字符</li><li>不必刻意通过空格来水平对齐</li><li>规范的缩进，保证代码嵌套层次清晰</li></ul><h3 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h3><ul><li><p>做数据抽象，暴露接口，隐藏实现。</p></li><li><p>面向对象将数据隐藏起来，提供操作数据的函数。面向过程直接处理数据结构。<br>举例来说，有多个几何形状正方形，圆形，三角形，计算面积。<br>采用面向过程的方法，我们定义三种数据结构和一个计算面积的方法，调用计算面积的方法，传入形状，判断形状再计算面积。我们非常容易再添加计算边长的方法，但如果我们新加形状，就必须修改现有所有和形状有关的方法。<br>采用面向对象的方法，我们定义三种对象，每个对象有自己的计算面积方法。非常容易添加新的形状，但如果我们想添加计算边长的方法，就需要去修改每个对象。</p></li><li><p>面向对象更抽象，易于添加新类型，改动对应类型的方法，但难于为所有类型添加新方法。</p></li><li><p>面向过程易于为所有类型添加新方法，但添加新类型需要修改现有所有方法。</p></li><li><p>当形状的方法增加频繁时，例如计算面积，计算周长，计算边数等等等，使用数据结构和面向过程的方式，当形状的种类变化频繁时，例如增加长方形，增加菱形等等,使用对象和面向对象的方式。</p></li><li><p>在工作中，不带偏见的根据工作性质和需求来选择面向对象和过程的其中一个解决问题。</p></li><li><p>避免混杂对象和数据结构。数据结构中并未完全不能定义方法，但必须避免将业务方法代码封装在诸如<code>active record</code>这种数据结构中，非常容易造成难以挽救的混乱。</p></li><li><p>得墨忒定律，即对象方法应该只跟邻居对话，不与陌生人交谈。邻居有以下几个定义:</p><ul><li>类与其实例出的对象</li><li>函数与传递给它的参数</li><li>对象和对象的属性<br>类似<code>a().b().c()</code>的调用方式是不推荐的。<br>对于数据结构来说，因为它直接暴露了自身，所以得墨忒定律是不适用的。</li></ul></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>保证错误处理的条理和与业务逻辑的区隔，避免凌乱，防止其打乱正常的代码逻辑</li><li>使用异常而不是错误标识（例如错误码), 因为异常我们可以统一捕获和处理而不打乱正常逻辑</li><li>将<code>try</code>中的代码当做事务，而<code>catch</code>中的代码则是事务状态的保证</li><li>保证异常携带充分的错误信息</li><li>通过打包封装<code>API</code>来将异常控制在特定的区域</li><li>不要返回<code>NULL</code>值，这会造成后续的所有代码都陷入不断判断<code>NULL</code>值的尴尬境地，抛出异常或者返回一个特例对象来代替返回<code>NULL</code>值。</li><li>不要定义显式可接收<code>NULL</code>值的函数，保证所有函数都是禁止接收<code>NULL</code>值的，从而在真正出现<code>NULL</code>值的函数参数时就可以明确的知道发生了错误。</li></ul><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>第三方库通常都追求普适性，但我们在使用时则想满足特定需求，这就需要我们保证代码良好的边界。</p><ul><li>通过封装来修整第三方库或者依赖，从而保证第三方库的边界不会深入系统。</li><li>通过完善的测试来覆盖第三方库的调用，从而能够保证第三方库不断升级过程中仍与系统的兼容，而不是只能长久的绑定在旧版本上。</li><li>对于第三方库这种我们无法控制的代码，保证整洁的边界能大大降低我们在未来改动和更新依赖的代价。</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>测试驱动开发,即<code>TDD</code>，能够大大降低代码修改和迭代的代价。它需要保证以下三条定律:<ul><li>先写测试，后写代码</li><li>只编写刚刚开始无法通过的测试</li><li>只编写刚刚开始通过测试的代码<br>这也就意味着我们的测试和代码互相推动着同时前进。</li></ul></li><li>测试代码同样要保证整洁，可维护。</li><li>测试代码最重要的是可读性。保证测试代码的简明和有力。</li><li>测试代码并不需要很多生产代码的限制，例如性能方面，并不那么重要。</li><li>每个测试只测试一个概念。</li><li>好的测试，要保证<code>F.I.R.S.T</code>特性<ul><li>快速<strong>Fast</strong>，保证测试够快，才能频繁运行</li><li>独立<strong>Independent</strong>,测试应该独立而不能互相依赖。</li><li>可重复<strong>Repeatable</strong>,测试应该在各种环境中都能通过。</li><li>自足验证<strong>Self-Validating</strong> 测试应该只客观的返回成功或失败</li><li>及时<code>Timely</code>，测试应该刚刚好在开发的前面一点点，不能落后</li></ul></li></ul><blockquote><p>测试，是保证代码可维护，可扩展，可复用的生命力的最有力工具。拥抱测试，就是在拥抱代码的健壮性，为代码延长寿命。但很可惜，大家都知道测试好，但都被需求的鞭子追着跑，管不了，唉，一声叹息。</p></blockquote><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p>除非测试需要访问，否则尽量将类的属性和方法设置为私有的，提升类的封装能力。</p></li><li><p>类应该和函数一样，尽量保持其的短小，避免涉及到各种公用方法和属性的<strong>神之类</strong>。一定规模的系统都会包含大量的逻辑和复杂性，通过组织短小单一的类，可以将特定时间和范围内的维护复杂性降低。</p></li><li><p>类的名称应该精确描述其权责，避免名称中出现<code>if</code>，<code>and</code>，<code>but</code>，<code>or</code>等关系词汇。当出现类似词汇时，说明类具有了太多权责。<br>类应该遵循单一权责原则<strong><em>SRP</em></strong>：类或模块应该只有一条修改的理由。</p></li><li><p>通过方法覆盖仅可能多的类变量来保持类的内聚性，当方法只能覆盖一部分类变量时，说明我们需要将类拆分为更短小更内聚的类。</p></li><li><p>类应该对修改封闭，对扩展开发。即我们使用许多内聚性较高的类，在新增功能时，就可以更多的通过增加代码实现，而可以较少的去修改代码，</p></li></ul><blockquote><p><code>Vue</code>中组件和类非常像，<code>Angular</code>中，组件就是个类。因此，对于前端组件来说，类的很多东西也是可以套用的。比如避免命名中有<code>if</code>,<code>or</code>，有这种单词时，说明组件是应该被拆分的。避免有Ｎ多功能的神之组件，使组件自身方法覆盖更多部分的组件数据，从而促使自己去拆分数据，提升组件的内聚程度等等，本书中关于<code>Java</code>类的一些内容，倒是触类旁通的让我对<code>Vue</code>组件的认识又加深了一些。</p></blockquote><p>总的来说，《代码整洁之道》这本书真的是非常不错的一本提升程序员编程水平和认知的书，认真的读下来，让人受益匪浅，很多道理，也可以看出是作者长久编程中悟出来的，能让我等菜鸟少走许多弯路。<br>当然，提升代码整洁和可读性，不是通过看会书就能学会的。最重要的，还是多写多写再多写，在写的过程中不断反思和总结，将书中的内容融会贯通，才能成为真正的好程序员，与大家共勉。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 TypeScript 构建 Vue 项目</title>
      <link href="/2018/07/23/%E4%BD%BF%E7%94%A8Typescript%E6%9E%84%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/07/23/%E4%BD%BF%E7%94%A8Typescript%E6%9E%84%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>随着 TypeScript 的热度越来越高，Vue 官方提供的 TypeScript 支持也越来越多，Vue-CLI 3.0 更是直接提供了使用 TypeScript 来创建一个新工程的功能。</p><p>使用 Vue 进行开发也已经有半年的时间了，也非常怀念当时拿 TypeScript 写 Angular 的那种得心应手的舒畅，因此，在这个周末，花了一下午时间，将手头的一个 Vue 小 Demo 从 Js 修改成 Ts，打算看一下，Vue的 TypeScript 开发，到底靠谱不靠谱。</p><p>本篇博客，就来记录一下项目升级到 TypeScirpt 中的一些重点和遇到的坑吧。</p></blockquote><a id="more"></a><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><p>首先，我尝试将原有的 <code>Vue</code> 项目直接改动到 <code>TypeScript</code>，但发现改造起来是比较麻烦的，需要再去安装各种相关依赖，调整打包配置，修改组件的代码写法。</p><p>所以我决定直接新建一个 <code>TypeScript</code>的 <code>Vue</code>项目，然后将旧项目迁移过来。</p><p>在<code>Vue-CLI 3.0</code> 中，提供了直接创建一个 <code>TypeScript</code>项目的功能。具体如下：</p><ol><li><p>如果未安装<code>Vue-CLI</code>，直接使用下面命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue-cli</span><br></pre></td></tr></table></figure></li><li><p>如果已安装，使用下面命令新建一个 <code>Vue</code> 项目，创建时选择<strong><em>手动选择特性(Manually select features)</em></strong>选项来添加<code>Typescript</code>支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project-name</span><br></pre></td></tr></table></figure></li></ol><p>通过上面的命令，我们就创建了一个新的有<code>TypeScript</code>支持的 <code>Vue</code>项目。</p><h3 id="迁移旧项目"><a href="#迁移旧项目" class="headerlink" title="迁移旧项目"></a>迁移旧项目</h3><p>当然，如果我们想将旧的<code>Vue</code>项目改造为新的项目的话，虽然比较麻烦，但也是可行的。需要以下几个步骤：</p><ol><li><p><code>npm</code> 安装<code>TypeScript</code></p></li><li><p><code>npm</code>安装 <code>ts-loader</code>，用于为<code>webpack</code>提供 <code>.ts</code> 文件的打包编译支持</p></li><li><p>修改<code>webpack</code>的<code>rules</code>配置，添加关于打包<code>.ts</code>文件的配置。类似如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改<code>extensions</code>选项，添加<code>.ts</code>声明，使打包时可以识别<code>.ts</code>文件。</p></li><li><p>创建 Ts 的项目配置文件 <code>tsconfig.json</code>，需要注意的是，尽量打开配置的<code>strict</code>模式，才能保证<code>Ts</code>对类似<code>this</code>的类型检查。更多的配置项，例如支持<code>JSX</code>，生成<code>sourceMap</code>文件等选项，可以自行查看<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">Typescript配置项文档</a></p></li><li><p>将项目打包入口文件<code>main.js</code>修改为<code>main.ts</code></p></li><li><p>增加<code>Vue</code>文件的类型声明。因为<code>Typescript</code>是不支持<code>Vue</code>文件的，所以我们通过自定义的将<code>Vue</code>文件声明为一个模块，来保证<code>Ts</code>对其的正确处理。</p><p>定义一个<code>vue-shims.d.ts</code>文件，放在项目任意位置，内容如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上几步，项目的<code>Typescript</code>配置就算完成了，通过将<code>.vue</code>文件的<code>&lt;script lang=&quot;js&quot;&gt;</code>标签修改为<code>&lt;script lang=&quot;ts&quot;&gt;</code>，就可以开始在项目中开始使用<code>typescript</code>了。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a><strong><em>vue-class-component</em></strong></h4><p>使用 <code>Ts</code>编写 <code>Vue</code>代码，<code>Vue</code> 官方提供了一个库 <a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">Vue-class-component</a>，用于让我们使用<code>Ts</code>的类声明方式来编写<code>vue</code>组件代码。</p><p>这个库提供了一个<code>@Component</code>装饰器，基本使用方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propMessage: <span class="built_in">String</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> App <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="comment">// initial data</span></span><br><span class="line">  msg = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// use prop values for initial data</span></span><br><span class="line">  helloMsg = <span class="string">'Hello, '</span> + <span class="keyword">this</span>.propMessage</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lifecycle hook</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.greet()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line">  <span class="keyword">get</span> computedMsg () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'computed '</span> + <span class="keyword">this</span>.msg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  greet () &#123;</span><br><span class="line">    alert(<span class="string">'greeting: '</span> + <span class="keyword">this</span>.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以前书写组件的<code>data</code>数据项，可以直接声明为组件类的属性，<code>methods</code>，可以直接声明为类的方法，组件的各种生命周期函数，也可以直接作为类方法声明。而计算属性，更可以方便的通过类的<code>get</code>和<code>set</code>函数来实现。</p><p>需要注意的是，因为<code>Ts</code>的模块系统只能自动识别<code>.ts</code>结尾的文件，因此我们在从<code>.Vue</code>文件导入组件类时，<strong>需要在导入路径上加上文件名后缀<code>.vue</code>。</strong></p><p>对于一些无法在<code>Ts</code>类中声明的方法和属性，例如<code>watch</code>，<code>props</code>我们可以直接在<code>@Component</code>装饰器中作为参数传入，或者使用下面这个库。</p><h4 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a><strong><em>vue-property-decorator</em></strong></h4><p>这个库依赖于上面的<code>vue-class-component</code>，提供了更多的 Vue 组件相关方法的装饰器，可以让我们方便的在组件类中使用 Vue 实例提供的方法和属性，例如<code>props</code>, <code>watch</code>等。</p><p><code>vue-property-decorator</code>提供了下面几个装饰器:</p><ul><li><code>@Watch</code></li><li><code>@Prop</code></li><li><code>@Model</code></li><li><code>@Provide</code></li><li><code>@Inject</code></li><li><code>@Emit</code></li><li><code>@Mixins</code></li><li><code>@Component</code> (依赖于<code>vue-class-component</code>)</li></ul><p>通过这些装饰器，我们可以简单方便的使用<code>Vue</code>实例自身提供的一些方法和属性。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Prop, Watch &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> YourComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="meta">@Prop</span>(<span class="built_in">Number</span>) propA!: <span class="built_in">number</span></span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="keyword">default</span>: <span class="string">'default value'</span> &#125;) propB!: <span class="built_in">string</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">'child'</span>)</span><br><span class="line">  onChildChanged(val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体这些装饰器的详细使用，可以前往<a href="https://github.com/kaorun343/vue-property-decorator" target="_blank" rel="noopener">vue-property-decorator项目主页</a> 查看。</p><h3 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a><strong><em>vuex-class</em></strong></h3><p><code>vuex-class</code> 同样是基于<code>vue-class-component</code>的一个库，用于提供<code>vuex</code>的<code>typeScript</code>支持。提供了以下几个装饰器：</p><ul><li><code>@State</code></li><li><code>@Getter</code></li><li><code>@Action</code></li><li><code>Mutation</code></li></ul><p>同时它还提供了一个<code>namespace</code>方法，用于获取<code>vuex</code>的某个命名空间。</p><p><code>vuex-class</code>的具体细节，也可以前往其<a href="https://github.com/ktsn/vuex-class" target="_blank" rel="noopener">项目主页</a> 查看。</p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>有了上面提到的三个库，基本的开发应该就可以顺利的进行了。当然，因为<code>Vue</code>对<code>TypeScript</code>的支持还并不是非常完美，所以在使用的过程中可能还是会遇到一些坑，我这里说几个比较容易遇见的问题和解决办法。</p><h4 id="使用装饰器时Ts-报错"><a href="#使用装饰器时Ts-报错" class="headerlink" title="使用装饰器时Ts 报错"></a>使用装饰器时<strong><em>Ts</em></strong> 报错</h4><p>这个问题，在<code>tsconfig.js</code>中设置<code>experimentalDecorators</code> 选项为<code>true</code>即可。</p><h4 id="第三方库引入"><a href="#第三方库引入" class="headerlink" title="第三方库引入"></a>第三方库引入</h4><p>我们在项目中会经常使用一些第三方的库，例如<code>ElementUI</code>，<code>echarts</code>等等，当我们在<code>Ts</code>中引入这些库的时候，明明我们已经安装了，<code>Ts</code>仍然会报错找不到库路径。这是因为这些库中没有包含以<code>.d.ts</code>结尾的库声明文件，所以<code>Ts</code>就无法识别它们。</p><p>比较方便的解决办法是前往<a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个网站</a>查看是否有对应第三方库的声明，如果有，直接使用<code>npm</code>安装即可。在这个网站，基本可以找到我们常用的所有库的声明<code>type</code>库。</p><p>当然，如果我们用的第三方库比较冷门的话，这个网站我们搜不到，我们也可以自己写一个声明文件放在项目中，并不是特别麻烦。</p><h4 id="Vue全局方法和属性的使用"><a href="#Vue全局方法和属性的使用" class="headerlink" title="Vue全局方法和属性的使用"></a>Vue全局方法和属性的使用</h4><p>在写<code>Vue</code>的时候，我们通常会定义或使用第三方提供的全局方法，在<code>TypeScript</code>中照原来的方法使用的话，会报错<code>Vue</code>类型并不存在这个全局属性或方法。这是因为我们没有为<code>Vue</code>类型声明对应的属性和方法。</p><p>可以通过在上文提到的<code>vue-shim.d.ts</code>中添加对应的方法和属性声明，来避免这个报错。</p><p>例如<code>elementUI</code>提供的全局方法<code>$message</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'vue/types/vue' &#123;</span><br><span class="line">  <span class="keyword">interface</span> Vue &#123;</span><br><span class="line">    $message: <span class="built_in">any</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性也是一样，在<code>Vue</code>的<code>interface</code>中声明即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，在<code>Vue</code>中使用<code>TypeScript</code> 目前是完全可行的，当然，还是远远比不上<code>Angular</code>和<code>TypeScript</code>的那种非常契合丝滑的感受的。但也情有可原，毕竟<code>vue</code>框架的作者尤大大一年前还在知乎严肃的说<code>Vue</code>并不特别需要<code>TypeScript</code>，<code>Vue</code>这个框架诞生之初也并没有想与<code>Ts</code>发生什么联系，就算现在想借助<code>TypeScirpt</code>来提高<code>Vue</code>在大型的长期项目中的开发效率，降低维护难度，也不是短期内就可以完成的事情。</p><p>但有理由相信，随着前端工程化程度的进一步深入，<code>Vue</code>也会加大与<code>Typescript</code>的结合力度，来进一步为我们提供更好的开发体验的。</p><p>另外，附上我使用 <code>Vue-CLI</code>搭建的<code>Vue + TypeScirpt</code>项目链接，有需要的同学可以参考一下。</p><p><a href="https://github.com/Gyufei/vue-typescript" target="_blank" rel="noopener">项目传送门</a></p><p>谢谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Vue的一次技术分享</title>
      <link href="/2018/07/20/%E5%85%B3%E4%BA%8EVue%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
      <url>/2018/07/20/%E5%85%B3%E4%BA%8EVue%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>本篇博客，是我在公司内部的一次关于vue的技术分享中分享的内容，特意整理一下，放在博客中，做个记录。</p></blockquote><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于vue框架来说，并没有太多特别规范化，大家都认可的特别约定俗成的最佳实践，当然，很多软件开发领域的通识规范，例如命名，文件划分，框架结构的分层界限等等，更多的也是通用于各类项目，也不好说这些就是vue的最佳实践。</p><p>更多的，也是追求一个能符合自己项目的需求，同时也保证一定开发效率的标准和良好实践，就非常ok了。所以呢，今天也是更多的就跟大家分享一下我在写vue这些时间里自己的一些心得。</p><p>最佳实践，大致的，可以分为风格类和功能操作类。</p><p>具体来说，风格类，例如缩进规则，命名规则等这些，vue在官方文档里提供了一个风格指南，主要就是关于这方面的建议，例如组件名，prop的定义和使用方式等等这些，大家闲了没事可以去瞄几眼。</p><p>功能操作类的最佳实践，例如组件的组织方式，全局状态的管理方式，类似axios请求层的封装调用方式，或者组织vuex这样的数据层的方式，包括如何处理自定义插件指令过滤器等等，官方并没有给出这方面的建议和最佳实践，网上关于这方面的东西也是争论多于讨论。所以要细说vue的最佳实践其实比较还蛮难的，可能大部分地方都得针对项目的具体情况和实际需求，来综合考虑。</p><p>当然，其实最佳实践这种东西，在项目中来说，最重要的还是<strong><em>统一就好</em></strong></p><h3 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h3><ul><li>组件文件名的大小写问题<br>（前几天我在linux下跑了某个前端项目，发现竟然是跑不起来的, 最后翻报错发现，原来存在几个组件命名时采用了首字母小写的驼峰命名，但是<code>import</code>时用了首字母大写的帕斯卡命名。<br>这在不识别文件名大小写的<code>windows</code>和<code>mac</code>下面是可以的，但是在<code>linux</code>下对文件大小写是敏感的，就会报找不到路径文件的错误，无法打包。<br>当然，因为现在大家大部分都是在mac打包编译之后部署的，所以没什么影响。但比如ssr类型的项目，因为是在linux服务器中编译的，如果存在组件命名大小写不统一错误的话，就会出问题。<br>对于组件的命名和使用，因为Vue的模板可以是单文件，可以是字符串，可以是原生DOM元素，模板形式不同，命名的最佳规则也不同，只要命名方式统一，就是比较好的。</li></ul><h3 id="vue实例对象属性顺序"><a href="#vue实例对象属性顺序" class="headerlink" title="vue实例对象属性顺序"></a>vue实例对象属性顺序</h3><p>虽然对象的属性是不区分大小写的，但是我们在写的时候，遵照特定的顺序，可以让代码更清晰一些。这种顺序风格也比较多，我总结了一下官方和iview库的风格，具体特别细的顺序其实也不用规定的太死，大概遵照下面的顺序，会使得组件的内部结构更清晰和易懂。组件特性，包括组件的挂载元素，名称等组件自身特质的一些东西。组件依赖项，包括组件依赖的一些在内部使用的外部资源。组件接口，例如props，双向绑定的model。组件自身的数据，包括data相应数据，compute计算属性组件的方法，包括组件的生命周期钩子函数，watch监听器，methods。我们在写代码的过程里，可以按照类似下面的分类来加上一些空行，使组件的内部结构更清晰明了。</p><ul><li>组件特性，例如 el, name</li><li>组件的依赖项 directive, filter, componets</li><li>组件的接口 props, model</li><li>组件自身数据 data，computed</li><li>组件自身方法<br>事件函数：生命周期函数，watch监听器<br>方法函数: methods</li></ul><p>这也是element和iview都使用的一种组件对象属性的顺序，在组件比较复杂，组件内属性比较多的时候，也可以根据这种归类使用空行分割，会比较清晰和明了。</p><h3 id="模板内的表达式"><a href="#模板内的表达式" class="headerlink" title="模板内的表达式"></a>模板内的表达式</h3><p>模板内不要写太复杂的表达式。在模板内的表达式如果比较复杂的话，有几个缺点:</p><ul><li>难以阅读</li><li>将数据逻辑和渲染层混在了一起，结构不清晰</li><li>没法复用</li><li>eslint无法准确的进行语法检查</li></ul><p>因为在模板内的表达式是拿双引号扩起来的，很多时候都堆在长长的一行里，阅读起来比较困难<br>模板内的表达式将数据逻辑和视图渲染层混在了一起，容易造成混乱。同时在一个地方写了一长串逻辑之后，在其他的地方是没办法用的。同时，eslint也没办法对它进行准确的语法检查，可能造成潜在的bug。</p><p>对于这种表达式，我们可以使用methods或者计算属性computed来代替。</p><h3 id="页面初始化的数据获取"><a href="#页面初始化的数据获取" class="headerlink" title="页面初始化的数据获取"></a>页面初始化的数据获取</h3><p><strong><em>进入页面后获取</em></strong></p><p>比较常见的一个场景就是，我们进入页面时需要根据某个参数获取一次数据，<br>随后watch这个参数，例如筛选条件参数,路由参数等，当参数变化时，去再次获取数据。<br>最基础的写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时获取数据</span></span><br><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.getList()</span><br><span class="line">&#125;,    </span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'$route'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="comment">// 获取数据的方法</span></span><br><span class="line">  getList () &#123;</span><br><span class="line">  　<span class="keyword">const</span> id = <span class="keyword">this</span>.$route.params.id</span><br><span class="line">    api.getList(id)</span><br><span class="line">    <span class="keyword">this</span>.pageData = pageData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们还可以使用watch的<code>immdiate</code>属性，在页面初始化完成，监听器开始工作的时候立即调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时获取数据</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'$route'</span>: &#123;</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    handler: <span class="string">'getList'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="comment">// 获取数据的方法</span></span><br><span class="line">  <span class="keyword">async</span> getList () &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="keyword">this</span>.$route.params.id</span><br><span class="line">    <span class="keyword">const</span> pageData = <span class="keyword">await</span> api.getList(id)</span><br><span class="line">    <span class="keyword">this</span>.pageData = pageData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>顺便插一句let和const的使用，最好遵循最小特权原则，如果不需要某个变量，对象，类做某件事，就不要给它可以做这件事的功能。</p><p>在页面加载完成之后开始获取数据，然后让用户等待loading，这种方式不一定是我们想要的。有时候我们想让用户进来的时候，数据就已经展现好了，当页面呈现在用户面前时，就已经是加载好的状态了，我们不需要再显示一个loading状态。就可以通过下面一种方式</p><p><strong><em>页面导航完成前获取</em></strong></p><p>这种方法不是特别常用，但是在某些时候还比较有用的另一种数据获取方式。<br>就是在导航完成前获取数据，这样<br>我们不在组件的生命周期里或者监听器里获取数据，而是到路由守卫里获取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  const id = to.params.id</span><br><span class="line">  const pageData = await api.getList(id)</span><br><span class="line">  next(vm =&gt; vm.pageData = pageData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由守卫中是不能获取vue实例this的，因为这个时候组件实例还没有生成。next是用来resolve这个路由钩子的，调用resolve，就表示这个钩子已经完成，可以继续进入导航下一步了。对于这个钩子来说，就是表示可以开始组件的声明周期了。<br>通过向next传递一个回调函数，来将我们在路由导航前获取的数据，传递给组件。<br>这样，这个组件一呈现在用户面前，就是数据已经加载完毕的状态。<br>从另一个角度来说，这种方式，我们不用在组件页面展示loading状态了，需要在离开的页面展示一个进度条或加载中提示。<br>当然，这两种方式，还是看需求使用，看需要哪种用户体验。。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a><strong><em>key</em></strong></h3><p>前端页面的性能，主要就是消耗在页面DOM的插入，更新，删除这些操作导致页面不断的重新生成DOM树，重新布局，重新绘制。</p><p>Vitual DOM是基于javascript实现的一种虚拟DOM，将dom对象抽象成保留了页面元素层级关系和基本属性，例如id，class这些的javascript对象，javascript对象更简单，处理速度更快，dom树的结构，属性信息，以及文本内容都可以很容易的用javascript对象来表示。在vue中的虚拟DOM对象，也被称为VNode，是vue将真实的页面结构和数据抽象成一个个包含元素结构信息和数据的节点。</p><p>当页面数据更新的时候，vue会重新生成一次虚拟DOM，然后去跟上一次生成的虚拟DOM进行diff，得到两次的虚拟DOM不相同的地方，用专业的语言来说，就叫patch，得到patch之后，vue会将patch打到DOM上去，然后页面再去重新渲染，完成更新。</p><p>但是diff的时候，比较前后两次虚拟DOM的不同，如果从头到尾循环往复的一个个比较的话，也是非常消耗性能的，所以vue的diff算法有两个比较通用的规则：</p><ul><li><p>只进行同一层级的比较</p></li><li><p>如果比较到相同层级的节点存在不同，直接删除旧的，插入新的节点。不会再去比较后面有没有可以复用的。</p></li><li><p>如果渲染前后节点结构相同的话，就直接复用，继续比较两个节点的字节点，直到结束。<br>这样的话，在列表渲染的时候，就会高效的复用DOM结构，大部分时间，只需要更新每个节点所绑定的列表数据就行了。</p><p>​</p><p>通过示意图来说明一下：</p><p>我们打算更新一个列表，向列表插入一条数据<br><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftihu78iikj30d905b74a.jpg" alt="更新列表"></p><p>在更新完成之后，它是这样的:<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1ftihuo0y1bj30fw05zdg5.jpg" alt="withkey"></p><p>上面这一排是旧的页面结构对应的vnode节点，下面是vue根据更新后的数据生成的虚拟vnode节点，通过diff算法来比较它们从而决定如何更新页面DOM结构。</p><p>需要注意的一点是，vue只会更新节点绑定的列表数据，对于节点自身的数据和状态，也是跟结构一样，直接复用的。比如我们渲染一个select选择器的option属性，如果原来相同位置的option有个自己的状态disable，那它的结构被复用的话，它的disable数据同样也会被保留。可能会造成比较奇怪的bug，比如列表渲染的第二个元素是disabled的。这也是vue推荐除非特殊情况，一般都应该加上key的原因。<br>那如果我们给v-for绑定上key的话。这个key就相当于节点的id，vue在渲染时，对于存在前后key相同的元素，它就会直接复用，如下<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1ftihuxpp95j30ck03mq38.jpg" alt=""></p><p>这样，vue通过key，就可以不单单只复用节点的结构，还可以复用节点绑定的列表数据，性能上会优势，同时它一起复用结构和数据，也会避免一些怪异的bug。</p><p>另外提一点，通过上面的解读，大家也可以发现一点，用列表的index来做key的话其实也存在一点点问题，因为这样会导致vue把明明前后不是同一个的节点当成同一个。也就是说，使用index做key的话，大部分时间，其实跟不加key是一样的效果，只不过vue不会报警告。但总的来说，因为大家都习惯了拿index当key，在大部分时间列表项的唯一id也不是那么好找，所以大概了解key的原理，遇到列表渲染奇怪的表现时也好处理一些。</p></li></ul><p>当然，key的作用也不止v-for这些，它另外的作用就是阻止组件复用。</p><p>比较典型的, 我们有一个展示 poi 的组件，它的页面路由是<code>poi/${id}</code>，我们在它的<code>created</code>函数里根据id获取数据， 现在我们在 poi/22 页面，然后我们通过修改地址栏路由也好，或者通过$router的路由跳转方法也好，将路由改成 poi/23 ，</p><p>我们会发现页面并没有变化，这就是因为vue在判断前后节点结构相同，就直接复用了原有的节点，也就不会重新生成和插入节点，当然就不会触发组件的生命周期钩子。</p><p>当然，这种时候我们可以通过watch <code>$route</code>来处理，但还有另一种比较简便的做法，就是为路由出口加上<code>key</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;$route.fullpath&quot;&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>拿路由当做<code>key</code>，这样一来，vue在diff的时候发现前后key不同，就不会再重用组件了，生命周期钩子函数也就会按照我们预期的来触发了。</p><p>通过为元素加上<code>key</code>，来保证元素动画的正常触发，也是同样的道理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下，对于列表渲染来说，我们可以通过key来增加元素的复用程度，让它不光顺序复用结构，还可以根据节点id身份来复用，但对于路由来说，我们又可以通过key来让它不复用组件结构，从而正常触发组件的生命周期。在组件里呢，我们可以通过生命周期来获取数据，也可以通过增加watch的<code>immediate</code>选项来不使用生命周期就获取到初始数据，我们甚至可以在进入页面前就通过路由守卫先把数据获取了，这也就是vue的灵活性的体现，你想怎么来都行，官方也并没有给如何完成某个功能给出明确的建议，但不管什么框架，保证开发效率高效的同时，避免混乱，都是最佳实践的不变主题。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习（五）：《算法图解》笔记(二)</title>
      <link href="/2018/07/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2018/07/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p>本篇博客是《算法图解》读书笔记的第二篇。</p><p>这本书的前半部分，主要是对算法中的一些基础知识和思想的解读。进入后半部分，则开始相对深入的介绍了一些比较复杂问题的算法解决方案，例如图和树等。</p><p>对于我来说，这本书后半部分的阅读，主要是抱着拓展视野，知其大概的想法，真想解决什么问题，我估摸着得先去把那本《算法导论》啃两遍才行。因此，我并没有详细的研究算法如何具体实现，只要能简单的理解算法的思路和策略，我也就比较满意了。</p></blockquote><h3 id="第六章：广度优先搜索"><a href="#第六章：广度优先搜索" class="headerlink" title="第六章：广度优先搜索"></a>第六章：广度优先搜索</h3><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>图，由节点<strong><em>(node)</em></strong>和边<strong><em>(edge)</em></strong>组成。相邻的节点成为邻居。</p><p>如果边带有方向，即相邻节点关系为单向的，称为有向图。</p><p>如果边不带方向，即相邻节点关系为双向的，称为无向图。</p><p>有向图中，如果所有边的方向都是一致的，又称为树。</p><p>如果有向图中，没有相邻节点互相双重连接，也就是没有环形结构，又称为有向无环图。</p><h4 id="数据结构之队列"><a href="#数据结构之队列" class="headerlink" title="数据结构之队列"></a>数据结构之队列</h4><p>队列，是一种先进先出<strong><em>(FIFO–first-in/first-out)</em></strong>的数据结构。类似栈的压入和弹出，队列支持两种操作，入队和出队。</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索主要用于解决两类问题：</p><ol><li>路径是否存在问题。即从一个节点到另一个节点，是否存在路径</li><li>路径最短问题。从一个节点到另一个节点，最短路径是哪条。</li></ol><p>广度优先搜索的具体步骤如下：</p><ol><li>将起始节点的所有相邻节点加入队列</li><li>取出队列中一个节点，检查是否为目标节点，如果是，目的达成。</li><li>如果不是，将此节点的所有邻居入队</li><li>重复步骤2</li></ol><p>需要注意的是，在广度优先搜索中，需要记录检查过的节点，避免因为存在环形结构而导致无限循环。</p><p>从上面的步骤介绍中，我们知道我们需要遍历所有的边，从而将所有节点加入队列，同时遍历队列，找出目标节点。因此，广度优先搜索的时间复杂度为<code>O(V+E)</code>，其中<code>V</code>为顶点数<strong><em>(vertice)</em></strong>，<code>E</code>为边数。</p><h3 id="第七章：狄克斯特拉算法"><a href="#第七章：狄克斯特拉算法" class="headerlink" title="第七章：狄克斯特拉算法"></a>第七章：狄克斯特拉算法</h3><h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><p>当图的边具有相应权重时，称为加权图。</p><p>对于加权图，要找出权重之和最低的路径，可以使用狄克斯特拉算法。</p><h4 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h4><p>狄克斯特拉算法适用于有向无环，且不存在负权边的图。</p><p>它通过不断找出到达每一节点层级的最短路径节点，从而找到到达目标节点的最短路径。步骤如下：</p><ol><li>列出到达所有节点的开销权重表（若目前无法到达，可暂设为无穷大</li><li>找出目前能到达的节点中路径最短的节点，遍历其邻居，更新开销表</li><li>找出目前能到达的节点中路径第二短的节点，遍历其邻居，更新开销表</li><li>直到遍历完所有节点，开销表中到达目标节点的开销，即为最短路径的长短</li></ol><p>狄克斯特拉算法，通过保证到达遍历节点过程中，每个节点的开销都为最小的，从而一步步找到最终所需的最短路径。也因为如此，狄克斯特拉算法只适用于无负权边的图，因为在存在负权边时，是无法根据已知开销，就确定到目前节点的路径为最短的。对于负权边的情况，可以使用贝尔曼-福德算法。（书中也只是提了个名字，我也不知道是个啥。</p><p>同时需要注意，每一步更新节点开销时，都要记录更新开销时的父节点，从而在最终根据父节点回朔得到具体的最短路径。</p><h3 id="第八章：贪婪算法"><a href="#第八章：贪婪算法" class="headerlink" title="第八章：贪婪算法"></a>第八章：贪婪算法</h3><p>贪婪算法，是指每一步都采取局部最优解的算法。</p><p>贪婪算法在某些情况下，获得的结果与全局最优解完全一致。但在某些情况下，并不是全局最优解，但也非常接近。</p><h4 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h4><p>NP完全问题，是指形如你需要列出所有的解，并从中选出最大或最小的那个这类问题。前文提过的旅行最短路径问题，就是NP完全问题。</p><p>集合覆盖问题，即存在若干个元素和若干个集合，每个集合中都包含有数个元素，选出最少的集合数，能够包含所有元素，也是一个NP完全问题。</p><p>在大部分情况下，NP完全问题是无法得出最优解的，只能求出与最优解近似的近似解。</p><p>不存在比较好的方法来确定一个问题是不是NP完全问题，但可以通过以下几个特征来进行一些辅助推断：</p><ol><li>随着元素的增加，时间复杂度近乎阶乘阶。</li><li>涉及 <strong><em>元素的所有组合</em></strong>类的问题</li><li>无法分解降低问题规模</li><li>涉及<strong><em>所有可能顺序</em></strong>的问题。</li><li>可以转化为旅行商和集合覆盖问题的问题，可以确定是NP完全问题。</li></ol><h3 id="第九章：动态规划"><a href="#第九章：动态规划" class="headerlink" title="第九章：动态规划"></a>第九章：动态规划</h3><p>动态规划，是指将一个问题分解为多个子问题问题，求出每个子问题的局部最优解，最终得到全局最优解。</p><p>动态规划在局部最优解也是全局最优解，且局部最优解的决策在后续决策中会不断被用到的情况下非常有效。</p><p>书中举例是有一个小偷，去商场偷东西，有各种商品，价格不同，体积也不同，有一磅，二磅，三磅等等。小偷的背包体积确定为4磅，现在需要确定小偷偷哪些商品，才能在本次偷窃中赚的最多。</p><p>这是一个十分适合使用动态规划解决的问题，首先计算，当背包为一磅时，偷哪些商品价值最高，再计算背包为两磅时，偷哪些商品，最终，我们就可以确定，背包为4磅时，偷哪些商品可以获得最多的价值。</p><p>动态规划将一个多阶段决策分解为多个局部的小决策，这就必须保证问题的粒度是可分的。如果上面的可偷商品可以只偷一部分的话，例如大米有三磅，但可以只拿一磅，这种时候动态规划就无能为力了。可以考虑使用贪婪算法。</p><p>对于动态规划来说，必须保证更细粒度的子问题是离散的，也就是某个局部最优解确定后，后续的决策不会影响到这个最优解。</p><p>动态规划问题，常见于求最长公共子序列问题。</p><h4 id="费曼算法"><a href="#费曼算法" class="headerlink" title="费曼算法"></a>费曼算法</h4><p>费曼算法是计算机领域的一个著名算法，它的步骤如下：</p><ol><li>把问题写到纸上</li><li>思考</li><li>将答案写到纸上</li></ol><h3 id="第十章：-K最近邻算法（k-nearest-neighbours-KNN）"><a href="#第十章：-K最近邻算法（k-nearest-neighbours-KNN）" class="headerlink" title="第十章： K最近邻算法（k-nearest-neighbours-KNN）"></a>第十章： K最近邻算法<strong><em>（k-nearest-neighbours-KNN）</em></strong></h3><p>K最近邻算法，通常用于进行分类和回归。</p><p>它将具体对象的一些特征值提取为一个N维数组，通过计算相互对象的特征值在N维坐标系中的距离，来确定对象之间的相似度，从而将相似度较高的对象以邻居归类。</p><p>书中举例一个电影推荐系统，每个用户都为很多电影打分，将用户对特定电影的打分值作为特征值，得出一个特征值数组，通过计算两组特征值的距离远近，来确定两个用户的相似度，从而将一个用户比较喜欢的电影推荐给另一个与他品味相似的用户，或者根据近邻用户为某部电影的打分，来预测当前用户的打分大概会是多少，也就是上面所说的回归。</p><p>当然，判断两个对象是否是邻居要根据特征值的选取和具体问题确定，不一定是坐标系中的距离，也可能是余弦相似度等。</p><p>KNN算法，是机器学习中的一个重要算法。</p><p>通过对大量相关对象提取特征值，也就是机器学习中的<strong>训练</strong>，来组成一个特征值库，通过KNN算法配合特征库，使机器具有识别和预测的能力，也就是我们常说的人工智能。当然，这里只是对人工智能粗浅的一个认识，真正的人工智能领域，是相当复杂和多变的。</p><p>KNN算法，比较常见的应用就是图像识别，人脸识别，语音识别，推荐系统等等。</p><p>另外，各论坛常见的关键字过滤系统，其中也有KNN算法的功劳。</p><h3 id="第十一章：其他常见算法"><a href="#第十一章：其他常见算法" class="headerlink" title="第十一章：其他常见算法"></a>第十一章：其他常见算法</h3><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>在前面的二分法介绍中，我们提到了二分法查找有序数组时效率很高。但是数组的插入和删除效率十分低，因此不适合存储用来查找的数据。</p><p>这时就需要二叉查找树来发挥作用了。</p><p>二叉查找树是一种左边的子节点始终小于父节点，右边的子节点始终大于父节点的数据结构。</p><p>当查找某个节点时，就沿着树形结构一路比较下去，直到找到目标节点。</p><p>处于平衡状态时，二叉查找树的查找时间复杂度为<code>O(logn)</code>，但不平衡时，查找的时间复杂度可能达到<code>O(n)</code>，是弱于二分查找的。</p><p>但二叉树相比数组的二分查找的优点在于，它的插入和删除的时间复杂度也平均为O(logn)，是优于数组的。但相比数组，它又有不能随机访问的缺点。</p><h4 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>傅里叶变换，用于分离信号。例如常见的音频信号，傅里叶变换能将其中的各个频率音符分离出来。</p><p>它常用于压缩音频文件，进行信号处理等。</p><h4 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h4><p>并行算法用于处理海量数据，通过多核处理器，来对问题进行同时的多重计算。</p><p>并行算法对问题解决的速度提升并不是线性的，主要是因为下面两个原因：</p><ol><li><strong>并行管理开销</strong> 例如两个内核的任务分配和结构处理等。</li><li><strong>负载均衡</strong> 平衡各内核间的工作量，从而达到均匀的负载。</li></ol><h4 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h4><p>分布式算法是一种特殊的并行算法，它并不是在多核上运行，而是在多台计算机上运行。</p><h4 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h4><p>SHA算法，是一个散列函数，可以根据一个字符串生成另一串唯一的字符串。但你并不能根据这一个唯一的字符串得到它的原始字符串。</p><p>它通常用于文件比较，存储密码等。</p><p>SHA算法包括SHA-0，SHA-1，SHA-2，SHA-3。SHA-0和 SHA-1 已经被确定为不安全的了。</p><p>SHA算法是局部不敏感的，也就是说，原始字符串的一个小小改动，就会导致SHA算法生成的唯一字符串完全不同。</p><h4 id="SimHash"><a href="#SimHash" class="headerlink" title="SimHash"></a>SimHash</h4><p>SimHash 与 SHA算法类似，不同之处在于，SimHash 算法是局部敏感的，因此常用于比较两个文件的相似程度，判断文件是否存在等。</p><h4 id="Diff-Hellman密匙交换"><a href="#Diff-Hellman密匙交换" class="headerlink" title="Diff-Hellman密匙交换"></a>Diff-Hellman密匙交换</h4><p>Diff-Hellman是一种加密方式。它提供一个公开的公钥，所有人都可以用此公钥来对数据进行加密，但只有私钥可以对这些加密的数据解密。你可以将公钥发放给需要进行信息传递的一方，从而达到与对方加密通信的效果。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript入门(一):编辑器相关</title>
      <link href="/2018/07/06/VimScript(%E4%B8%80)/"/>
      <url>/2018/07/06/VimScript(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><p><img src="https://i.loli.net/2018/07/08/5b41d99199b25.jpeg" alt="vim.jpeg"></p><blockquote><p>用 VIM 也有一段时间了，插件和各种配置也尝试了不少，但由于不懂<code>VimScript</code>，很多时候遇到问题，并没有办法自己解决，只能去各种搜解决方案。很多时候，解决了问题，也是知其然而不知其所以然。</p><p>因此，打算学习一下<code>VimScript</code>，从而加深对Vim的了解，也可以在后续根据实际需求来自己定义一些Vim配置，写一些实用的<code>Vim</code>脚本。</p><p>这篇是 <strong><em>VimScript入门系列</em></strong> 的第一篇。</p></blockquote><a id="more"></a><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>&quot;打印消息到命令行ececho</code></pre><p>另外还有<code>echo</code>的各种形式，例如<code>echom</code> 以消息形式打印，<code>echoe</code>以错误形式打印。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code>&quot; 使用一个双引号作为注释</code></pre><h2 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h2><h3 id="布尔选项"><a href="#布尔选项" class="headerlink" title="布尔选项"></a>布尔选项</h3><p>以 name 选项为例</p><pre><code>&quot; 将选项设置为onset &lt;name&gt;&quot; 将选项设置为offset no&lt;name&gt;&quot; 切换选项值set &lt;name&gt;!&quot; 查询选项值set &lt;name&gt;?</code></pre><h3 id="键值选项"><a href="#键值选项" class="headerlink" title="键值选项"></a>键值选项</h3><p>对于选项值不是布尔值而是其他具体值的选项，使用<code>set</code>，如果想只作用于当前文件，使用<code>setlocal</code>。</p><pre><code>&quot; 设置选项值set &lt;name&gt;=&lt;value&gt;&quot; 查询选项值set &lt;name&gt;?&quot; 可以一次设置多个选项值set &lt;name1&gt; &lt;name2&gt;=&lt;value&gt;</code></pre><p>一些基本的设置选项</p><pre><code>&quot; 布尔选项number &quot; 是否显示行号，wrap   &quot; 是否折行shiftround &quot; 使用 &gt;&gt; 或 &lt;&lt; 时， 是否依shiftwidth 调整宽度relativenumber &quot; 是否使用相对行号numberwidth &quot;行号的宽度，键值选项matchtime &quot;括号高亮的匹配时间</code></pre><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><pre><code>&quot; 将某按键name映射为&lt;key&gt;按键map &lt;name&gt; &lt;key&gt;&quot; 删除按键unmap &lt;name&gt;&quot;非递归的映射noremap &lt;name&gt; &lt;key&gt;</code></pre><ul><li>以上三种映射均可以在前面加上i，n,v来表示插入，普通和可视模式。</li><li>Vim可以映射按键序列，形如noremap<name><name>key</name></name></li><li>有以下几个特殊按键<ul><li><code>&lt;C-d&gt;</code> Ctrl</li><li><code>&lt;A-d&gt;</code> Alt</li><li><code>&lt;space&gt;</code> 空格键</li><li><code>&lt;esc&gt;</code> Esc键</li><li><code>&lt;nop&gt;</code> 无键值，通常用于取消掉一些默认按键的行为</li></ul></li><li>leader 键 可以通过let mapleader=<name>设置键name为leader，来更好的进行按键映射。<ul><li>另外有一个localleader选项，可以用于特定文件中的leader键设置。</li></ul></name></li><li>键盘映射无法使用 “ 在行内注释。</li><li>可以使用buffer设置只作用于当前文件的本地映射，形如:nnoremap<buffer>Q x 。</buffer></li><li><code>:normal</code> 用于在定义命令时相当于在普通模式下按下其后跟随的按键。但它无法识别特殊字符。</li><li>如果想识别特殊字符，比如尖括号，下划线等，可以使用<code>excute</code>命令。<code>excute</code>命令后跟随一个 vim 的字符串形式脚本命令，类似这样<code>excute &quot;normal! gg&quot;</code></li></ul><h3 id="operator-Pending-映射"><a href="#operator-Pending-映射" class="headerlink" title="operator-Pending 映射"></a>operator-Pending 映射</h3><p>在VIM中，可以在一个操作<code>&lt;operator&gt;</code>后跟随一个移动命令或选中命令，从而为这个操作指定范围。比较常见的操作例如<code>d</code>，<code>y</code>,<code>c</code>等。<br>可以使用<code>operator-Pending</code>映射来将一个移动命令定义为<code>operator-pending</code>映射。从而使其可以与操作命令连用。<br>如这个命令：<br><code>onoremap p i(</code><br>就是将 <code>p</code> 映射到 <code>i(</code>, 使用<code>dp</code>命令，就相当于执行了<code>di(</code></p><p>通常，<code>operator-Pending</code>映射的作用规则是:</p><ul><li>如果映射到的命令以选中文本结束，则操作命令会操作这些文本。</li><li>否则，VIM 会从光标位置操作到移动命令终点之间的文本。</li></ul><h2 id="缩写abbreviations"><a href="#缩写abbreviations" class="headerlink" title="缩写abbreviations"></a>缩写abbreviations</h2><p>使用<code>abbrev</code>选项来定义缩写，在你输入某些字符时自动替换为另外的字符。一般在前面加上i来在插入模式下使用，如下：</p><pre><code>&quot; 当你输入 retrun 时自动替换为 returniabbrv retrun return</code></pre><p>缩写可以用来纠正常见的拼写错误或者定义一些简短的代码片段。</p><h2 id="自动命令"><a href="#自动命令" class="headerlink" title="自动命令"></a>自动命令</h2><p>自动命令，可以在特定模式的特定事件事件发生时，自动执行命令。</p><p>使用<code>autocmd</code>来编写自动命令。</p><p>形如：</p><p><code>autocmd VimEnter * PlugInstall</code></p><p>具体如下：</p><ul><li><code>vimEnter</code>为事件类型，可以使用逗号来添加多个事件到自动命令。使用<code>:help autocmd-events</code>来查看 VIM 支持的所有事件类型。</li><li>为事件匹配模式<strong><em>pattern</em></strong>，可以是文件名，文件类型等</li><li><code>PlugInstall</code>为自动执行的命令</li></ul><h3 id="FileType-事件"><a href="#FileType-事件" class="headerlink" title="FileType 事件"></a>FileType 事件</h3><p>FileType 事件会在 VIM 设置一个缓冲区的时候filetype时触发，是非常常用的事件。</p><p>下面是一个在文件类型为 Python 时自动将<code>&lt;leader&gt; c</code>设置为添加行注释的命令</p><pre><code>:autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;esc&gt;</code></pre><h3 id="自动命令组"><a href="#自动命令组" class="headerlink" title="自动命令组"></a>自动命令组</h3><p>因为 VIM 在每次读入<code>.vimrc</code>文件时，都会载入自动命令，导致命令被多次定义。可以使用命令组的自动清除来防止这个问题。</p><p>命令组的定义如下：</p><pre><code>:augruop groupname:autocmd ...:autocmd ...:augruop end</code></pre><p>通过在命令组中加入清除autocmd命令<code>autocmd !</code>，来实现每次载入命令组时都清除组内的所有自动命令效果。</p><pre><code>:augruop groupname:autocmd ！:autocmd ...:augruop END</code></pre><h2 id="状态条"><a href="#状态条" class="headerlink" title="状态条"></a>状态条</h2><p>使用<code>set statusline=</code>来设置状态条的格式，一些有用的字符串插值如下:</p><ul><li><code>%f</code> 文件名</li><li><code>%F</code> 文件路径</li><li><code>%y</code> 文件FileType类型</li><li><code>%l</code> 当前行号</li><li><code>%L</code> 总行数</li><li><code>%=</code> 切换到状态条右侧</li></ul><p>有以下几个需要注意的地方：</p><ol><li>空格需要使用<code>\</code>转义</li><li>使用数字来表示字符最小宽度<ul><li><code>%4l</code>，表示行号最少占4个字符。</li><li>空位字符位于右边，则使用<code>%-4l</code>。</li><li>使用0代替空位，则使用<code>%04l</code>。</li></ul></li><li>使用点加数字来表示字符最大宽度。形如<code>%.20F</code></li></ol><p>可以使用<code>+=</code>来通过多行代码定义动作条，使其语义更清晰。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> VIM </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习（四）：《算法图解》笔记(一)</title>
      <link href="/2018/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2018/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p>前段时间一直在看《算法图解》，这本书图文并茂，深入浅出，还是比较易读的。在阅读的过程中，记了一些笔记，都是一些算法领域相关的比较基础的一些知识。</p><p>我总觉得，读一本书，要有一本书的收获这句话是比较贪婪的说法，抱着功利心去读书，反而不如平常心去读更有乐趣点。但对于技术类的书来说，这句话我觉得还是比较贴切的（废话，技术书里面又没有那么多跌宕。</p><p>关于读书笔记这件事，我并不会照着抄一些书里加粗黑体的概念来充数，主要是记录一些我对书中内容的理解。</p><p>内心OS：其实我知道上面说这么一堆并没有什么用。因为并不会有人看我的博客。我日。</p></blockquote><a id="more"></a><h3 id="第一章：算法简介"><a href="#第一章：算法简介" class="headerlink" title="第一章：算法简介"></a>第一章：算法简介</h3><p>主要介绍了关于算法的一些基本知识，例如大O表示法等。关于大O表示法在此不多记录，需要的同学可以去看<a href="https://gyufei.github.io/2018/04/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" target="_blank" rel="noopener">我算法学习的第一篇博客</a>，就是关于大O表示法的。</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>作为最简单和容易理解的查找算法，它的步骤如下：</p><ol><li>取列表的中间值与要查找的目标元素进行比较</li><li>根据比较结果选择列表的前半部分或后半部分为一个新列表</li><li>对新列表重复步骤1，直到找到目标元素。</li></ol><p>二分查找只能应用于有序列表。因为它需要根据目标元素与列表中间元素的比较结果来缩小列表，从而进一步确定目标元素所处的位置，如果是无序列表的话，与列表中间元素的比较毫无意义。</p><p>也比较容易得出，二分查找的时间复杂度为<code>O(logn)</code></p><h4 id="旅程最短问题"><a href="#旅程最短问题" class="headerlink" title="旅程最短问题"></a>旅程最短问题</h4><p>旅程最短问题，即某个人，要去n个城市，各个城市之间距离不同，求出它的最短旅程。</p><p>抽象出来就是：求出遍历<code>n</code>个互相距离不同的点的最短路线。</p><p>此问题的最基本解决思路如下：</p><ol><li>确定遍历顺序，也就是列举出所有可能的路线</li><li>计算每种路线的路程</li><li>选出最短路径</li></ol><p>我们知道，<code>n</code>个元素的排列顺序，有<code>n！</code>种，因此上面的解决办法，其时间复杂度为<code></code>O(n！)<code>。当</code>n&gt;20`之后，此类解决方法需要列举的路线已经是一个天文数字了，因此上面的解决办法已经近乎无能为力了。</p><p>对于旅程最短问题，至今仍没有比较完美的解决办法。但通过二叉树等算法，我们可以得到一个近似的最短路径结果。</p><h3 id="第二章：选择排序"><a href="#第二章：选择排序" class="headerlink" title="第二章：选择排序"></a>第二章：选择排序</h3><h4 id="数据结构之数组"><a href="#数据结构之数组" class="headerlink" title="数据结构之数组"></a>数据结构之数组</h4><p>数组作为存储元素的一种数据结构，它的所有元素在内存中都是连续的，因此它有着很快的读取速度，例如我们需要第5个元素，数组通过第一个元素的内存地址，就可以直接得到第5个元素的内存地址。</p><p>但数组的插入速度是非常慢的，主要有以下两个原因：</p><ul><li>在数组中间插入一个元素，就必须移动插入位置之后的所有元素</li></ul><ul><li>如果数组的后面的内存已经被占用，数组就无法再加长了，如果想加长，就必须将整个数组都移动到可以容纳更长数组的内存空位去。（虽然可以通过为数组后面预留空位来解决这个问题，但也只是权宜之计</li></ul><p>同理，当删除数组元素时，必须前移其后的所有元素，所以数组的删除速度也很慢。</p><p><strong>具体的，数组的读取速度为<code>O(1)</code>，插入和删除速度为<code>O(n)</code></strong></p><p>另外，数组这种数据结构还有一点需要注意，它的所有元素的类型必须相同。</p><h4 id="数据结构之链表"><a href="#数据结构之链表" class="headerlink" title="数据结构之链表"></a>数据结构之链表</h4><p>链表的元素在内存中并不是相邻的，而是分散的，通过前一个元素存储下一个元素的地址，将一系列内存地址串成一个链表。这也是链表名字链字的由来。</p><p>对于链表来说，它的插入和删除速度是非常快的，因为在插入和删除时，都只需要修改它前一个元素存储的内存地址即可，不需要移动其他元素。</p><p>但链表的读取速度非常慢，因为无法像数组一样，通过第一个元素的内存地址就得出任意索引位置的地址。它必须从头开始，顺序得到每个元素的地址。</p><p><strong>具体的，链表的读取速度为<code>O(n)</code>，插入和删除速度为<code>O(1)</code></strong></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序，是一种时间复杂度为O(n<sup>2</sup>) 的排序算法。具体步骤如下：</p><ol><li>遍历列表，找出列表的最大值，取出放入一个空列表</li><li>重复步骤1，直到列表中元素全被取出。</li></ol><h3 id="第三章：递归"><a href="#第三章：递归" class="headerlink" title="第三章：递归"></a>第三章：递归</h3><p>递归函数，即在函数运行时又调用了自身的函数。</p><p>递归函数中，递归条件指函数调用自己的条件，基线条件是指，递归函数停止调用自己的条件。</p><p>递归函数必须有基线条件，这样才能避免无限循环。</p><h4 id="数据结构之栈"><a href="#数据结构之栈" class="headerlink" title="数据结构之栈"></a>数据结构之栈</h4><p>栈<strong><em>(stack)</em></strong>是一种先进后出<strong><em>（FILO - first-in/last-out)</em></strong> 的数据结构，数据只能在栈顶进行添加和删除，即栈的<strong>压入</strong>和<strong>弹出</strong>。</p><p>对于函数调用来说，存在一个函数的<strong>调用栈</strong>，存储了函数调用所需的变量和上下文。</p><p>如果递归层数过多，会产生非常多的函数调用栈，占用大量内存，造成栈溢出，此时可以借助尾递归优化。</p><p>尾递归优化，就是指所有递归函数都使用同一个栈，大部分语言针对递归进行了尾递归优化。必须保证递归函数只返回自身调用，没有其他多余返回值时，才能使用。</p><h3 id="第四章：-快速排序"><a href="#第四章：-快速排序" class="headerlink" title="第四章： 快速排序"></a>第四章： 快速排序</h3><p>分而治之<strong><em>(D&amp;C - divide and conquer)</em></strong>策略，是指找出递归的基线条件和递归条件，通过递归来解决问题的一种策略。</p><p>快速排序就是使用分而治之策略的一种排序算法。具体步骤如下：</p><ol><li>在列表中选取一个基准值</li><li>将小于基准值的元素和大于基准制的元素分别放入一个列表。</li><li>如果得到的列表长度小于2，返回列表，否则，对得到的列表递归进行快速排序</li></ol><p>采用递归进行排序的快速排序算法，时间复杂度和基准值的选择关系较大，最糟情况下（选取列表端值作为基准），时间复杂度为<em>O(n²)</em>，平均时间复杂度为<em>O(n log n)</em></p><h3 id="第五章：-散列表"><a href="#第五章：-散列表" class="headerlink" title="第五章： 散列表"></a>第五章： 散列表</h3><p>散列表，有多种叫法，在<code>python</code>中叫字典，在<code>ruby</code>中叫哈希，在<code>PHP</code>中叫关联数组。但在作为数据结构时，通常都称为散列表。散列表用于存储映射关系，也就是我们常说的键名和键值。</p><p>散列表是由散列函数和数组共同组成的一种数据结构，具有<code>O(1)</code>时间复杂度的查找速度。</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数，是指接受任意输入，并返回一个数字的函数，即可以将输入映射到一个数字。</p><p>散列函数必须保证以下两个要求：</p><ul><li>一致性。对于相同的输入，必须返回相同的数字。</li><li>差异性。对于不同的输入，尽可能的映射到不同数字。</li></ul><p>通过散列函数的这种特性，将键名输入散列函数，得到一个数字，将键值存入数组中对应此索引的位置，就实现了散列表。</p><p>在散列表中通过键名查找键值时，将键名输入散列函数，就可以得到存储对应键值的数组索引。</p><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>不可能存在将所有不同输入映射到不同数字的散列函数，因为数组的长度并不是无限的。因此，在有限的数组前提下，散列函数一定会存在将不同键名映射到数组相同索引的情况，也就是冲突。</p><p>解决冲突的方法，最简单的，就是在冲突的位置不存储单个键值，而是存储一个链表，在链表中存储此索引处的所有键名键值。</p><h4 id="填装因子"><a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h4><p>填装因子，即<strong>散列表键值元素数占散列表数组长度的比值</strong>。一般来说，当填装因子大于0.7时，散列表当前的数组已经不适合继续使用了，应该对数组调整长度（别忘了我们前面说的，调整数组长度是比较耗费性能的。</p><p>散列表如果想实现比较好的性能，就要尽可能避免冲突，尽量满足以下要求：</p><ul><li>良好的散列函数，能尽可能的将键值均匀的分布在数组中</li><li>较低的填装因子，使数组有较多空位来继续容纳新元素</li></ul><blockquote><p>以上就是《算法图解》中前面章节前五章我记的一些笔记。为避免篇幅过长，这篇博客就到这里，下一篇博客再继续，关于算法中图的相关知识，记得回来^_^。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript数组和对象的遍历</title>
      <link href="/2018/06/06/JavaScript%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/06/06/JavaScript%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>遍历数组和对象是我们经常遇到的编程场景，<code>JS</code>有多种不同的方式和方法来遍历数组和对象，但每种方法深究起来又有各种差异，再加上对象的继承属性，不可枚举属性，<code>Symbol</code>属性等等，如果不熟悉这些方法的话，可能会造成隐藏较深的 <strong><em>bug</em></strong>。</p><p>因此，本篇博客就对有关数组和对象的各种遍历方法，做一个总结。</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=186668&auto=0&height=66"></iframe><p>首先需要说明的是，在<code>JS</code>中，数组可以视为恰巧拥有一些整数属性的对象。遍历对象的一些方法，都可以用来遍历数组。但通常对于数组和对象这两种不同用途的结构，我们在遍历它们时目的是不一样的，因此虽然有的方法可以用来遍历数组，但我们几乎不会拿来遍历数组，在下文中会有提及。</p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>数组可以视为一种特殊形式的对象，特殊之处在于，它有一些从0开始的整数的属性，也就是我们通常所说的索引。同时这个对象有一个<code>length</code>属性，它会根据索引数量的变化来动态改变其值。</p><p>对于数组遍历，我们通常是遍历它每个索引属性对应的值，而不会去遍历作为对象的它的其他属性，例如<code>toString</code>方法等。</p><p>关于数组的遍历，有以下几种方法。我们统一使用下面这个数组来举例。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'yewen'</span>, <span class="string">'huangfeihong'</span>, <span class="string">'fangshiyu'</span>, <span class="string">'huoyuanjai'</span>]</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a><strong><em>for</em></strong></h4><p>这是遍历数组时使用频率最高，也最简单的方式。</p><p>下面是普通的<code>for</code>循环。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length,; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有一些对<code>for</code>循环进行优化的小方法，例如缓存数组长度，使用局部的循环<code>index</code>等。如下</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,len = a.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环除了写起来麻烦一点，其实效率是相当不错的。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach( )"></a><strong><em>forEach( )</em></strong></h4><p><code>forEach</code>是数组的方法。你可能要问了，上面说了数组也是一个普通的对象，那么数组的这些不同于其他对象的方法是哪里来的呢？别忘了<code>JS</code>的 <code>Array</code>类型，数组的一些独有的方法，就是继承自<code>Array.prototype</code>。</p><p><code>forEach</code>方法的使用如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法接收一个函数作为参数。对每个元素，<code>forEach</code>都会使用当前元素，当前元素的索引，数组本身作为三个参数，调用传入的函数。（后两个参数如不需要，可省略)</p><p>同时需要注意，<code>forEach</code>方法一旦开始，是无法类似<code>for</code>循环一样，使用<code>break</code>终止的。</p><h4 id="map"><a href="#map" class="headerlink" title="map( )"></a><strong><em>map( )</em></strong></h4><p><code>map</code>方法，同样接受一个函数作为参数。此函数与<code>forEach</code>方法接受同样的三个函数参数。不同点在于，<code>map</code>对数组的每个元素调用此函数，并使用此函数的返回值作为数组项，组成一个新的数组返回。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    <span class="keyword">return</span> val + <span class="string">'map'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//=&gt; ['yewenmap', 'huangfeihongmap', 'fangshiyumap', 'huoyuanjaimap']</span></span><br></pre></td></tr></table></figure><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a><strong><em>for…of</em></strong></h4><p><code>for...of</code> 是<code>ES6</code>提供的新特性，用于遍历部署了<code>Iterator</code>接口的数据类型。例如<code>Map</code>，<code>Set</code>等。因为数组类型也具有原生的<code>Iterator</code>接口，所以也可以使用<code>for...of</code>遍历。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for...of</code>重复的将数组的值赋值变量<code>i</code>来供我们使用。</p><p>需要注意，此特性不支持<code>IE</code>。另外，字符串类型<code>String</code>也部署了<code>Iterator</code>接口，也可以通过<code>for...of</code>来遍历。</p><p>以上就是关于数组遍历的几种方法。另外，数组也有一些特别的方法，例如<code>filter</code>，<code>some</code>，<code>every</code>，<code>find</code>，<code>reduce</code>等，但这些方法主要的目的并不是完全为了单纯的遍历数组，因此在此不多做介绍。</p><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a><strong><em>keys()</em></strong></h4><p>在ES6中，加入了数组的<code>keys()</code>，<code>values()</code>, <code>entries()</code>三个方法，它们都返回一个迭代器，可以使用<code>for...of</code>来迭代。</p><p><code>keys()</code>返回由数组的索引组成的迭代器。</p><p><code>values()</code>返回由数组的值组成的迭代器。(此方法在<code>chrome</code>和<code>firefox</code>中均未实现）</p><p><code>entries()</code>返回一个由包含数组索引和值的数组的迭代器。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> arr.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> arr.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0,'yewen']</span></span><br><span class="line"><span class="comment">//[1,'huangfeihong‘]</span></span><br><span class="line"><span class="comment">//[2,'fangshiyu']</span></span><br><span class="line"><span class="comment">//[3,'huoyuanjia']</span></span><br></pre></td></tr></table></figure><h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><p>对象的属性，有继承属性和自有属性之分，又有可枚举属性和不可枚举属性之分。</p><p>所谓继承属性，就是指对象从原型对象继承而来的属性。例如我们上文提到的数组的<code>map</code>等方法继承自<code>Array.prototype</code>，<code>map</code>就是继承属性。</p><p>所谓可枚举属性，是指在<code>ES5</code>之后，对象的属性有了以下可以设置的四个特性：</p><ul><li><p>值<code>value</code></p><p>属性的值</p></li><li><p>可读性 <code>writeable</code></p><p>决定属性是否可读取</p></li><li><p>可配置性 <code>configurable</code></p><p>决定属性是否可删除，可修改</p></li><li><p>可枚举性 <code>enumerable</code></p><p>决定属性是否可以通过<code>for...in</code>循环返回</p></li></ul><p>在<code>ES3</code>中，对象属性默认就是可写，可配置，可枚举且无法修改的。<code>ES5</code>之后，我们可以通过<code>Object.defineProperty()</code>方法来定义对象的这些特性。</p><p>另外，在<code>ES6</code>中，引入了<code>Symbol</code>数据类型。因此对象存在特殊的一种情况，即使用<code>Symbol</code>值作为属性名。</p><p>对于上面提到的几种属性的区分和特殊情况，各个遍历属性的方法会有不同表现，具体的我们在每个方法中详细介绍。</p><p>下面来看遍历对象属性的常用方法。</p><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a><strong><em>for…in</em></strong></h4><p><code>for...in</code>会遍历对象的<strong><em>所有可枚举属性</em></strong>，因此，只要对象的属性是可枚举的，它就会被遍历到，无论此属性是继承自原型还是对象自有。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br></pre></td></tr></table></figure><p>我们来通过下面这个例子来演示<code>for...in</code>遍历的特点。</p><figure class="highlight js"><figcaption><span>Javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使childObj继承自obj</span></span><br><span class="line"><span class="keyword">var</span> childObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//为childObj定义一个不可迭代属性d(使用defineProperty定义的属性默认enumerable其实就是false)</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(childObj, <span class="string">'d'</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">childObj.e = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> childObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//e</span></span><br></pre></td></tr></table></figure><p>可以看出，<code>for...in</code>遍历了<code>childObj</code>的继承属性<code>a,b,c</code>和自有属性<code>e</code>，但并没有遍历不可迭代属性<code>d</code>。</p><p><code>for...in</code>不被建议用来遍历数组，使用它来遍历数组，主要有以下两点问题：</p><ul><li><code>for...in</code>不光会遍历到数组的索引值，如果数组有其他定义或继承的非整数可迭代属性，它一样会遍历到。</li></ul><ul><li><code>for...in</code>的遍历顺序是取决于当前的执行环境的，它并不一定会按照索引顺序来遍历数组的索引。</li></ul><h4 id="Object-getOwnPropertypeNames"><a href="#Object-getOwnPropertypeNames" class="headerlink" title="Object.getOwnPropertypeNames()"></a><strong><em>Object.getOwnPropertypeNames()</em></strong></h4><p><code>Object.getOwnPropertypeNames()</code>方法，返回一个由对象的<strong><em>所有自有属性</em></strong>的属性名组成的数组。</p><p>我们使用上面定义的<code>childObj</code>来看一下<code>Object.getOwnPropertypeNames()</code>的表现。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propArr = <span class="built_in">Object</span>.getOwnPropertypeNames(childObj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(propArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//["d", "e"]</span></span><br></pre></td></tr></table></figure><p>我们可以看到，<code>Object.getOwnPropertypeNames()</code>并没有遍历<code>childObj</code>的继承属性<code>a,b,c</code>，而只是遍历了它自有的不可枚举属性<code>d</code>和可枚举属性<code>e</code>。<em>**</em></p><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a><strong><em>Object.keys()</em></strong></h4><p><code>Object.keys()</code>方法，返回一个由对象的<strong><em>所有可枚举的自有属性</em></strong>的属性名组成的数组。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propArr = <span class="built_in">Object</span>.keys(childObj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(propArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//["e"]</span></span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，<code>Object.keys()</code>只会遍历到对象自有的且可枚举的属性，不会遍历到继承的属性和不可枚举的属性。</p><p>另外，<code>ES6</code>中添加了两个对象的新静态方法，<code>Object.values()</code>和<code>Object.entries()</code>，用于对应<code>Object.keys()</code>的自有可枚举，分别返回对象的相应所有键值组成的数组和对象的相应键值键名数组组成的数组。</p><h4 id="Object-getOwnPropertypeSymbols"><a href="#Object-getOwnPropertypeSymbols" class="headerlink" title="Object.getOwnPropertypeSymbols"></a><strong><em>Object.getOwnPropertypeSymbols</em></strong></h4><p>此方法用于遍历对象<strong><em>所有属性名为<code>Symbol</code>值的属性</em></strong>，返回一个由所有<code>Symbol</code>值属性组成的数组。</p><p>我们上文提到的三个遍历对象的方法，<code>for...in</code>，<code>Object.getOwnPropertypeNames()</code>，<code>Object.keys()</code>都是不会遍历到对象的<code>symbol</code>值属性的。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">var</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">childObj[foo] = <span class="number">666</span></span><br><span class="line">childObj[bar] = <span class="number">888</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> symbolArr = <span class="built_in">Object</span>.getOwnPropertypeSymbols(childObj)</span><br><span class="line"><span class="built_in">console</span>.log(symbolArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//[symbol(foo),symbol(bar)]</span></span><br></pre></td></tr></table></figure><h4 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a><strong><em>Reflect.ownKeys()</em></strong></h4><p><code>Reflect</code>，是<code>ES6</code>中新加入的一个内置对象，因为<code>ES6</code>中提供了<code>proxy</code>来代理对象的默认行为，所以提供了<code>Reflect</code>来保证在代理时也可以使用对象的原始默认行为。</p><p><code>Reflect.ownKeys()</code>与<code>Object.getOwnPropertypeNames()</code>行为基本相同，都返回一个由对象的<strong><em>所有自有属性</em></strong>的属性名组成的数组。唯一不同的是，它还会包括对象的<code>Symbol</code>值属性。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reflectKeys = <span class="built_in">Reflect</span>.ownKeys(childObj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reflectKeys)</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;</span></span><br><span class="line"><span class="comment">//["d", "e", symbol(foo), symbol(bar)]</span></span><br></pre></td></tr></table></figure><p>可以认为，<code>Reflect.ownKeys（target)</code> 等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。</code></p><p>关于遍历对象的方法的介绍就到这里，通过下面这个表格，对这些方法进行一个总结。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自有属性</th><th style="text-align:center">继承属性</th><th style="text-align:center">可枚举属性</th><th style="text-align:center">不可枚举属性</th><th style="text-align:center">Symbol属性</th></tr></thead><tbody><tr><td style="text-align:center"><code>for...in</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center">✘</td></tr><tr><td style="text-align:center"><code>Object.getOwnPropertypeNames()</code></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td></tr><tr><td style="text-align:center"><code>Object.keys()</code></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center">✘</td></tr><tr><td style="text-align:center"><code>Object.getOwnPropertypeSymbols()</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center"><code>Reflect.ownKeys()</code></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center">✘</td></tr></tbody></table><blockquote><p>✔ 表示只会遍历此种类型属性</p><p>✘ 表示不会遍历此种类型属性</p></blockquote><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十六）：自定义指令和过滤器</title>
      <link href="/2018/05/27/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E5%85%AD%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2018/05/27/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E5%85%AD%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>Vue 本身提供了很多例如<code>v-if</code> ，<code>v-for</code>等等的指令，用于对绑定的<code>DOM</code>元素进行各种各样的操作。在需要时，我们也可以自定义一些指令，从而实现一些操作逻辑的复用。</p><p>在使用双花括号或者<code>v-bind</code>指令绑定一些数据时，我们有时会需要对这些数据进行一些格式化操作，此时，我们可以自定义一个过滤器，方便快捷的完成这个需求。</p><p>本篇博客，就主要来介绍以下，Vue的自定义指令和自定义过滤器。</p></blockquote><a id="more"></a><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>我们可以通过两种方式来注册一个自定义指令——<strong>全局注册</strong>和<strong>局部注册</strong>。</p><p>全局注册，即使用<code>Vue.directive()</code>方法来注册，通过全局注册的指令，可以在全局的模板任意位置使用。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册一个自定义指令</span></span><br><span class="line">Vue.directive(<span class="string">'directiveName'</span>, options)</span><br></pre></td></tr></table></figure><p>其中，第一个参数为指令名称，第二个参数为指令的配置，为一个对象。</p><p>局部注册的指令，可以在其注册实例组件的模板中使用。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部注册一个自定义指令</span></span><br><span class="line"><span class="keyword">new</span> Vue(<span class="string">'componentName'</span>,&#123;</span><br><span class="line">    <span class="comment">//组件可以接受一个directives选项，</span></span><br><span class="line">    <span class="comment">//此选项值为对象，对象键为指令名，对象值为指令的options对象。</span></span><br><span class="line">    directives: &#123;</span><br><span class="line">       directiveName: options</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>在上面的组件注册中，我们提到指令有一个<code>options</code>对象，用于配置指令。在<code>options</code>对象中，我们可以使用此对象提供的指令作用各阶段的钩子函数，来实现指令的功能。</p><p>指令主要有以下几个钩子函数：</p><ul><li><p><code>bind</code></p><p>在指令绑定到<code>DOM</code>元素时调用，只会被调用一次。可以在此处执行指令的初始化设置。</p></li><li><p><code>insert</code></p><p>在指令绑定的<code>DOM</code>元素插入到父节点时调用。要注意的是，插入到父节点时父节点并不一定在文档中。</p></li><li><p><code>update</code></p><p>指令所在的组件更新时调用。</p></li><li><p><code>componentUpdated</code></p><p>指令所在的组件及其子组件全部更新后调用。</p></li><li><p><code>unbind</code></p><p>指令解除绑定时调用，同<code>bind</code>类似，只会被调用一次。</p></li></ul><p>以上是指令配置对象提供给我们的指令钩子函数。</p><p>这些钩子函数，都会被传入相同的参数，即<code>el</code>，<code>binding</code>，<code>vnode</code> 和 <code>oldVnode</code>。</p><p>各参数的具体含义如下：</p><ul><li><p><code>el</code></p><p>指令所绑定的<code>DOM</code>元素对象，可以用来直接操作绑定到的<code>DOM</code>。</p></li><li><p><code>vnode</code></p><p><code>Vue</code>编译生成的虚拟节点。作为抽象节点，<code>VNode</code>定义了很多属性，来模拟真实<code>DOM</code>节点。具体可以<a href="https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown" target="_blank" rel="noopener">点击此处查看</a></p></li><li><p><code>oldVnode</code></p><p>更新之前的<code>vnode</code>虚拟节点，在<code>update</code>和<code>componentUpdated</code>钩子中可用。</p></li><li><p><code>binding</code></p><p>一个对象，包含了和指令有关的一些属性。如下：</p><ul><li><p><code>name</code></p><p>指令名（不包括<code>v-</code>前缀</p></li><li><p><code>value</code></p><p>指令绑定的表达式计算后的值，如<code>v-dir=&quot;1+1&quot;</code>，则<code>value</code>为2</p></li><li><p><code>oldValue</code></p><p>指令绑定的前一个值，仅在<code>update</code>和<code>componentUpdated</code>钩子中可用。</p></li><li><p><code>expression</code></p><p>字符串形式的指令表达式，即未经计算的表达式。如<code>v-dir=1+1</code>，则其值为<code>&quot;1+1&quot;</code></p></li><li><p><code>arg</code></p><p>传给指令的参数，是钩子函数的可选参数。如在指令<code>v-dir:bar=&quot;1+1&quot;</code>中，则其值为<code>bar</code>。</p></li><li><p><code>modifiers</code></p><p>指令的修饰符对象参数，包含指令的各修饰符的使用情况。如在指令<code>v-dir.foo.bar=&quot;1+1&quot;</code>中，其值为<code>{foo: true, bar: true}</code>。</p></li></ul><p>需要注意的是，除了上面提到的这些属性中，除了<code>el</code>，其他都是只读的，不能进行修改。</p><p>指令通常是绑定到一个<code>JS</code>表达式，但也可以绑定到一个对象字面量。形如<code>v-dir=&quot;{label: true, hide: false}&quot;</code>。</p><p>下面我们来看一个在图片未加载出来时，使用随机颜色来填充图片背景的指令。从而对自定义指令的使用加深了解。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'image'</span>, &#123;</span><br><span class="line">    inserted (el,binding) &#123;</span><br><span class="line">       <span class="keyword">const</span> color = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10000</span>)</span><br><span class="line">       el.style.backgroundColor = <span class="string">`#<span class="subst">$&#123;color&#125;</span>`</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">       img.src = binding.value</span><br><span class="line">       img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            el.style.backgroundColor = <span class="string">''</span></span><br><span class="line">            el.src = binding.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外，值得注意的一点时，如果我们直接将指令的 <code>options</code>值传入为一个函数，而不是一个包含对应各个钩子的函数组成的对象时，这个传入的函数会对应到<code>bind</code>和<code>update</code>钩子函数上，这在有时会很有用。</p></li></ul><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>过滤器主要用于方便的对数据文本进行格式化，在我们想改变数据的显示格式但是不想改变数据本身时比较有用。它可以用在<strong>双括号插值</strong>和<strong><em><code>v-bind</code>指令</em></strong>中。例如我们有个 <strong><em>size</em></strong> 过滤器：</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;someData | size&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:data</span>=<span class="string">"someData | size"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的，过滤器也有两种定义方式。</p><h4 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h4><p>使用<code>vue.filter()</code>方法，来全局定义一个过滤器。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">`size`</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val.length &gt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> val.slice(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部定义"><a href="#局部定义" class="headerlink" title="局部定义"></a>局部定义</h4><p>在实例内部定义一个过滤器，只在实例组件内部可用。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部注册一个自定义指令</span></span><br><span class="line"><span class="keyword">new</span> Vue(<span class="string">'componentName'</span>,&#123;</span><br><span class="line">    filters: &#123;</span><br><span class="line">        <span class="comment">//val 为要过滤的数据值</span></span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(val.length &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> val.slice(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>过滤器可以串联使用，形如</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; someData | filterA | filterB | filterC &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以在定义过滤器时为其设置多个参数，在使用过滤器时传入它们的值。如下：</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">       <span class="comment">//val 为要过滤的数据值</span></span><br><span class="line">       size: <span class="function"><span class="keyword">function</span>(<span class="params">val, min, max</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(val.length &gt; min)&#123;</span><br><span class="line">           <span class="keyword">return</span> val.slice(min, max)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; someData | size(5,10) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于<strong><em>Vue</em></strong>的自定义指令和过滤器，就介绍到这里，希望对你有所帮助。谢谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十五）：关于组件的其他事情</title>
      <link href="/2018/05/22/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B6%E4%BB%96%E4%BA%8B%E6%83%85/"/>
      <url>/2018/05/22/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%94%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B6%E4%BB%96%E4%BA%8B%E6%83%85/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>本篇博客主要介绍在前几篇<code>vue</code>组件相关博文中未曾涉及的关于组件的一些知识。</p><p>包括父组件和子组件的一些特别的访问方式，循环引入的递归组件的处理，父组件向子组件的依赖注入等。</p></blockquote><a id="more"></a><h3 id="访问相关"><a href="#访问相关" class="headerlink" title="访问相关"></a>访问相关</h3><p>通常，我们通过<code>props</code>和 事件来进行父子组件之间的通信。但在某些情况下，我们可能也需要在父组件中直接使用子组件实例，或者反过来。</p><h4 id="parent"><a href="#parent" class="headerlink" title="$parent"></a><strong><em>$parent</em></strong></h4><p><code>vue</code>提供了一个组件实例属性<code>$parent</code>,用于让我们在子组件中直接访问父组件的实例。</p><p>这种方式可以作为父组件通过<code>props</code>向子组件传递数据方法的一个替代方法。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        ParentIndex: <span class="keyword">this</span>.$parent.index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但需要注意，这种直接访问父组件的方式，会让子组件和父组件耦合在一起，并使应用变得难以调试和维护。一般情况下使用<code>props</code>来进行父子组件的数据传递总是更好的方式。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>在某些时候，我们可能想让一个组件中包含的所有子孙组件，都能够得到此组件的某些数据。按我们普通的做法，有以下两种实现方式</p><ul><li>使用<code>props</code>，一层一层的将数据传递给子组件和后代组件。</li><li>在子组件中，使用<code>$parent</code>。形如<code>this.$parent.$parent</code>这种方式。</li></ul><p>但这两种方法都存在难以维护和繁琐的缺点。</p><p>因此，<code>Vue</code>提供了一种名为<strong>依赖注入</strong>的方式，让我们可以将父组件的某些数据属性，作为一个依赖，注入到需要使用它的子孙组件中。</p><p>在父组件实例中，我们使用<code>provide</code>实例选项，来声明我们提供给后代组件的属性和方法。</p><p>在子组件实例中，我们使用<code>inject</code>实例选项，来接收我们需要从父组件中注入的依赖。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    provide：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            someData: <span class="keyword">this</span>.someData</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件实例</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">    inject: [<span class="string">'someData'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种方式的优点在于，我们可以在父组件中提供一些属性，但并不需要主动将其传递到子组件中去。子组件在需要时，自行注入这些属性就可以了。避免了我们去主动组织这些数据的流动和传递的麻烦。</p><p>然而，这种方式是存在一些缺点的：</p><ul><li>依赖并不是响应式的，这意味着我们在子组件中注入这些依赖之后，如果父组件提供的数据更新了，子组件并不会去响应这些更新。</li><li>子组件与父组件的组织产生了耦合，例如，我们在想将子组件移出父组件时，需要对注入的依赖进行繁琐的清理。</li></ul><h4 id="root"><a href="#root" class="headerlink" title="$root"></a><strong><em>$root</em></strong></h4><p>Vue提供了一个实例选项<code>$root</code>用于在子组件实例中访问根实例。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        one: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        two: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        deliver: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个根实例的所有子组件中，我们都可以通过<code>$root</code>，来访问根实例中定义的这些数据和方法。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问根组件中的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.one</span><br><span class="line"><span class="comment">//将数据写入根组件</span></span><br><span class="line"><span class="keyword">this</span>.$root.one = <span class="number">100</span></span><br><span class="line"><span class="comment">//访问根组件中的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.two</span><br><span class="line"><span class="comment">//使用根组件中的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.deliver()</span><br></pre></td></tr></table></figure><p>在小型项目中，我们可以通过根实例，来维护我们的某些全局数据，通过<code>$root</code>来供所有子组件实例使用。</p><p>但是这种模式并不适合大型项目，在大型项目中，我们应该使用专门的状态管理器，例如<code>vuex</code>。</p><h4 id="children"><a href="#children" class="headerlink" title="$children"></a><strong><em>$children</em></strong></h4><p>使用<code>$children</code>，我们可以在当前实例中访问到它的所有直接子组件。有以下几点需要注意：</p><ul><li>它并不是响应式的，所以对于子组件的动态添加和移除，并不会表现在它返回的数组中。</li><li>它并不能保证返回数组的顺序和子组件的组织顺序一致。</li></ul><h4 id="refs"><a href="#refs" class="headerlink" title="$refs"></a><strong><em>$refs</em></strong></h4><p>我们可以在<code>DOM</code>或子组件上使用 <code>ref</code>这一特殊属性，来为元素或子组件注册引用信息。<code>ref</code>会将元素或子组件的引用注册在父组件的<code>$refs</code>对象上。</p><p>如果在普通元素上使用<code>ref</code>，引用指向的就是<code>DOM</code>元素，如果在子组件上使用，引用就指向子组件的实例。</p><figure class="highlight html"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过vm.$refs.aForm访问此DOM元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">ref</span>=<span class="string">"aForm"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过vm.$refs.child访问此子组件的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-componet</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-componet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样，<code>$refs</code>也并不是响应式的，所以下面这种<code>$refs</code>的使用方式是错误的，应该避免在模板或计算属性中使用<code>$refs</code>：</p><figure class="highlight html"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; $refs.child.text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，因为<code>$refs</code>是在组件<code>DOM</code>渲染完成后才被创建的对象，因此我们在组件初始化的过程中是无法使用它的。</p><p>当将<code>ref</code>和有<code>v-for</code>指令的元素或子组件一起使用时，得到的引用是<code>v-for</code>渲染出的所有元素或子组件实例的一个数组。</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>组件间的循环引用分为两种情况：</p><ul><li>组件在模板中调用自身</li><li>两个组件互相引用</li></ul><p>对于第一种情况，我们应该保证组件在模板中调用自身时，设置相关的递归终止条件（通常使用<code>v-if</code>指令保证递归可以在满足一定条件时停止）</p><p>对于第二种情况，在全局注册的，也就是使用<code>Vue.component()</code>创建的组件，互相引用完全不会造成什么影响。但是在单文件模板的<code>.vue</code>文件中，由于使用<code>webpack</code>构建，会造成组件互相依赖从而无法打包的情况。此时我们可以将其中一个组件作为异步组件加载，从而避免这种错误。</p><h3 id="事件侦听相关"><a href="#事件侦听相关" class="headerlink" title="事件侦听相关"></a>事件侦听相关</h3><p>通常来说，我们在子组件中使用<code>$emit</code>来传播出事件触发，再在父组件中通过<code>v-on</code>指令来接受触发信号。</p><p>但在有的时候，我们也会想在同一实例上监听事件的触发，主要有以下两种情况：</p><ul><li>我们需要在实例的某些事件触发时，进行一些工作，例如销毁一些数据和对象实例等等。</li><li>我们需要将实例作为一个桥梁，在实例的子组件中触发实例的事件，从而将消息通过实例传递到其他子组件中</li></ul><p><code>Vue</code>提供了四个与事件触发有关的实例方法。如下：</p><ul><li><code>$emit</code> 用于在当前实例上触发事件</li></ul><ul><li><code>$on</code> 用于监听当前实例上的自定义事件。可以监听<code>$emit</code>触发的事件。</li><li><code>$off</code> 用于移除当前实例上的事件监听器，如果不传入事件名的话，会移除所有事件监听。</li><li><code>$once</code> 用于监听当前实例上的自定义事件，但是只监听一次，在触发一次后就会移除监听。</li></ul><h3 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h3><p>在本系列的开头几篇博客中，我们详细介绍过<code>vue</code>组件的生命周期。<code>vue</code>也提供了几个关于实例生命周期的实例方法，用于我们手动的来控制实例的生命周期。</p><ul><li><code>$mount</code> 如果<code>vue</code>实例在实例化的时候，没有声明<code>el</code>挂载点，那么实例就处于<strong><em>未挂载</em></strong>状态。对于未挂载状态的实例，我们可以使用<code>$mount</code>来手动的将它挂载在<code>DOM</code>元素上。它接受一个<code>DOM</code>元素选项作为参数，返回实例自身。</li><li><code>$forceUpdate</code> 强制当前实例重新渲染，通常用于手动强制更新组件。</li><li><code>$nextTick</code> 接受一个回调函数作为参数，在<code>DOM</code>更新后立即运行此回调函数。通常在修改实例数据后调用来进行数据更新到视图后的后续操作。</li><li><code>$destory</code> 销毁实例，会移除实例与其他实例的所有连接并解除全部事件监听。当然，也会触发<code>beforeDestory</code>和<code>destoryed</code>生命周期函数。</li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之Async/Await</title>
      <link href="/2018/05/20/ES6%E4%B9%8BAsyncAwait/"/>
      <url>/2018/05/20/ES6%E4%B9%8BAsyncAwait/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在前面的两篇博客中，我们介绍了<strong><em>ES6</em></strong> 的 <code>promise</code> 和 <code>generator</code>，它们都是用来解决 <strong><em>js</em></strong>中的异步操作问题的。本篇博客的主角，<code>async</code>函数，同样是用于解决异步回调问题，它甚至被称为异步操作的终极解决方案。使用它，我们可以像处理简单的同步操作一样来处理一些异步操作，彻底告别回调函数方式的回调地狱问题，<code>promise</code>方法绵长的<code>then</code>调用问题，<code>generator</code>函数需要引入 <strong><em>co</em></strong> 库等这些异步处理方案中恼人的不完美之处。</p><p>准确的来说，<code>async</code>函数其实是 <strong><em>ES7</em></strong> 中的新语言特性，但<strong><em>babel</em></strong>已经完全提供了它的转码，所以在可以使用 <strong><em>ES6</em></strong>的地方，我们都可以大胆的使用 <code>async</code>函数。</p><p>为了图个方便，就将此篇博客无伤大雅的放在 <strong><em>ES6</em></strong> 系列中，所以特此说明。</p><p>好了，下面就来具体介绍以下我们今天的主角吧。</p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>async</code>函数，其实是将<code>promise</code>和<code>generator</code>函数结合在一起，从而将异步处理步骤大大简化的一种函数。</p><p>首先，我们来复习一下系列博客的前两篇中介绍的<code>generator</code>和<code>promise</code>。</p><p><code>generator</code>函数，通过为函数定义添加 <strong>*</strong> 号来声明，通过<code>yield</code>关键字，得到异步结果，并在我们使用<code>next</code>执行器时，将异步结果传递给我们。它的缺点在于，我们必须在异步处理完成时，调用<code>next</code>执行器来进行结果传递，这意味着，我们必须对一些异步 <strong><em>API</em></strong>进行二次包装，增加了异步处理的复杂性。虽然 <strong><em>co</em></strong>库为我们提供了类似自动执行器的功能，但要求异步操作必须返回一个<code>thunk</code>函数或<code>promise</code>，在实际使用中仍然是比较麻烦的。具体见<a href="https://gyufei.github.io/2018/05/12/ES6%E4%B9%8BGenerator/" target="_blank" rel="noopener">ES6之generator</a></p><p><code>promise</code>，将回调函数规范化，通过 <code>resolve</code>传递异步操作结果，通过<code>reject</code>传递异步操作异常，通过<code>then</code>的链式调用，来将异步操作序列化。但在一些复杂的异步操作时，<code>new Promise(function(resolve,reject){...})</code>，这种冗长的写法，以及大串的<code>then</code>调用，也会使代码混乱和难以维护。具体见<a href="https://gyufei.github.io/2018/04/20/ES6%E4%B9%8BPromise/" target="_blank" rel="noopener">ES6之promise</a></p><p>而<code>async</code>函数，作为<code>generator</code>函数的语法糖，将<code>generator</code>的 <code>yield</code>机制，通过包装为<code>promise</code>实现自动执行，从而避免了我们手动使用<code>next</code>执行器或者使用一些类似<strong><em>co</em></strong>库这种自动执行器的麻烦。</p><h4 id="Async"><a href="#Async" class="headerlink" title="Async"></a><strong><em>Async</em></strong></h4><p>首先来看一下<code>async</code>函数的基本语法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过在函数声明前加上 async，来声明函数是一个async函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>（）</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'this is a async func'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的在函数前加上<code>async</code>关键字，就声明了函数 <code>foo</code> 为一个异步的 <code>async</code>函数。我们可以像调用一个普通函数一样调用它。</p><p>但特别之处在于，这个函数并不会像普通函数一样简单的返回我们<code>return</code>的值，它总是将我们在函数中<code>return</code>的值转化为一个<code>promise</code>对象返回。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo())</span><br><span class="line"><span class="comment">//Promise&#123;&lt;resolved&gt;: "this is a async func"&#125;</span></span><br><span class="line"></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//this is a async func</span></span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以清楚的看出<code>async</code>函数总是返回一个<code>promise</code>对象。还记得我们在<code>promise</code>中提到的<code>resolve</code>实例方法吗？<code>async</code>就是使用它，来将我们在函数内部声明的返回值包装为<code>promise</code>对象的。</p><p>当然，如果我们不在<code>async</code>函数中显式返回任何值，那么它就会返回 <code>Promise.resove(undefined)</code>。</p><h4 id="Await"><a href="#Await" class="headerlink" title="Await"></a><strong><em>Await</em></strong></h4><p><code>async</code>函数当然不仅仅只是返回一个<code>promise</code>对象这么简单，通过<code>Await</code>关键字，才能真正体现出<code>async</code>无阻塞，以同步方式来书写异步代码的魔力所在。</p><p><code>await</code>关键字，用在<code>async</code>函数中，从名字也可以看出，它用于等待一个异步操作的完成并得到异步操作的结果。类似<code>yield</code>关键字只能用在<code>generator</code>函数中，<code>await</code>也只能用在<code>async</code>中。</p><p><code>await</code>关键字，会等待跟随在它后面的表达式完成，取得表达式的值。如果它后面跟随的表达式返回一个<code>promise</code>对象，它就会执行这个<code>promise</code>对象的<code>then</code>方法，得到<code>promise</code>的<code>resolved</code>值。</p><p>通过代码来看一下它的具体作用：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们定义一个返回promise对象的异步函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(<span class="number">100</span>)</span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> val = time()</span><br><span class="line">    <span class="keyword">return</span> val+<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别忘了我们上面提到的，async永远返回一个promise对象</span></span><br><span class="line">bar()</span><br><span class="line"><span class="comment">//Promise &#123; &lt;state&gt;: "pending" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3秒后我们得到异步的结果值</span></span><br><span class="line">bar.then(<span class="function"><span class="params">res</span>=&gt;</span>res)</span><br><span class="line"><span class="comment">//200</span></span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看出，<code>await</code>关键字，将其后跟随的表达式进行解析，如果是<code>promise</code>对象，就会等待<code>promise</code>对象转换为<code>fullfilled</code>状态，得到其<code>resolve</code>出来的值。</p><p><code>await</code>简洁直接的解决了我们调用异步操作并得到异步操作结果这个过程的麻烦，在遇到异步操作的处理时，我们只需要简单的在其前面加上<code>await</code>，它会去执行这个异步操作，等待着得到异步的结果，从而让我们的代码逻辑清晰，再也不需要那一长条的<code>then</code>链了。</p><p>另外，<code>await</code>后面如果跟随的是一个同步操作，它也会直接返回这个同步操作的结果值，跟不加<code>await</code>是一样的。这也解决了我们使用<code>generator</code>时，<code>yield</code>必须返回一个<code>thunk</code>函数或<code>promise</code>对象才能被<strong><em>co</em></strong>库自动执行的问题。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>async/await</code>，已经算是比较完美的异步处理方案了。但它仍然有美中不足的地方，那就是异常处理。</p><p>我们知道，<code>promise</code>会有两种状态，<code>fullfilled</code>和<code>rejected</code>，当异步操作发生错误时，<code>promise</code>会进入<code>rejected</code>状态，传递出错误。但是在<code>async</code>函数中，<code>await</code>只会去自动获取其得到的<code>promise</code>的<code>resolve</code>值，并不关心<code>reject</code>值。这也就意味着，我们必须自己去处理异步操作返回<code>promise</code>的<code>rejected</code>状态。</p><p>首先，第一种方法，直接了当，我们在<code>await</code>后面的<code>promise</code>对象上直接处理<code>reject</code>。代码形如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> fetch(<span class="string">'a'</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">await</span> fetch(<span class="string">'b'</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err)&#125;)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面这种方法，在<code>async</code>包装了很多异步操作时，有很多<code>await</code>时，需要为每个<code>await</code>后面的异步操作都加上<code>catch</code> ，显得臃肿和累赘，非常不优雅。</p><p>第二种方法，就是使用<code>try/catch</code>，将多个异步操作的<code>await</code>都放在<code>try</code>块中，并在<code>catch</code>块中统一处理。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> fetch(<span class="string">'a'</span>)</span><br><span class="line">        <span class="keyword">let</span> b = <span class="keyword">await</span> fetch(<span class="string">'b'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法，算是在实际应用中使用的较多的一种方法，它能够方便的同时处理同步和异步错误。但是在异步操作逻辑比较复杂时，也并不是那么的优雅，会一定程度增加代码的可读性和复杂度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于<code>await/async</code>函数的介绍，就到这里。其实如果仔细的了解了<code>generator</code>函数和<code>promise</code>，<code>async</code>函数是非常容易理解的，也可以很直观的体会到它相比于其他两者的简洁优雅。作为 <strong><em>JavaScript</em></strong> 近年来推出的最革命性的特性之一，相信在后面的前端领域发展中，它也会发挥越来越重要的作用。</p><p>好啦，这篇博客就到这里。谢谢阅读，鞠躬退场^O^。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之Generator</title>
      <link href="/2018/05/12/ES6%E4%B9%8BGenerator/"/>
      <url>/2018/05/12/ES6%E4%B9%8BGenerator/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在 ES6 中，对于异步问题的处理其实笼统的来说提供了三种解决方案，分别是<code>Promise</code>，<code>Generator</code>，<code>async/await</code> 。但这三种方案并不是各自独立，而是互相关联，互相依赖的。它们也都有各自的一些应用场景和优缺点。</p><p>这篇博客就主要来介绍一下<code>Generator</code>。</p><p>OK，Let’s begin。</p></blockquote><a id="more"></a><h3 id="Generator-概述"><a href="#Generator-概述" class="headerlink" title="Generator 概述"></a><strong><em>Generator</em></strong> 概述</h3><p>首先，<code>Generator</code>是ES6中新推出的一种函数的叫法，它是一种全新的函数类型。</p><p>它与<code>JS</code>中其他函数的主要区别在于，它是一种可以在运行时暂停的函数。一般来说，在<code>JS</code>中，当一个函数运行起来时，我们是无法中断它的，归因于<code>JS</code>的单线程和事件循环机制，我们在以前是没法做到将一个正在运行的函数暂停去做一些其他事情，然后在需要时回来继续运行这个函数的。</p><p>而<code>Generator</code>函数，正是为我们提供了这样一个实现，让我们可以在函数代码执行过程中，一次或多次暂停，并在将来的某个时刻继续执行。我们来仔细思考一下，对于普通的函数来说，我们在调用函数时向函数传入参数，并等待函数执行完毕为我们<code>return</code>一个最终值。那么对于<code>Generator</code>函数来说，我们在每次暂停时，都可以返回一个值，然后在启动时，再传入一个值。嗯，听起来还蛮振奋人心的函数内外部双向通信，用来处理异步问题，实在是再合适不过了啊。</p><h4 id="generator-函数语法"><a href="#generator-函数语法" class="headerlink" title="generator 函数语法"></a><strong><em>generator</em></strong> 函数语法</h4><p>首先，我们来看一下<code>generator</code>函数是如何书写的。</p><p><code>generator</code>函数的声明语法跟普通函数的声明语法大致相同，不同的是，它多一个<code>*</code>号。如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以下两种generator函数声明都是合法的，但推荐使用第一种，比较明了*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>*</code>号，就是用来标示函数是一个<code>generator</code>函数的。</p><p>如果接触过<code>python</code>的话，会发现<code>ES6</code>的<code>generator</code>函数和<code>python</code>的生成器函数十分相似，都是通过 <code>yield</code> 来在函数内部暂停函数的执行，并传递值到函数外去，再通过<code>next()</code>传递值给<code>yield</code>表达式，并继续函数的执行。（只是顺便一提，没了解过<code>python</code>的同学可以当做没看见。。</p><p>我们先来看一个简单的 generator 函数的例子，通过这个简单的例子来对<code>generator</code>函数做一个直观的认识。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">first</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = first()</span><br><span class="line"></span><br><span class="line">f</span><br><span class="line"><span class="comment">//Generator</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">//&#123;value: 3, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>通过上面的函数，我们可以看到，我们定义的<code>generator</code>函数有以下几个特别的地方：</p><ul><li><code>first()</code>并不会执行<code>first</code>函数，也不会返回函数运行结果，而是返回一个指向函数内部状态的指针对象，也就是一个<code>Generator</code>对象。</li><li>当我们执行调用<code>generator</code>函数返回的对象的<code>next()</code>方法后，函数才开始执行，执行到<code>yield</code>关键字时暂停，并返回一个对象，这个对象的<code>value</code>值为<code>yield</code>传递出的值，<code>done</code>属性是函数的状态，当函数执行完毕时，它会从<code>false</code>置为<code>true</code>。</li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong><em>yield</em></strong></h4><p>大家<code>generator</code>函数的关键语句——<code>yield</code>。我们就来具体解释一下 <code>yield</code>。</p><p><code>yield</code>的汉语意思就是产出，从上面的例子中也很好理解，就是产出一个形如<code>{value: xxx, done:boolean}</code>的对象。</p><p>在<code>generator</code>函数运行过程中，当遇到<code>yield</code>语句时，就会暂停函数，并将<code>yield</code>后的值作为<code>next()</code>所返回对象的<code>value</code>值。如果<code>yield</code>表达式不返回值的话，<code>value</code>就为<code>undefined</code>。</p><p>再次调用<code>next()</code>方法，函数继续从上次暂停的地方执行，直到再次遇到<code>yield</code>，以此类推。</p><p>如果从上次暂停的位置后面没有<code>yield</code>，函数就会一直执行下去，直到函数结束将<code>next</code>返回对象的<code>done</code>值置为<code>true</code>。</p><p>值得注意的是，如果函数有<code>return</code>语句的话，<code>return</code>语句的返回值会作为<code>next()</code>调用返回对象的最后一个<code>value</code>，并结束函数，后续的<code>next</code>调用，会一直返回<code>undefined</code>。</p><p>关于<code>yield</code>，还有以下两点需要注意：</p><ul><li><p><code>yield</code>只能用在<code>generator</code>函数中，不能用在普通函数中，因此它也不能用在那些以函数作为参数的方法中，例如<code>forEach</code>，<code>map</code>等方法。</p></li><li><p><code>yield</code> 如果用在表达式中参加运算，必须加括号。形如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">second</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="双向通信"><a href="#双向通信" class="headerlink" title="双向通信"></a>双向通信</h4><p>在上面我们提到了，<code>yield</code>表达式可以暂停<code>generator</code>函数的运行，并将其后的值传递出去。那么我们如何向<code>yield</code>表达式传递值呢？也就是说，<code>generator</code>函数是如何实现函数内外部的双向通信的呢？</p><p>看下面例子：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="number">200</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x: '</span>+ x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先，我们调用generator函数得到返回的generator对象。</span></span><br><span class="line"><span class="keyword">let</span> b = foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们调用next方法，执行函数。注意此时函数开始运行，首先对 x 赋值，从右到左，遇到了yield，暂停函数执行，返回 200</span></span><br><span class="line">b.next()</span><br><span class="line"><span class="comment">//&#123;value: 200, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继续调用next()方法，函数从上次暂停的yield处继续开始，我们为next方法传递了一个参数1</span></span><br><span class="line">b.next(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//'x: 2'</span></span><br><span class="line"><span class="comment">//&#123;value: undefine, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>从上面代码我们可以看到，<strong><em>x</em></strong>的值在函数结束时为2。</p><p>通过以上代码我们就可以清楚的知道<code>generator</code>函数如何实现双向通信了。</p><ul><li>遇到<code>yield</code>表达式时，暂停函数，并将其后的值传递出去</li><li>在下一个<code>next</code>调用时，从暂停的<code>yield</code>处继续运行，并将<code>next</code>携带的参数作为此处<code>yield</code>表达式的最终计算结果值。</li><li>如果 <code>next()</code>没有传递参数给<code>yield</code>表达式的话，默认<code>yield</code>表达式返回值为<code>undefined</code>。</li></ul><p>形象的来说，<code>yield</code>就像是在管道一样的函数上开了一个口子，在运行到它所在位置时，从这个口子会冒出一个东西，我们把冒出的东西拿到后，还可以通过这个口子，再往里面塞进去一个东西。而<code>next</code>，就是用来使我们能够合乎规则和秩序的取到口子传递出的东西再塞东西进去。</p><p>看明白上面的例子后，我们再通过下面这个复杂一些的例子，更详细的加深一下理解。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">let</span> h = x + y + z</span><br><span class="line">    <span class="built_in">console</span>.log(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先，我们向函数传递一个参数 5</span></span><br><span class="line"><span class="keyword">let</span> b = bar(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用next方法。在这个next方法我们只是用来启动函数，到达第一个yield位置，传递出x+1的值，暂停</span></span><br><span class="line"><span class="comment">//这个next我们不需要传递任何参数，因为此时并没有处于暂停状态的yield表达式来接受我们传递的值。</span></span><br><span class="line">b.next()</span><br><span class="line"><span class="comment">//&#123;value: 6, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继续调用next，此时函数在第一个yield暂停的位置继续运行，计算 y 的值。</span></span><br><span class="line"><span class="comment">//我们通过 next 传递进去一个值，将这个值作为 yield 表达式的计算结果值，求得y值为 48</span></span><br><span class="line"><span class="comment">//求得y 值之后，到函数下一行，计算 z 的值</span></span><br><span class="line"><span class="comment">//此时我们又遇到了yield，并将 y/3 的值传递出去,函数暂停，</span></span><br><span class="line">b.next(<span class="number">24</span>)</span><br><span class="line"><span class="comment">//&#123;value: 16,done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继续调用next，此时函数在第二个yield暂停的位置继续往下运行，计算 z 的值。</span></span><br><span class="line"><span class="comment">//同上，我们传递一个值作为yield表达式的结果，得到 z 值为 1。</span></span><br><span class="line"><span class="comment">//函数继续运行，直到结束，没有再遇到yield和return传递值，因此返回对象value为undefined</span></span><br><span class="line"><span class="comment">//并最终输出 h 值为 5 + 58 + 1 ，即54</span></span><br><span class="line">b.next(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//&#123;value: undefined，done:false&#125;</span></span><br></pre></td></tr></table></figure><p>上面这个例子对于初次接触<code>generator</code>的同学可能有些难以理解，多看几次^O^.</p><h4 id="异常捕捉"><a href="#异常捕捉" class="headerlink" title="异常捕捉"></a>异常捕捉</h4><p>我们可以通过<code>next()</code>方法向<code>generator</code>函数内传递数据，那么当然，像<code>promise</code>对象的数据和错误处理配套的一样，我们也可以向<code>generator</code>中传递异常。</p><p>来看代码：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">200</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'generator 内部捕获异常：'</span> + err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = gen()</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动generator函数</span></span><br><span class="line">f.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用generator对象的throw方法，向函数内部传递异常（注意区分此方法和全局throw方法，不是一个哦</span></span><br><span class="line">f.throw(<span class="string">'aError'</span>)</span><br><span class="line"><span class="comment">//generator 内部捕获异常：aError</span></span><br></pre></td></tr></table></figure><p>当然，在实际使用中，我们最好应该向<code>throw</code>中传递一个<code>Error</code>对象的实例。此处传递一个字符串的行为不可取，只是为了方便演示。</p><p><code>generator</code>对象的<code>throw</code>方法只能在<code>generator</code>函数启动后才能传递错误进去，很好理解，我们当然必须首先使用一次<code>next</code>方法启动函数才能抛出异常啊。抛出的异常如果在内部未被捕获，就会扩散到<code>throw</code>调用的位置，还没被捕获的话，程序就会被异常终止。</p><h4 id="generator对象的return方法"><a href="#generator对象的return方法" class="headerlink" title="generator对象的return方法"></a><strong><em>generator</em></strong>对象的<em>return</em>方法</h4><p><code>generator</code>对象，除了我们上面提到的<code>next</code>和<code>throw</code>两个方法外，还有一个<code>return</code>方法。它的作用是向<code>generator</code>函数内部传递一个值，并结束<code>generator</code>函数的运行。</p><p>如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动函数</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向generator内部传递一个值100，并结束函数</span></span><br><span class="line">g.return(<span class="number">100</span>)</span><br><span class="line"><span class="comment">//&#123;value: 100, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出函数已经结束了</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>我们在上面提到，<code>generator</code>函数内部的<code>return</code>会将函数结束，并将<code>return</code>作为最后一个非<code>undefined</code>的<code>value</code>返回值。<code>generator</code>对象的<code>return</code>方法，作用跟函数内部的<code>return</code>是一样的。</p><p>现在我们可以来总结一下<code>next</code>，<code>throw</code>，<code>return</code>这三个方法：</p><ul><li>这三个方法都是用于在<code>generator</code>函数从 上个暂停的<code>yield</code>处启动时，向<code>yield</code>表达式传递值作为其表达式结果的方法。</li><li><code>next</code>方法传递一个普通值作为<code>yield</code>表达式的结果，相当于将<code>yield</code>表达式替换为一个普通值</li><li><code>throw</code>方法传递一个抛出的错误作为<code>yield</code>表达式的结果，相当于将<code>yield</code>表达式替换为一个<code>throw</code>语句</li><li><code>return</code>方法同样传递一个普通值作为<code>yield</code>表达式的结果，但它会结束函数的运行，相当于将<code>yield</code>表达式替换为一个<code>return</code>语句。</li></ul><h3 id="使用generator函数解决异步问题"><a href="#使用generator函数解决异步问题" class="headerlink" title="使用generator函数解决异步问题"></a>使用<em>generator</em>函数解决异步问题</h3><p>上面讲了一大堆关于<code>generator</code>函数的特性和方法，但大家对于它具体怎么应用在一些异步操作中还是有些疑惑。</p><p>首先我们来思考一下，异步问题，归根结底就是有的操作，需要耗费比较长的时间，我们又不想在这些操作进行的时候一直等着它返回结果。我们想要的理想状态是，当这些操作进行时，我们可以先做一点别的事情，等操作完成了，我们再去得到结果就行。</p><p><code>generator</code>函数就正好符合我们的要求。我们可以将异步操作包装在<code>generator</code>函数中，当异步操作进行时，函数暂停，我们可以去做其他的一些事情。当我们需要获得异步操作结果时，再使用<code>next</code>方法，取到结果并进行处理。这样看来，<code>generator</code>函数很适合来进行异步操作。</p><p>我们看下面的代码：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们有一个耗时的操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">22</span></span><br><span class="line">        g.next(a)</span><br><span class="line">    &#125;，<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过generator函数来获取来处理这个异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> longTime()</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得generator对象</span></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行generator函数，yield会去执行longTime这个异步操作，并暂停generator函数</span></span><br><span class="line"><span class="comment">//在上面的异步操作中，我们在得到异步操作的结果后，通过在异步操作中调用next方法，将结果再交给generator函数</span></span><br><span class="line">g.next()</span><br></pre></td></tr></table></figure><p>可以看出，通过<code>generator</code>函数来进行异步处理，其实就是构造一个<code>generator</code>函数，使用<code>yield</code>来启动异步操作，并在异步操作中将结果再通过<code>next()</code>方法传递回<code>generator</code>函数，从而完成异步操作。</p><p>很多异步操作都是通过回调函数来传递操作结果的，那我们如果想使用<code>generator</code>函数来对他们进行处理，就必须在他们的回调函数里使用<code>next</code>方法，拿最常见的<code>Ajax</code>举例。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funciton req（）&#123;</span><br><span class="line">    $.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> req()</span><br><span class="line">    doSomeThing(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>（<span class="title">x</span>）</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那大家就可能有这样一个问题了，我为什么不直接在<code>Ajax</code>的回调函数里对结果进行处理，还要费那么大麻烦把结果传递回<code>generator</code>函数里干嘛。</p><p>额，单纯这样用<code>generator</code>函数是没什么用，在多个异步操作时，我们要在每个异步操作的回调里使用next传递结果，到处的回调里都是<code>next</code>，显得十分愚蠢。</p><p>于是就有了这样的一个解决方案，我们通过<code>Thunk</code>函数，将形如<code>$.get(url, callback)</code>类型的异步请求形式，转换为 <code>aGet(url)(callback)</code>形式的调用，这样，我们就可以在每次 <code>next</code>的返回值的<code>value</code>中自定义回调函数，从而简化代码。如下：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先通过thunk函数，将 $.get(url,cb) 转换为 aGet(url)(cb)的调用形式</span></span><br><span class="line"><span class="keyword">let</span> aGet = thunk($.get)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> aGet(<span class="string">'urlA'</span>)</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> aGet(<span class="string">'urlB'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们通过上面thunk的转换，使得next每次返回的对象value值可以直接接受一个回调函数作为参数，从而使我们更方便的在回调函数里使用next()来传递异步操作结果</span></span><br><span class="line">g.next().value(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data).value(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种方式第一是写起来比较麻烦，难以理解，不够清晰明了。第二就是需要引入额外的<code>thunk</code>相关库来对各种有回调函数的异步<code>API</code>进行包装，增加了使用成本。</p><p>对于那些不使用回调函数，而是返回<code>promise</code>对象的异步<code>API</code>，使用<code>generator</code>函数来进行处理其实是一样的步骤，只不过将回调函数中的<code>next</code>调用换到了<code>then</code>中。</p><p>当然，<code>generator</code>函数有一些相关的库，例如<code>co</code>库，可以用来降低我们在回调函数和<code>then</code>中使用<code>next</code>来进行异步操作结果传递的麻烦程度，但同样的，也会增加我们的使用成本，降低多人协作开发中的容错率。引入相关的类库来改变项目中的所有异步操作处理步骤，可能对于一些大型项目来说，是需要慎重考虑的事情。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相比于<code>promise</code>的原生支持和简明的用法，<code>generator</code>函数略显鸡肋，在<code>ES7</code>推出的<code>async/await</code>这个终极异步操作处理方案面前，<code>generator</code>函数就更有些尴尬了。</p><p>如果希望了解更多关于<code>generator</code>函数的知识，仍旧推荐阅读阮一峰老师的<code>ES6入门</code>，关于<code>generator</code>函数的一些细节和异步操作处理的更多应用，都介绍的比较详细。<a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">赠送飞机票一张</a></p><p>好了，对于<code>generator</code>函数的介绍，就到这里了。谢谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十四）：vue-cli的脚手架结构</title>
      <link href="/2018/05/09/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/"/>
      <url>/2018/05/09/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E5%9B%9B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>作为<code>Vue</code>官方发布的项目脚手架，<strong><em>vue-cli</em></strong> 提供了比较完善的项目构建结构，能够帮助我们快速的完成项目的创建和基本配置。</p><p>这篇博客主要来介绍<code>vue-cli</code>提供的项目脚手架中，一些配置文件的具体作用，通过对这些配置文件作用的讲解，我们能够清楚的知道项目脚手架的具体构成和实现方式，从而能够更好的解决开发中遇到的一些问题。</p><p>当然本文会主要涉及<code>webpack</code>方面的脚手架配置，对于<code>vue-router</code>等与<code>vue</code>关联比较密切，与项目耦合较深的脚手架配置，因为篇幅有限，不会过多介绍。</p></blockquote><a id="more"></a><p>首先我们先来简单的介绍一下<code>vue-cli</code> 。作为<code>vue</code>项目的常用构建工具，它依赖于<code>node</code>环境，能够提供给我们一个完整的项目配置，提供了本地开发，热加载，测试和打包发布等功能，能够使我们快速的搭建开发环境，进行项目开发。</p><p><code>vue-cli</code> 使用<code>webpack</code>作为项目的构建工具，且已集成<code>webpack</code>，所以我们只需要使用以下命令就可以简单的完成<code>vue-cli</code>的安装。</p><figure class="highlight shell"><figcaption><span>SHELL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>在安装完成之后，我们就可以使用<code>vue init webpack projectname</code> 来快速的初始化一个<code>vue</code>项目。在项目的初始化搭建过程中，它会询问一些关于你的项目的一些自定义信息，例如项目名称，项目描述等等，很简单，只要一步一步跟着提示做下去，很快就可以完成。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在项目初始化完成后，进入项目目录下，我们会看到这样一个目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── node_module</span><br><span class="line">├── build</span><br><span class="line">│  ├── check-versions.js</span><br><span class="line">│  ├── build.js</span><br><span class="line">│  ├── utils.js</span><br><span class="line">│  ├── vue-loader.conf.js</span><br><span class="line">│  ├── webpack.base.conf.js</span><br><span class="line">│  ├── webpack.dev.conf.js</span><br><span class="line">│  └── webpack.prod.conf.js</span><br><span class="line">├── config</span><br><span class="line">│  ├── dev.env.js</span><br><span class="line">│  ├── index.js</span><br><span class="line">│  └── prod.env.js</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│  ├── App.vue</span><br><span class="line">│  ├── assets</span><br><span class="line">│  │  └── logo.png</span><br><span class="line">│  ├── components</span><br><span class="line">│  │  └── Hello.vue</span><br><span class="line">│  └── main.js</span><br><span class="line">└── static</span><br></pre></td></tr></table></figure><p>我大概对这些文件做一个简单介绍。</p><p><strong><em>node_module</em></strong>文件夹，我们通过<strong><em>npm</em></strong>安装的项目依赖模块，插件等都存储在此文件夹中。</p><p><strong><em>src</em></strong>文件夹，就是我们进行项目开发的地方，跟项目自身有关的东西基本都在这里面了。它主要包含以下几个部分：</p><ul><li><strong><em>assets</em></strong> 用来放置图片等的文件夹，主要放置例如 <strong><em>logo</em></strong>图片，通用的js和css文件以及字体等等。</li><li><strong><em>components</em></strong> 组件文件夹，用来放置项目中的组件，可以根据项目具体情况来决定是否使用。</li><li><strong><em>App.vue</em></strong> <code>Vue</code>项目的入口文件，作为<code>vue</code>组件树的主入口。</li><li><strong><em>main.js</em></strong> <code>webpack</code>的主入口，是项目编译打包的核心文件，我们在这里初始化Vue实例。</li></ul><p><strong><em>static</em></strong> 文件夹，主要用来存放一些静态资源，也就是我们不想被编译打包的文件，例如某些图片，字体，插件等等。</p><p><strong><em>index.html</em></strong> 项目首页的入口文件，项目经过打包后的模块都会被引入到此文件中。我们可以在这里面添加项目的一些<code>meta</code>信息或统计代码。</p><p><strong><em>package.json</em></strong> 项目的配置文件，包括项目的相关信息，依赖模块信息，脚本命令信息等。</p><p><strong><em>README.md</em></strong> 项目的<code>markdown</code>格式说明文档。</p><p>跟项目的开发环境配置和编译打包配置有关的文件，集中在 <strong><em>build</em></strong> 文件夹和<strong><em>config</em></strong>文件夹下。这两个文件夹，也是我们今天要介绍的主角。</p><p>我会逐个介绍这两个文件夹下每个文件的具体作用，从而让大家明白，它们是通过怎样的配合来完成一个项目的构建和开发环境配置的。</p><h3 id="config文件夹"><a href="#config文件夹" class="headerlink" title="config文件夹"></a><strong><em>config</em></strong>文件夹</h3><p>首先我们来介绍项目的环境配置文件夹。此文件夹下的配置文件主要是用来配置 devServer 和 开发及生产环境下 <strong><em>NODE_ENV</em></strong> 不同时对应的一些配置。</p><p>此文件夹下有三个文件，我们通过注释代码来说明他们的作用。</p><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><strong><em>index.js</em></strong></h4><p>根配置文件 <strong><em>index.js</em></strong>，它设置了 <strong><em>dev</em></strong> 和 <strong><em>prod</em></strong> 环境的各自一些配置项，然后导出供其他项目构建文件使用。这个文件里面本来就有比较详细的英文注释，大家可以对照我的注释来加深理解。</p><p>文件内容具体如下：</p><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入node中常见的path模块，主要用于处理文件和目录路径。</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//开发环境development下的相关配置</span></span><br><span class="line">  dev: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路径配置</span></span><br><span class="line">    <span class="comment">//打包后静态文件根目录中的静态资源子目录,用于存放js，css，image，font等项目资源。</span></span><br><span class="line">    <span class="comment">//例如我们打包项目一般会生成dist文件夹来存放打包后文件，我们项目中的静态资源就会位于dist/static文件夹中。</span></span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    <span class="comment">// 资源引用目录</span></span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">    <span class="comment">//代理表，主要用于解决项目开发模式时的跨域问题。</span></span><br><span class="line">    <span class="comment">//它使用的是vue-cli自带的http-proxy-middleware插件</span></span><br><span class="line">    proxyTable: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发时的本地服务器设置</span></span><br><span class="line">    <span class="comment">//本地服务器IP，可以通过 process.env.HOST 来重写</span></span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="comment">//本地服务器端口，可以通过 process.env.PORT 来重写</span></span><br><span class="line">    port: <span class="number">8080</span>, </span><br><span class="line">    <span class="comment">//是否自动打开浏览器</span></span><br><span class="line">    autoOpenBrowser: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//是否将错误进行网页全屏覆盖展示</span></span><br><span class="line">    errorOverlay: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//是否开启更优雅的错误提示</span></span><br><span class="line">    notifyOnErrors: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//使用文件系统来获取文件改动通知</span></span><br><span class="line">    poll: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否使用代码检查插件</span></span><br><span class="line">    useEslint: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//是否将代码检查检查出的错误也作为全屏错误显示</span></span><br><span class="line">    showEslintErrorsInOverlay: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map文件的生成模式，</span></span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">    <span class="comment">//是否在开发时进行文件缓存失效处理</span></span><br><span class="line">    cacheBusting: <span class="literal">true</span>,</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//是否生成css的map文件，map文件主要用于对应文件压缩前后的位置，便于调试</span></span><br><span class="line">    cssSourceMap: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  build: &#123;</span><br><span class="line">    <span class="comment">// 模板文件 index.html 路径。path.resolve用于拼接路径，__dirname为当前目录路径</span></span><br><span class="line">    index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包后的静态文件的根目录，一般为dist</span></span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    <span class="comment">// 打包后静态文件中静态资源子目录</span></span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    <span class="comment">// 静态资源的引用路径</span></span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否生成map文件</span></span><br><span class="line">    productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// map文件生成模式</span></span><br><span class="line">    devtool: <span class="string">'#source-map'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否压缩文件</span></span><br><span class="line">    <span class="comment">// 如果要压缩，需要先命令行执行 npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">    productionGzip: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 要压缩的文件类型</span></span><br><span class="line">    productionGzipExtensions: [<span class="string">'js'</span>, <span class="string">'css'</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否开启编译完成后的报告，可设为true和false。默认为环境里的 npm_config_report 变量值</span></span><br><span class="line">    <span class="comment">// 设为ture时，可以通过 npm run build --report 来开启报告模式</span></span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们提到<code>proxyTable</code>配置项，它借助<code>http-proxy-middleware</code>插件，来建立一个虚拟api服务器，从而解决我们在开发模式下遇到的跨域问题。用法一般如下：</p><figure class="highlight js"><figcaption><span>proxyTable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">     <span class="comment">//当请求这个地址时进行代理从而避开跨域</span></span><br><span class="line">    <span class="string">'/users'</span>:&#123;</span><br><span class="line">        target: <span class="string">'http://api.someurl.com'</span>   <span class="comment">//要跨域请求的网站</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,                <span class="comment">//是否跨域</span></span><br><span class="line">        secure: <span class="literal">false</span>,  <span class="comment">// 如果是https接口，需要配置为true</span></span><br><span class="line">        pathRewrites：&#123;</span><br><span class="line">            <span class="comment">//在请求目标路径时将代理路径重写，例如此时请求'/users'，请求的真实接口为http://api.someurl.com/re</span></span><br><span class="line">            <span class="string">'^/users'</span>: <span class="string">'/re'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prod-env-js"><a href="#prod-env-js" class="headerlink" title="prod.env.js"></a><strong><em>prod.env.js</em></strong></h4><p><strong><em>production</em></strong> 环境的配置文件 <strong><em>prod.env.js</em></strong>，因为在 <strong><em>index.js</em></strong>中已经包含了大部分配置项，所以此文件的配置项非常简单，只是导出一个对象，<code>NODE_ENV</code> 为环境变量，指定 <strong><em>production</em></strong> 环境。</p><figure class="highlight js"><figcaption><span>prod.env.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"production"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dev-env-js"><a href="#dev-env-js" class="headerlink" title="dev.env.js"></a><strong><em>dev.env.js</em></strong></h4><p><strong><em>development</em></strong> 环境的配置 <strong><em>dev.env.js</em></strong> ,它合并了 <strong><em>production</em></strong> 的配置对象(覆盖相同配置项)。</p><figure class="highlight js"><figcaption><span>dev.env.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入webpack的merge插件，此插件用于对象的合并，会覆盖相同选项。主要用于配置文件的合并</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="comment">//引入prod.env.js配置文件</span></span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">'./prod.env'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并prod配置，并导出一个对象，其中 NODE_ENV 环境变量为 development</span></span><br><span class="line"><span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"development"'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="build-文件夹"><a href="#build-文件夹" class="headerlink" title="build 文件夹"></a><strong><em>build 文件夹</em></strong></h3><p><strong><em>build</em></strong> 文件夹下是项目构建中<code>webpack</code>相关配置文件的目录。</p><p>主要有以下几个文件</p><ul><li><strong><em>check-versions.js</em></strong> 主要用来检查<strong><em>node</em></strong>和<strong><em>npm</em></strong>版本</li><li><strong><em>utils.js</em></strong> 工具库文件，主要定义了配置文件中几个公用的函数</li><li><strong><em>webpack.base.conf.js</em></strong> <code>webpack</code>的基本配置</li><li><strong><em>webpack.prod.conf.js</em></strong> <code>webpack</code>在<strong><em>prod</em></strong> 模式下的配置文件</li><li><strong><em>webpack.dev.conf.js</em></strong> <code>webpack</code> 在 <strong><em>dev</em></strong> 模式下的配置文件</li><li><strong><em>vue-loader.conf.js</em></strong> <code>webpack</code>中关于 <code>.vue</code> 文件中<code>css</code>构建解析的配置</li><li><strong><em>build.js</em></strong> 项目构建入口，即<code>npm run build</code>的入口文件</li></ul><h4 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a><strong><em>webpack.base.conf.js</em></strong></h4><p>我们首先来看 <code>webpack</code>的基础配置文件 <strong><em>webpack.base.conf.js</em></strong></p><figure class="highlight js"><figcaption><span>webpack.base.conf.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">// 导入目录和路径模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 导入工具函数文件</span></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="comment">// 导入环境配置文件，即 config 文件夹下的 index.js 文件。</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">// 导入 vue-loader.conf 中关于 .vue 文件的 webpack配置</span></span><br><span class="line"><span class="keyword">const</span> vueLoaderConfig = <span class="built_in">require</span>(<span class="string">'./vue-loader.conf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数是用来返回当前目录的平行目录的路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'..'</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有关格式检查 eslint 的一些配置</span></span><br><span class="line"><span class="keyword">const</span> createLintingRule = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">//使用格式检查的文件类型</span></span><br><span class="line">  test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">  <span class="comment">//格式检查使用的loader</span></span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">  <span class="comment">//是否在编译前检测</span></span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  <span class="comment">// 要检查的目录，还可以通过 exclude 选项排除文件夹</span></span><br><span class="line">  include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">  <span class="comment">// 传递给eslint-loader的参数</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">//更友好的错误信息</span></span><br><span class="line">    formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>),</span><br><span class="line">    <span class="comment">//错误是否全屏显示在网页浮层上，使用config中index.js定义的配置值</span></span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//webpack发挥作用的基础目录，一般默认为当前目录</span></span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// webpack 应用程序的起点入口</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// webpack打包的出口目录</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包后文件的保存路径，在config文件夹中配置</span></span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    <span class="comment">// 打包后的文件名</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    <span class="comment">// 文件的真实引用路径，根据config中的配置确定</span></span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//webpack 模块解析的相关配置</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 如果引入文件以以下选项结尾，则进行解析，否则直接打包</span></span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    <span class="comment">// webpack引入模块或文件时路径中可使用的别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="comment">// 后面的$符号指精确匹配，</span></span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// webpack 对项目模块化的配置</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 如果在 config 中开启了格式检查eslint，就使用上面定义的函数生成有关eslint的webpack配置。</span></span><br><span class="line">      ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 对vue文件使用导入的 vue-loader.conf.js 中的配置，主要用于处理各种形式的css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="comment">// vue-loader 是 vue单文件组件的实现核心，专门用于解析.vue文件</span></span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// js文件的webpack配置</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 对js文件使用babel-loader解码，主要用来解析ES6语法等。</span></span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>), resolve(<span class="string">'node_modules/webpack-dev-server/client'</span>)]</span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//图片相关文件的webpack配置</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        <span class="comment">// 对图片相关的文件使用url-loader插件，在图片尺寸较小时，将其解析为base64的DataURL形式</span></span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 限制10000字节以下的图片转换为 DataURLURL形式</span></span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          <span class="comment">//转换后的图片文件名</span></span><br><span class="line">          name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//音频和视频文件的webpack配置，与图片配置类似</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">'media/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//字体文件的webpack配置，与图片类似</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">'fonts/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//自定义NODEJS环境</span></span><br><span class="line">  node: &#123;</span><br><span class="line">    <span class="comment">//阻止webpack引入一些Vue已内置或开发环境中不需要的node模块和功能</span></span><br><span class="line">    setImmediate: <span class="literal">false</span>,</span><br><span class="line">    dgram: <span class="string">'empty'</span>,</span><br><span class="line">    fs: <span class="string">'empty'</span>,</span><br><span class="line">    net: <span class="string">'empty'</span>,</span><br><span class="line">    tls: <span class="string">'empty'</span>,</span><br><span class="line">    child_process: <span class="string">'empty'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是<code>webpack</code>基本的配置，也就是不管在开发环境还是生产环境下通用的一些配置。对于特定生产环境下的特定配置，集中在 <strong><em>webpack.dev.conf.js</em></strong> 和 <strong>webpack.prod.conf.js</strong> 下。</p><p>在开发环境中，我们需要项目具有本地服务器，实时加载和热替换模块等能力。而在生产模式中，我们则需要更小的打包后尺寸，更轻量的项目体积。因此我们一般会将各自环境下所需的<code>webpack</code>配置都放在单独的文件中。</p><h4 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a><strong><em>webpack.prod.conf.js</em></strong></h4><p><strong><em>webpack.prod.conf.js</em></strong> 文件是生产环境下<code>webpack</code>的核心配置文件。</p><figure class="highlight js"><figcaption><span>webpack.prod.conf.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入nodejs目录路径模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">//引入 utils.js 工具配置文件，具体可查看本文下面对其的详细介绍</span></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="comment">//引入webpack，从而使用webpack的内置的一些插件</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="comment">//引入 config 文件夹下的 index.js 配置文件。具体查看本文上面对其的具体介绍。</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">//引入webpack的merage插件，来处理配置对象的合并。相同项将会被覆盖。</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="comment">//引入基础的webpack配置文件，具体看上面对其的介绍</span></span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>)</span><br><span class="line"><span class="comment">//引入webpack的copy插件，主要用于复制文件或文件夹到指定目录</span></span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入webpack的html插件，用于设置模板index.html，自动将打包后资源引入到html文件中。</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入webpack的extractText插件，用于将文本从bundle中提取到一个单独的文件中。主要用于处理css。</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入webpack的optimizeCSS插件，用来压缩css代码，同时去除重复代码，与上个插件配合使用来处理css模块</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入uglifyjs插件，对js进行压缩处理</span></span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入环境配置中的prod.env.js环境配置</span></span><br><span class="line"><span class="keyword">const</span> env = <span class="built_in">require</span>(<span class="string">'../config/prod.env'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将prod的webpack配置对象和基础的webpack配置对象合并</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用utils.js中的方法，生成各种css类型的配置。</span></span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      <span class="comment">//是否生成独立文件</span></span><br><span class="line">      extract: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">//项目是否使用postCSS</span></span><br><span class="line">      usePostCSS: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//根据config中的配置确定是否生成便于调试的sourcemap文件</span></span><br><span class="line">  devtool: config.build.productionSourceMap ? config.build.devtool : <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// config中的打包后文件路径配置</span></span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    <span class="comment">// 打包后的文件名，name为文件名，chunkhash是模块的hash值，用于浏览器缓存。</span></span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].[chunkhash].js'</span>),</span><br><span class="line">    <span class="comment">//非入口的chunk文件名，</span></span><br><span class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 利用webpack的DefinePlugin插件，定义process.env环境变量为env。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: env</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用 UglifyJSplugin来压缩js文件。</span></span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          <span class="comment">//禁止压缩时的警告信息</span></span><br><span class="line">          warnings: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//根据config中的文件配置来确定是否生成map文件。</span></span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      <span class="comment">//是否启用多线程压缩，速度更快。</span></span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//使用ExtractTextPlugin来将css抽离为单独的文件。</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      <span class="comment">//抽离后css单独的文件名</span></span><br><span class="line">      filename: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>),</span><br><span class="line">      allChunks: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用OptimizeCSSPlugin来将去除重复的css并压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSPlugin(&#123;</span><br><span class="line">      <span class="comment">//传入config中的设置来确定是否生成map文件</span></span><br><span class="line">      cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">        ? &#123; <span class="attr">safe</span>: <span class="literal">true</span>, <span class="attr">map</span>: &#123; <span class="attr">inline</span>: <span class="literal">false</span> &#125; &#125;</span><br><span class="line">        : &#123; <span class="attr">safe</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成用于打包后文件挂载的html页面</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">//根据config中的配置来确定html页面名</span></span><br><span class="line">      filename: config.build.index,</span><br><span class="line">      <span class="comment">//生成html页面使用的模板文件</span></span><br><span class="line">      template: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">//将js文件的引入放到html的body标签后面</span></span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        <span class="comment">//移除注释</span></span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//压缩空格</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//去除属性的引用</span></span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//在存在chunk时chunk的排序模式</span></span><br><span class="line">      chunksSortMode: <span class="string">'dependency'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//在文件未改变时保证文件id不变从而缓存文件</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    <span class="comment">// 在js文件中进行作用域提升，从而让代码文件更小，一般使用于ES6</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    <span class="comment">// 将打包后的文件中的第三方库文件抽取出来，便于浏览器缓存，提高运行速度。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// 将第三方库文件（主要是node_modules中的库)打包到vendor中</span></span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line">      minChunks (<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// any required modules inside node_modules are extracted to vendor</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">          /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">          <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">            path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">          ) === <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将webpack的runtime时的代码和模块提取到mainfest文件中，防止在代码被修改但未修改第三方库文件时第三方库仍然打包。 </span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'manifest'</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'app'</span>,</span><br><span class="line">      <span class="keyword">async</span>: <span class="string">'vendor-async'</span>,</span><br><span class="line">      children: <span class="literal">true</span>,</span><br><span class="line">      minChunks: <span class="number">3</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用复制文件的插件来过滤掉打包过程中产生的以.开头的文件</span></span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        ignore: [<span class="string">'.*'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在config文件中打开了代码压缩配置，会在下面进行代码压缩。</span></span><br><span class="line"><span class="keyword">if</span> (config.build.productionGzip) &#123;</span><br><span class="line">  <span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">//打包后的文件名</span></span><br><span class="line">      asset: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">      algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">      <span class="comment">//压缩config文件中规定的压缩文件</span></span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">        <span class="string">'\\.('</span> +</span><br><span class="line">        config.build.productionGzipExtensions.join(<span class="string">'|'</span>) +</span><br><span class="line">        <span class="string">')$'</span></span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">//小于此大小的文件不会被压缩</span></span><br><span class="line">      threshold: <span class="number">10240</span>,</span><br><span class="line">      <span class="comment">//压缩率小于此值的文件才会被压缩</span></span><br><span class="line">      minRatio: <span class="number">0.8</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列出打包后文件的详细文件信息，vue-cli默认禁用了，个人感觉也的确没什么用。</span></span><br><span class="line"><span class="keyword">if</span> (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  <span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line">  webpackConfig.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将合并后的配置对象导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure><h4 id="webpack-dev-conf-js"><a href="#webpack-dev-conf-js" class="headerlink" title="webpack.dev.conf.js"></a><strong><em>webpack.dev.conf.js</em></strong></h4><p><strong><em>webpack.dev.conf.js</em></strong> 中是在开发模式下的一些<code>webpack</code>配置。当我们执行<code>npm run dev</code>时，执行的就是此文件。</p><figure class="highlight js"><figcaption><span>webpack.dev.conf.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入utils.js中定义好的函数，此文件会在下面详细解释</span></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="comment">//引入webpack，需要使用它的一些自带插件</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="comment">//引入config文件夹中的配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">//引入webpack-merge插件，主要用于合并配置对象</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="comment">//引入路径模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">//引入webpack.base.conf中基础的webpack配置</span></span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>)</span><br><span class="line"><span class="comment">//引入webpack的copy插件，主要用于复制文件或文件夹到指定目录</span></span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入webpack的html插件，用于设置模板index.html，自动将打包后资源引入到html文件中。</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入FriendError插件，对错误进行收集汇总，并以更友好的形式输出。</span></span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//搜索闲置端口，默认情况下是8000</span></span><br><span class="line"><span class="keyword">const</span> portfinder = <span class="built_in">require</span>(<span class="string">'portfinder'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前程序环境的地址</span></span><br><span class="line"><span class="keyword">const</span> HOST = process.env.HOST</span><br><span class="line"><span class="comment">//当前程序环境下的端口</span></span><br><span class="line"><span class="keyword">const</span> PORT = process.env.PORT &amp;&amp; <span class="built_in">Number</span>(process.env.PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将dev的webpack配置对象和基础的webpack配置对象合并</span></span><br><span class="line"><span class="keyword">const</span> devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">     <span class="comment">// 使用utils.js中的方法，生成各种css类型的转换和格式化配置。</span></span><br><span class="line">    rules: utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap, <span class="attr">usePostCSS</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 根据config中的配置确定是否生成便于调试的sourcemap文件</span></span><br><span class="line">  devtool: config.dev.devtool,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本地开发服务器配置</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">//在浏览器控制台显示消息的级别限制</span></span><br><span class="line">    clientLogLevel: <span class="string">'warning'</span>,</span><br><span class="line">    <span class="comment">//使用HTML5 histort API</span></span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      <span class="comment">//将404页面导向到index.html，对于SPA单页面应用非常有用。</span></span><br><span class="line">      rewrites: [</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="regexp">/.*/</span>, <span class="attr">to</span>: path.posix.join(config.dev.assetsPublicPath, <span class="string">'index.html'</span>) &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//启用模块热更新</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//dev-server的默认根目录为当前目录</span></span><br><span class="line">    contentBase: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//使用gzip方式压缩代码</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//dev-server的host，如果未在config中设置则使用默认设置localhost</span></span><br><span class="line">    host: HOST || config.dev.host,</span><br><span class="line">    <span class="comment">//dev-server的port，如果未在config中设置则使用8000端口</span></span><br><span class="line">    port: PORT || config.dev.port,</span><br><span class="line">    <span class="comment">//根据config中的配置来确定是否自动打开浏览器</span></span><br><span class="line">    open: config.dev.autoOpenBrowser,</span><br><span class="line">    <span class="comment">//根据config中配置来确定是否错误全屏覆盖页面显示</span></span><br><span class="line">    overlay: config.dev.errorOverlay</span><br><span class="line">      ? &#123; <span class="attr">warnings</span>: <span class="literal">false</span>, <span class="attr">errors</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      : <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//dev-sever的根目录，默认是'/'，如果项目并不是在网站根目录下，可以通过config中设置修改</span></span><br><span class="line">    publicPath: config.dev.assetsPublicPath,</span><br><span class="line">    <span class="comment">//根据config中的proxyTable来确定是否启用代理</span></span><br><span class="line">    proxy: config.dev.proxyTable,</span><br><span class="line">    <span class="comment">//不向控制台打印webpack相关的错误</span></span><br><span class="line">    quiet: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">//侦听文件改变选项</span></span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">      <span class="comment">//根据config文件中侦听选项来进行文件侦听，在config中我们设置的是使用文件系统来获取文件改变</span></span><br><span class="line">      poll: config.dev.poll,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//使用此webpack插件定义全局环境常量</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: <span class="built_in">require</span>(<span class="string">'../config/dev.env'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//使用此webpack插件进行文件改变自动刷新，模块热更新，绝对不能在生产环境下使用！</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="comment">//使用此webpack插件在模块更新时在控制台打印出文件名</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), </span><br><span class="line">    <span class="comment">//使用此webpack插件跳过编译错误并记录错误代码</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用此插件生成挂载打包后资源的html文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">//生成html页面使用的模板文件</span></span><br><span class="line">      template: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">//将js文件的引入放到html的body标签后面</span></span><br><span class="line">      inject: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用复制文件的插件来过滤掉打包过程中产生的以.开头的文件</span></span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</span><br><span class="line">        to: config.dev.assetsSubDirectory,</span><br><span class="line">        ignore: [<span class="string">'.*'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将webpack配置对象异步传递出去（因为要进行寻找端口号等耗时操作</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  portfinder.basePort = process.env.PORT || config.dev.port</span><br><span class="line">  <span class="comment">//查找当前环境端口</span></span><br><span class="line">  portfinder.getPort(<span class="function">(<span class="params">err, port</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.env.PORT = port</span><br><span class="line">      <span class="comment">//如果端口未被占用就将当前进程绑定到端口</span></span><br><span class="line">      devWebpackConfig.devServer.port = port</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加文件顶部引入的错误信息整理美化插件</span></span><br><span class="line">      devWebpackConfig.plugins.push(<span class="keyword">new</span> FriendlyErrorsPlugin(&#123;</span><br><span class="line">        compilationSuccessInfo: &#123;</span><br><span class="line">          messages: [<span class="string">`Your application is running here: http://<span class="subst">$&#123;devWebpackConfig.devServer.host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//添加错误发生所在域名和端口的提示信息</span></span><br><span class="line">        onErrors: config.dev.notifyOnErrors</span><br><span class="line">        ? utils.createNotifierCallback()</span><br><span class="line">        : <span class="literal">undefined</span></span><br><span class="line">      &#125;))</span><br><span class="line">      <span class="comment">//将配置好的webpack配置传递出去</span></span><br><span class="line">      resolve(devWebpackConfig)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="vue-loader-conf-js"><a href="#vue-loader-conf-js" class="headerlink" title="vue-loader.conf.js"></a><strong><em>vue-loader.conf.js</em></strong></h4><p>此文件是<code>vue-cli</code> 中用于生成处理<code>.vue</code>单文件<code>webpack</code>配置。主要是用于解决<code>vue</code>中各种格式，如<code>css</code>，<code>scss</code>，<code>less</code>等的转换处理。</p><figure class="highlight js"><figcaption><span>vue-loader.conf.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入utils.js中的相关方法</span></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="comment">//引入config中的相关配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">//判断是否为生产环境</span></span><br><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line"><span class="comment">//根据生产环境来确定ma文件的生成模式</span></span><br><span class="line"><span class="keyword">const</span> sourceMapEnabled = isProduction</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//使用utils.js中提供的方法生成css相关的loader配置</span></span><br><span class="line">  loaders: utils.cssLoaders(&#123;</span><br><span class="line">    sourceMap: sourceMapEnabled,</span><br><span class="line">    <span class="comment">//是否将样式提取到单独的文件</span></span><br><span class="line">    extract: isProduction</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">//是否生成css的map文件</span></span><br><span class="line">  cssSourceMap: sourceMapEnabled,</span><br><span class="line">  <span class="comment">//是否禁用文件缓存</span></span><br><span class="line">  cacheBusting: config.dev.cacheBusting,</span><br><span class="line">  <span class="comment">//在模板编译时，将某些资源引用，如src等，转换为require形式调用</span></span><br><span class="line">  transformToRequire: &#123;</span><br><span class="line">    video: [<span class="string">'src'</span>, <span class="string">'poster'</span>],</span><br><span class="line">    source: <span class="string">'src'</span>,</span><br><span class="line">    img: <span class="string">'src'</span>,</span><br><span class="line">    image: <span class="string">'xlink:href'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a><strong><em>utils.js</em></strong></h4><p><strong><em>utils.js</em></strong>文件主要存放了几个方法函数，例如生成<code>vue-loader.conf.js</code>需要的<code>css</code>的一些<code>loader</code>配置的方法等。</p><figure class="highlight js"><figcaption><span>utils.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入nodejs的path目录路径模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">//引入config文件夹下的配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">//引入ExtractText插件，用于将文本（主要是css）提取到一个单独的文件中去。</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//引入项目配置package.json</span></span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数用于将一个路径处理为相对于项目根目录的相对路径</span></span><br><span class="line">exports.assetsPath = <span class="function"><span class="keyword">function</span> (<span class="params">_path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据当前环境得到项目的静态资源目录</span></span><br><span class="line">  <span class="keyword">const</span> assetsSubDirectory = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">    ? config.build.assetsSubDirectory</span><br><span class="line">    : config.dev.assetsSubDirectory</span><br><span class="line">  <span class="comment">//使用path.posix.join得到传入路径相对于资源目录的相对路径</span></span><br><span class="line">  <span class="keyword">return</span> path.posix.join(assetsSubDirectory, _path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个用于生成cssLoaders配置的cssLoaders函数并导出</span></span><br><span class="line">exports.cssLoaders = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//若未传入options参数则将其设为一个空对象</span></span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cssLoader的css配置</span></span><br><span class="line">  <span class="keyword">const</span> cssLoader = &#123;</span><br><span class="line">    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">//是否开启css的map生成</span></span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//cssLoader的postcss配置</span></span><br><span class="line">  <span class="keyword">const</span> postcssLoader = &#123;</span><br><span class="line">    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      sourceMap: options.sourceMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此函数根据传入的所使用样式的字符串名，如scss，less等生成相应loader配置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">generateLoaders</span> (<span class="params">loader, loaderOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//loaders配置数组，根据是否使用postCSS来决定是否加入上面定义的postcssLoader的配置</span></span><br><span class="line">    <span class="keyword">const</span> loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据传入的样式语法名称生成对应的loader配置</span></span><br><span class="line">    <span class="keyword">if</span> (loader) &#123;</span><br><span class="line">      loaders.push(&#123;</span><br><span class="line">        loader: loader + <span class="string">'-loader'</span>,</span><br><span class="line">        options: <span class="built_in">Object</span>.assign(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">          sourceMap: options.sourceMap</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数传入的options参数包含了extract选项定义的话</span></span><br><span class="line">    <span class="comment">// 就配置vue-style-loader使用ExtracTextPlugin插件</span></span><br><span class="line">    <span class="comment">// 将样式提取到一个单独文件中</span></span><br><span class="line">    <span class="keyword">if</span> (options.extract) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExtractTextPlugin.extract(&#123;</span><br><span class="line">        use: loaders,   <span class="comment">//使用对应loader来提取css代码</span></span><br><span class="line">        fallback: <span class="string">'vue-style-loader'</span>  <span class="comment">//如果提取失败就使用此loader提取</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'vue-style-loader'</span>].concat(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成各种css的loader配置，作为cssLoders函数的返回值。</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    css: generateLoaders(),</span><br><span class="line">    postcss: generateLoaders(),</span><br><span class="line">    less: generateLoaders(<span class="string">'less'</span>),</span><br><span class="line">    sass: generateLoaders(<span class="string">'sass'</span>, &#123; <span class="attr">indentedSyntax</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    scss: generateLoaders(<span class="string">'sass'</span>),</span><br><span class="line">    stylus: generateLoaders(<span class="string">'stylus'</span>),</span><br><span class="line">    styl: generateLoaders(<span class="string">'stylus'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成不包含在vue单文件内的样式的loader，例如通过import导入的</span></span><br><span class="line">exports.styleLoaders = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> output = []</span><br><span class="line">  <span class="comment">//首先使用上面的cssLoaders函数生成的各种loader配置</span></span><br><span class="line">  <span class="keyword">const</span> loaders = exports.cssLoaders(options)</span><br><span class="line">  <span class="comment">//将各种loader加入到一个数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> extension <span class="keyword">in</span> loaders) &#123;</span><br><span class="line">    <span class="keyword">const</span> loader = loaders[extension]</span><br><span class="line">    output.push(&#123;</span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\.'</span> + extension + <span class="string">'$'</span>),</span><br><span class="line">      use: loader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回包含各种loader配置的数组</span></span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误通知函数，在发生错误时使用node-notifier来打印出错误信息</span></span><br><span class="line">exports.createNotifierCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notifier = <span class="built_in">require</span>(<span class="string">'node-notifier'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">severity, errors</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (severity !== <span class="string">'error'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> error = errors[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> filename = error.file &amp;&amp; error.file.split(<span class="string">'!'</span>).pop()</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      title: packageConfig.name,</span><br><span class="line">      message: severity + <span class="string">': '</span> + error.name,</span><br><span class="line">      subtitle: filename || <span class="string">''</span>,</span><br><span class="line">      icon: path.join(__dirname, <span class="string">'logo.png'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a><strong><em>build.js</em></strong></h4><p><strong><em>build.js</em></strong> 是我们在执行<code>npm run build</code>时执行的文件，通过相应的<code>webpack</code>配置文件中的配置来构建项目。</p><figure class="highlight js"><figcaption><span>build.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入check-versions来检查npm和node版本</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./check-versions'</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置当前环境为生产环境</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入ora插件，此插件用来显示build前的loading动画（就是那个转圈圈的动画</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>)</span><br><span class="line"><span class="comment">//引入rimraf插件，此插件用来执行系统的rm -rf 命令</span></span><br><span class="line"><span class="keyword">const</span> rm = <span class="built_in">require</span>(<span class="string">'rimraf'</span>)</span><br><span class="line"><span class="comment">//引入nodejs的PATH模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">//引入chalk插件，主要用于为命令行的输出添加颜色</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</span><br><span class="line"><span class="comment">//引入webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="comment">//引入config文件下的配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="comment">//引入webpack.prod.conf中的生产环境相关配置</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.prod.conf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始loading动画</span></span><br><span class="line"><span class="keyword">const</span> spinner = ora(<span class="string">'building for production...'</span>)</span><br><span class="line">spinner.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空build的目标文件夹，一般默认'./dist'</span></span><br><span class="line">rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="comment">//清空文件夹后，执行webpack构建</span></span><br><span class="line">  webpack(webpackConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    spinner.stop()</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="comment">//编译完成后，输出编译后的文件详情</span></span><br><span class="line">    process.stdout.write(stats.toString(&#123;</span><br><span class="line">      <span class="comment">//输出控制台信息是否配色</span></span><br><span class="line">      colors: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">//增加内置模块信息的编译选项</span></span><br><span class="line">      modules: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 当项目使用TS时，将此选项置为true，可输出TS编译中错误</span></span><br><span class="line">      children: <span class="literal">false</span>, </span><br><span class="line">      <span class="comment">//允许较少的输出</span></span><br><span class="line">      chunks: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">//将内置模块信息加到包信息</span></span><br><span class="line">      chunkModules: <span class="literal">false</span></span><br><span class="line">    &#125;) + <span class="string">'\n\n'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编译过程出错的提示消息</span></span><br><span class="line">    <span class="keyword">if</span> (stats.hasErrors()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.red(<span class="string">'  Build failed with errors.\n'</span>))</span><br><span class="line">      process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编译成功后的输出信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(chalk.cyan(<span class="string">'  Build complete.\n'</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.yellow(</span><br><span class="line">      <span class="string">'  Tip: built files are meant to be served over an HTTP server.\n'</span> +</span><br><span class="line">      <span class="string">'  Opening index.html over file:// won\'t work.\n'</span></span><br><span class="line">    ))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="check-versions-js"><a href="#check-versions-js" class="headerlink" title="check-versions.js"></a><strong><em>check-versions.js</em></strong></h4><p><strong><em>bulid</em></strong> 文件夹下的<strong><em>check-versions.js</em></strong>文件，它与其他文件没什么关联，作用比较简单——用来检测<code>node</code>和<code>npm</code>版本。</p><p>具体实现代码如下，我做了详细注释。</p><figure class="highlight js"><figcaption><span>check-versions.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用js的严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">//引入插件chalk，此插件用于为文字添加不同的颜色从而便于在命令行输出。</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</span><br><span class="line"><span class="comment">//引入插件semver，用于将版本号转换为纯净的数字形式。例如将v9.10.1转换为9.10.1</span></span><br><span class="line"><span class="keyword">const</span> semver = <span class="built_in">require</span>(<span class="string">'semver'</span>)</span><br><span class="line"><span class="comment">//导入项目的配置文件package.json,主要为了使用其中的engines声明的node和npm版本选项</span></span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</span><br><span class="line"><span class="comment">//引入插件shelljs,此插件用于执行Unix命令，我们通过此插件来确定npm是否安装</span></span><br><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">'shelljs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//exec函数用于执行命令行命令</span></span><br><span class="line"><span class="comment">//它接受一个cmd命令，并通过引入child_process插件新建一个子进程来执行cmd命令，将命令结果转化为前后没有空格的字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span> (<span class="params">cmd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync(cmd).toString().trim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//node的版本信息</span></span><br><span class="line"><span class="keyword">const</span> versionRequirements = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'node'</span>, </span><br><span class="line">    <span class="comment">//当前的node版本，通过process.version获得</span></span><br><span class="line">    currentVersion: semver.clean(process.version),</span><br><span class="line">    <span class="comment">//项目依赖的node版本，从项目配置文件中获得</span></span><br><span class="line">    versionRequirement: packageConfig.engines.node</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//npm的版本信息</span></span><br><span class="line"><span class="keyword">if</span> (shell.which(<span class="string">'npm'</span>)) &#123;</span><br><span class="line">  versionRequirements.push(&#123;</span><br><span class="line">    name: <span class="string">'npm'</span>,</span><br><span class="line">    <span class="comment">//当前的npm版本，通过上面的exec执行命令npm --version 获得</span></span><br><span class="line">    currentVersion: exec(<span class="string">'npm --version'</span>),</span><br><span class="line">    <span class="comment">//项目依赖的npm版本</span></span><br><span class="line">    versionRequirement: packageConfig.engines.npm</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据上面的node和npm版本信息，进行相应提示和操作。</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> warnings = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; versionRequirements.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> mod = versionRequirements[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前的版本不满足项目依赖的要求，将相应信息加入到警告信息列表</span></span><br><span class="line">    <span class="keyword">if</span> (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</span><br><span class="line">      warnings.push(mod.name + <span class="string">': '</span> +</span><br><span class="line">        chalk.red(mod.currentVersion) + <span class="string">' should be '</span> +</span><br><span class="line">        chalk.green(mod.versionRequirement)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果警告信息列表不为空，向命令行输出警告信息</span></span><br><span class="line">  <span class="keyword">if</span> (warnings.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'To use this template, you must update following to modules:'</span>))</span><br><span class="line">    <span class="built_in">console</span>.log()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; warnings.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> warning = warnings[i]</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'  '</span> + warning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log()</span><br><span class="line">    <span class="comment">//结束进程</span></span><br><span class="line">    process.exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><strong><em>package.json</em></strong></h3><p>我们顺便来讲解一下项目的<strong><em>package.json</em></strong>，作为项目的配置文件，它主要用来保存项目的基本信息和管理项目的相关依赖。</p><p>我们执行<code>npm install</code>时，就是通过它里面的项目依赖列表来确定安装那些包的。</p><figure class="highlight js"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从name到private，是项目的基本信息和配置。在新建项目时询问我们的就是这些信息</span></span><br><span class="line">  <span class="comment">//项目名称，不能包含大写字母和点和下划线</span></span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"my-vue"</span>,</span><br><span class="line">  <span class="comment">//项目版本</span></span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="comment">//项目描述</span></span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"A Vue.js project"</span>,</span><br><span class="line">  <span class="comment">//项目作者</span></span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"Gyf_linux &lt;guo812773673@163.com&gt;"</span>,</span><br><span class="line">  <span class="comment">//项目是否私有</span></span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//scripts命令，也就是我们通过控制台执行的缩写命令对应的命令行命令</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">//启动本地http服务器，能够实时相应文件改变</span></span><br><span class="line">    <span class="comment">//inline模式是指我们直接访问的就是项目根目录的index.html，对应有另一个模式iframe</span></span><br><span class="line">    <span class="comment">//progess 为显示打包进度</span></span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//项目的依赖，安装模块使用--save指令选项即是把模块置于此中</span></span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"vue"</span>: <span class="string">"^2.5.2"</span>,</span><br><span class="line">    <span class="string">"vue-router"</span>: <span class="string">"^3.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//开发环境的依赖，安装模块时使用--save-dev将模块置于此中</span></span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="comment">//用于为css添加浏览器前缀</span></span><br><span class="line">    <span class="string">"autoprefixer"</span>: <span class="string">"^7.1.2"</span>,</span><br><span class="line">    <span class="comment">//以下以babel开头的均为针对es6解析的插件</span></span><br><span class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.22.1"</span>,</span><br><span class="line">    <span class="string">"babel-eslint"</span>: <span class="string">"^8.2.1"</span>,</span><br><span class="line">    <span class="string">"babel-helper-vue-jsx-merge-props"</span>: <span class="string">"^2.0.3"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^7.1.1"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-syntax-jsx"</span>: <span class="string">"^6.18.0"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-vue-jsx"</span>: <span class="string">"^3.5.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.3.2"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-2"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="comment">//用于为命令行输出配色</span></span><br><span class="line">    <span class="string">"chalk"</span>: <span class="string">"^2.0.1"</span>,</span><br><span class="line">    <span class="comment">//用于拷贝文件到其他目录</span></span><br><span class="line">    <span class="string">"copy-webpack-plugin"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line">    <span class="comment">//用于解析css格式的文件</span></span><br><span class="line">    <span class="string">"css-loader"</span>: <span class="string">"^0.28.0"</span>,</span><br><span class="line">    <span class="comment">//以下以eslint开头的就用于eslint语法检查</span></span><br><span class="line">    <span class="string">"eslint"</span>: <span class="string">"^4.15.0"</span>,</span><br><span class="line">    <span class="string">"eslint-config-standard"</span>: <span class="string">"^10.2.1"</span>,</span><br><span class="line">    <span class="string">"eslint-friendly-formatter"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="string">"eslint-loader"</span>: <span class="string">"^1.7.1"</span>,</span><br><span class="line">    <span class="string">"eslint-plugin-import"</span>: <span class="string">"^2.7.0"</span>,</span><br><span class="line">    <span class="string">"eslint-plugin-node"</span>: <span class="string">"^5.2.0"</span>,</span><br><span class="line">    <span class="string">"eslint-plugin-promise"</span>: <span class="string">"^3.4.0"</span>,</span><br><span class="line">    <span class="string">"eslint-plugin-standard"</span>: <span class="string">"^3.0.1"</span>,</span><br><span class="line">    <span class="string">"eslint-plugin-vue"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="comment">//用于将文本提取到单独的文件中去，主要用于提取css</span></span><br><span class="line">    <span class="string">"extract-text-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="comment">//用于压缩文件</span></span><br><span class="line">    <span class="string">"file-loader"</span>: <span class="string">"^1.1.4"</span>,</span><br><span class="line">    <span class="comment">//整理和聚合webpack错误，并以更友好的形式输出</span></span><br><span class="line">    <span class="string">"friendly-errors-webpack-plugin"</span>: <span class="string">"^1.6.1"</span>,</span><br><span class="line">    <span class="comment">//根据模板创建html文件并将资源引入到此文件</span></span><br><span class="line">    <span class="string">"html-webpack-plugin"</span>: <span class="string">"^2.30.1"</span>,</span><br><span class="line">    <span class="comment">//使用node发送跨平台的通知</span></span><br><span class="line">    <span class="string">"node-notifier"</span>: <span class="string">"^5.1.2"</span>,</span><br><span class="line">    <span class="comment">//压缩css文件，并解决使用ExtractTextPlugin插件提取出的css中的重复</span></span><br><span class="line">    <span class="string">"optimize-css-assets-webpack-plugin"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="comment">//用于在命令显示动画的插件</span></span><br><span class="line">    <span class="string">"ora"</span>: <span class="string">"^1.2.0"</span>,</span><br><span class="line">    <span class="comment">//查看进程端口</span></span><br><span class="line">    <span class="string">"portfinder"</span>: <span class="string">"^1.0.13"</span>,</span><br><span class="line">    <span class="comment">//postcss用于处理postcss相关的样式</span></span><br><span class="line">    <span class="string">"postcss-import"</span>: <span class="string">"^11.0.0"</span>,</span><br><span class="line">    <span class="string">"postcss-loader"</span>: <span class="string">"^2.0.8"</span>,</span><br><span class="line">    <span class="string">"postcss-url"</span>: <span class="string">"^7.2.1"</span>,</span><br><span class="line">    <span class="comment">//执行命令行rm -rf 命令</span></span><br><span class="line">    <span class="string">"rimraf"</span>: <span class="string">"^2.6.0"</span>,</span><br><span class="line">    <span class="comment">//对库版本号进行格式化和比较</span></span><br><span class="line">    <span class="string">"semver"</span>: <span class="string">"^5.3.0"</span>,</span><br><span class="line">    <span class="comment">//用于执行shell命令</span></span><br><span class="line">    <span class="string">"shelljs"</span>: <span class="string">"^0.7.6"</span>,</span><br><span class="line">    <span class="comment">//用于压缩js</span></span><br><span class="line">    <span class="string">"uglifyjs-webpack-plugin"</span>: <span class="string">"^1.1.1"</span>,</span><br><span class="line">    <span class="comment">//用于将图片转换为base64的DataUrl</span></span><br><span class="line">    <span class="string">"url-loader"</span>: <span class="string">"^0.5.8"</span>,</span><br><span class="line">    <span class="comment">//vue单文件组件的核心webpack加载器</span></span><br><span class="line">    <span class="string">"vue-loader"</span>: <span class="string">"^13.3.0"</span>,</span><br><span class="line">    <span class="comment">//用于vue单文件中的css处理，将经过各loader处理后的css作为style标签引入根文件中。</span></span><br><span class="line">    <span class="string">"vue-style-loader"</span>: <span class="string">"^3.0.1"</span>,</span><br><span class="line">    <span class="comment">//用于vue单文件的模板编译</span></span><br><span class="line">    <span class="string">"vue-template-compiler"</span>: <span class="string">"^2.5.2"</span>,</span><br><span class="line">    <span class="comment">//打包工具webpack</span></span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="comment">//用于可视化分析webpack打包后的项目各文件大小</span></span><br><span class="line">    <span class="string">"webpack-bundle-analyzer"</span>: <span class="string">"^2.9.0"</span>,</span><br><span class="line">    <span class="comment">//实时重载的本地开发服务器</span></span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^2.9.1"</span>,</span><br><span class="line">    <span class="comment">//用于配置对象的合并，重复的选项将会被覆盖。</span></span><br><span class="line">    <span class="string">"webpack-merge"</span>: <span class="string">"^4.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//项目需要的node和npm的版本</span></span><br><span class="line">  <span class="string">"engines"</span>: &#123;</span><br><span class="line">    <span class="string">"node"</span>: <span class="string">"&gt;= 6.0.0"</span>,</span><br><span class="line">    <span class="string">"npm"</span>: <span class="string">"&gt;= 3.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//项目需要的浏览器或客户端版本</span></span><br><span class="line">  <span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>,</span><br><span class="line">    <span class="string">"last 2 versions"</span>,</span><br><span class="line">    <span class="string">"not ie &lt;= 8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的介绍和总结，我们对<code>vue</code>的脚手架结构和其中各文件的作用应该有了一定的了解和认识。由于篇幅有限，对其中具体的一些插件的配置项和使用并未做详细解释。当然，在需要用到时，这些插件的文档，去搜索一下也很容易找到。</p><p>写这篇文章，我去查了很多文档和博客，一行行的注释写下来，腰酸背痛。也愈发佩服<code>vue</code>的作者了，能把这些琐碎的配置，组织的文件结构明了，代码逻辑清晰，写法简洁优雅，实在是厉害。哎，前方路远，差距好大，努力努力。</p><p>好啦，感谢阅读本文^_^。我赶紧去休息一下去。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS两栏布局的常用方法</title>
      <link href="/2018/05/04/CSS%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/04/CSS%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>两栏布局作为<code>CSS</code>中一个比较古老的布局问题，可以用多种方法实现。在实际工作中很多人也大概跟我一样都是用的时候顺着思路写出来一个能用就行，很少仔细考虑过各个实现方法之间的那些细微的差异和特殊情况下布局的不同表现。</p><p>不过话说回来，为了写这篇博客，我也查了不少有关<code>CSS</code>布局的资料和文章，算是温习了很多布局方面已经被慢慢遗忘的知识。也越发觉得<code>flex</code>布局方式大概真的是未来网页布局的最佳解决方案，那些传统的各种不正交的<code>CSS</code> 概念，庞杂繁复又无趣，实在是有些反人类。</p><p>前端的各种框架类库和新技术层出不穷，工作这么长时间来，自己也接触了不少。前端构建，组件化，模块等等这些东西做久了，还真是蛮怀念当初刚入前端做切图仔的日子，虽然工资不高，工作也挺单调，但那些整天就知道傻乐的日子，也好像真的一去不复返了呢。</p><p>好了，不扯远了，说正事。</p></blockquote><a id="more"></a><p><code>CSS</code>的两栏布局，通常情况都是一个固定宽度的侧边栏加上一个自适应宽度的主内容栏。实现方式比较多，本文肯定不能尽述，仅对常用的方法做一个介绍。</p><h4 id="浮动方式"><a href="#浮动方式" class="headerlink" title="浮动方式"></a>浮动方式</h4><p><code>float</code>方式，也是最简单的实现两栏布局的方式。如下:</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双浮动方式"><a href="#双浮动方式" class="headerlink" title="双浮动方式"></a>双浮动方式</h4><p>此种方式需要配合<code>CSS</code>的<code>calc</code>属性，从而避免无宽度元素浮动会自动缩小为最小宽度的问题。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    float：left；</span><br><span class="line">    <span class="selector-tag">width</span><span class="selector-pseudo">:calc(100</span>% <span class="selector-tag">-</span> 220<span class="selector-tag">px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="float-BFC-方式"><a href="#float-BFC-方式" class="headerlink" title="float + BFC 方式"></a><strong><em>float + BFC</em></strong> 方式</h4><p>这种方法同样利用了浮动，但通过为主内容栏设置<code>overflow</code>形成<code>BFC</code>，来达到避免被侧栏覆盖的效果。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    overflow：auto；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="行内块方式"><a href="#行内块方式" class="headerlink" title="行内块方式"></a>行内块方式</h4><p>将两栏元素都设为行内块<code>inline-block</code>，再通过<code>calc</code>属性来达到主内容区宽度自适应。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="built_in">calc</span>(100% - 220px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>calc</code>方式虽然可以达到自适应的效果，但是对宽度计算比较苛刻，同时也会因为盒模型表现方式不同而出现布局问题。另外在将两栏都改为行内元素后，还需要考虑<code>vertical-align</code>问题。不推荐使用。</p></blockquote><h4 id="固定定位方式"><a href="#固定定位方式" class="headerlink" title="固定定位方式"></a>固定定位方式</h4><p>为侧边栏设置固定定位，缺点是需要改变父元素的定位方式。同时因为侧边栏已脱离文档流，当高度较高时就会超出父容器，同时还需要为主内容区设置外边距保证其不会被侧边栏覆盖。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    margin-left：220px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以将两栏都设置为固定定位来达到布局效果，但这种方式比较暴力，且难以维护，不推荐。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    position：absolute;</span><br><span class="line">    <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;</span><br><span class="line">    <span class="selector-tag">left</span><span class="selector-pseudo">:0</span>;</span><br><span class="line">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="table方式"><a href="#table方式" class="headerlink" title="table方式"></a><strong><em>table</em></strong>方式</h4><p>使用表格布局的方式来达到想要的效果（很久远以前的实现方式，透露着老气。。。)另外当两栏高度想要不同时，这种方法就没法用了。</p><figure class="highlight css"><figcaption><span>CSS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex-方式"><a href="#flex-方式" class="headerlink" title="flex 方式"></a><strong><em>flex</em></strong> 方式</h4><p>这种方式，代码简单方便可控，兼容问题在现在也不是什么大问题了。推荐使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">    flex：0 0 200px;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    flex:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<code>flex</code> 布局默认<code>align-item：stretch</code>，导致列等高。如需要不同高度，可将此属性设置为<code>algin-item：flex-start</code> 。</p></blockquote><p>以上就是我总结的关于两栏布局的一些实现方法。感谢阅读。</p><p><strong><em>ps：</em></strong>前端搞来搞去，还真是<code>CSS</code>最让人头大哈哈哈哈。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之Symbol</title>
      <link href="/2018/04/28/ES6%E4%B9%8BSymbol/"/>
      <url>/2018/04/28/ES6%E4%B9%8BSymbol/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>众所周知，在 <code>JS</code> 中有六种基本数据类型，即五个原始数据类型<code>Undefined</code> ，<code>Null</code>，<code>Boolean</code>，<code>String</code>，<code>Number</code>和一个对象类型<code>Object</code>。</p><p>在<code>ES6</code>中，又推出了一种新的原始数据类型，就是我们今天博客中要介绍的——<code>Symbol</code>类型。</p><p>这种新的数据类型是做什么用的呢？它有哪些需要我们及时了解和掌握的知识和特性呢？</p><p>就让我们来一步一步揭开<code>ES6</code>新数据类型<code>Symbol</code>的神秘面纱吧。</p></blockquote><a id="more"></a><p><strong><em>Symbol</em></strong>，就是符号，标志的意思。在<code>ES6</code>新出现的<code>Symbol</code>数据类型，主要有以下两个作用：</p><ul><li>提供<code>JS</code>中一直比较欠缺的一种特性： <strong><em>唯一性</em></strong></li><li>为操作<code>JS</code>的相关内部逻辑提供接口，也就是操作一些<code>JS</code>的语言内部行为</li></ul><p>当然，第二个作用一般在实际业务和项目中是很难遇到应用的地方的（别告诉我你有在项目代码中进行<code>JS</code>魔改的打算。。。。</p><p>所以这篇博客里对<code>Symbol</code>的介绍，也主要侧重于它的第一个作用，也就是它所能提供的<strong><em>唯一性</em></strong>， 具体是个什么东西。</p><h3 id="Symbol的创建"><a href="#Symbol的创建" class="headerlink" title="Symbol的创建"></a><strong><em>Symbol</em></strong>的创建</h3><p>创建一个<code>Symbol</code>类型的值的语法如下：</p><figure class="highlight js"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>([description])</span><br><span class="line"><span class="comment">//description为可选参数。为创建的symbol值提供一个描述</span></span><br></pre></td></tr></table></figure><p>通过<code>Symbol()</code>这个静态函数，我们可以创建一个<code>symbol</code>类型的值。</p><p>需要注意的是，跟其他的原始类型不同，创建出来的这个<code>symbol</code>值我们是看不见的，这也是<code>symbol</code>对于很多初学者来说比较难以理解的地方，它并不像一个字符串或者数字一样，非常直观的静静的躺在代码里，它是隐藏在代码后面的。我们知道<code>Symbol()</code>函数返回一个<code>symbol</code>值，我们也可以将这个<code>symbol</code>值赋值给一个变量，但我们并不能真真切切的看到这个<code>symbol</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="comment">// 此时变量a代表的就是我们创建的symbol值，一个独一无二的值。</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="comment">// 变量b是我们创建的另一个symbol值，它也是独一无二的。</span></span><br><span class="line"><span class="keyword">typeof</span> a   <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> b   <span class="comment">// symbol</span></span><br><span class="line">a   <span class="comment">// 打印到控制台，输出 Symbol()</span></span><br><span class="line">b   <span class="comment">// 打印到控制台，同样输出 Symbol()</span></span><br><span class="line">a === b  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>到这里，我们就应该可以理解<code>symbol</code>值的创建方法了，也明白了我们每次调用<code>Symbol()</code>创建的每个<code>symbol</code>值，都是独一无二，仅此一份的，绝对不会重复。</p><p>那问题又来了，虽然我们在上面代码中创建的两个<code>symbol</code>值是不相等的，独一无二的，但打印到控制台，输出的都是<code>Symbol()</code>。我们怎么区分它们呢？谁知道它们是不是代表的同一个<code>symbol</code>。</p><p>别忘了我们在上面提到的，<code>Symbol</code>函数可以接受一个可选参数<code>description</code>。这个参数，就可以为我们创建的<code>symbol</code>值，提供一个描述，便于我们进行区分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a symbol'</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b symbol'</span>)</span><br><span class="line">a   <span class="comment">// 打印到控制台，输出 Symbol('a symbol')</span></span><br><span class="line">b   <span class="comment">// 打印到控制台，输出 Symbol('b symbol')</span></span><br></pre></td></tr></table></figure><p>但要记得我们上面提到的，<code>Symbol()</code>函数每次创建的<code>symbol</code>值都是唯一的，<code>description</code>参数只是提供一个描述。</p><p>就算为两次创建的<code>symbol</code>提供相同的描述，它们各自仍然是独一无二的。切记：<code>symbol</code>的唯一性唯一性唯一性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'tsymbol'</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'tsymbol'</span>)</span><br><span class="line">a === b  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>以上就是<code>symbol</code>的基本概念，关于它，还有以下几个细碎的要点需要注意:</p><ul><li><p>作为原始数据类型，<code>symbol</code>值是不能用 <code>new Symbol()</code>创建的。（你问<code>new Boolean</code>，<code>new Number()</code> 为什么可以？额，这属于<code>JS</code>的历史遗留问题，其实它们也不是完全可以，不信你打印一下<code>typeof new Number(22)</code></p></li><li><p><code>symbol</code>值不能和其他类型的值进行运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line">+a        <span class="comment">//TypeError: can't convert symbol to number</span></span><br><span class="line">a + <span class="number">3</span>     <span class="comment">//TypeError: can't convert symbol to string</span></span><br><span class="line">a + <span class="string">'aaa'</span> <span class="comment">//TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure></li><li><p><code>symbol</code> 可以显式转换为字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(a)   <span class="comment">//'Symbol(a)'</span></span><br><span class="line">a.toString  <span class="comment">//'Symbol(a)'</span></span><br></pre></td></tr></table></figure></li><li><p><code>symbol</code>可以转换为布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">!a   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(a)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以像下面这样使用（谁会这么用啊摔</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;....&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="Symbol的使用"><a href="#Symbol的使用" class="headerlink" title="Symbol的使用"></a><strong><em>Symbol</em></strong>的使用</h3><h4 id="作为属性名使用"><a href="#作为属性名使用" class="headerlink" title="作为属性名使用"></a>作为属性名使用</h4><p>在上面提到<code>symbol</code>的唯一性这个特点时，相信很多同学就会想到将其作为属性名使用，从而避免我们经常遇到的，在向对象添加属性时错误覆盖对象原有属性等各种有关属性冲突的问题。</p><p><strong>通过将<code>symbol</code>值作为对象的属性名，保证这个对象属性的唯一性，也正是<code>symbol</code>最重要的作用之一。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> star = <span class="built_in">Symbol</span>(<span class="string">'star'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[star] = <span class="string">"hello symbol"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [star]: <span class="string">"hello symbol"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, star, &#123;<span class="attr">value</span>: <span class="string">"hello world"</span>&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，对象以<code>symbol</code>作为属性名时，访问这个属性必须要使用方括号形式，而不能使用点运算符形式，因为点运算符会始终使用它后面跟随属性名的字符串形式值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj[star]    <span class="comment">//'hello symbol'</span></span><br><span class="line">obj.star    <span class="comment">// undefined</span></span><br><span class="line">obj[<span class="string">'star'</span>] <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>另外，对象以<code>symbol</code>作为属性名时，该属性依然是公开属性，但不会被<code>for...in</code>，<code>for...of</code>循环到，也不会被<code>Object.keys()</code>，<code>Object.getOwnPropertyNames()</code>，<code>JSON.stringify()</code>返回。</p><p>要想遍历出对象属性名为<code>symbol</code>值类型的属性，需要使用<code>Object.getOwnPropertySymbols()</code>方法，它返回所有<code>symbol</code>类型属性名的一个数组。</p><h4 id="作为常量使用"><a href="#作为常量使用" class="headerlink" title="作为常量使用"></a>作为常量使用</h4><p>很多时候，我们需要为对象设置一系列属性用于对应不同的类型，在使用时，我们并不在意这些属性的具体值，只需要保证它们是可区分的各自唯一值即可。此时我们可以使用<code>symbol</code>作为我们的属性值，从而保证多个属性值间的唯一性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> type = &#123;</span><br><span class="line">    car: <span class="built_in">Symbol</span>(<span class="string">'car'</span>),</span><br><span class="line">    bicycle: <span class="built_in">Symbol</span>(<span class="string">'bicycle'</span>),</span><br><span class="line">    plane: <span class="built_in">Symbol</span>(<span class="string">'plane'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traffic</span>(<span class="params">yourTraffic</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(yourTraffic === type.car)&#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(yourTraffic === type.bicycle)&#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(yourTraffic === type.plane)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就不需要使用一堆字符串，来区分对象多个属性之间的值了。</p><h3 id="Symbol的静态方法"><a href="#Symbol的静态方法" class="headerlink" title="Symbol的静态方法"></a><strong><em>Symbol</em></strong>的静态方法</h3><p><code>Symbol</code>有两个方法，分别是<code>Symbol.for(key)</code> 和 <code>Symbol.keyFor(sym)</code>。</p><h4 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a><strong><em>Symbol.for(key)</em></strong></h4><p><code>Symbol.for(key)</code>方法同样是用于创建一个<code>symbol</code>值，但它接受一个<code>key</code>值。如果我们使用相同的<code>key</code>创建过一个<code>symbol</code>值，它就会直接返回这个<code>symbol</code>值，否则就会将创建一个新的以<code>key</code>为索引登记在全局注册表中的<code>symbol</code>值。</p><p><code>Symbol</code>的全局注册表，就是使用<code>Symbol.for(key)</code>方法创建的所有<code>symbol</code>的登记薄，它存在于全局环境，甚至可以跨越<code>iframe</code>的限制。为我们复用具有唯一性的<code>symbol</code>值提供了非常好的支持。</p><p>需要注意，使用<code>Symbol()</code>创建的<code>symbol</code>是不会被登记到全局注册表的，它每次都返回一个新的<code>symbol</code>值。</p><h4 id="Symbol-keyFor-sym"><a href="#Symbol-keyFor-sym" class="headerlink" title="Symbol.keyFor(sym)"></a><strong><em>Symbol.keyFor(sym)</em></strong></h4><p>很显然，这个方法就是<code>Symbol.for(key)</code>的逆方法，它接受一个<code>symbol</code>值作为参数，并返回这个<code>symbol</code>在全局注册表中对应的<code>key</code>值。如果没有对应的<code>key</code>，它就返回个<code>undefine</code>（要不它还能返回什么。。。？</p><p>通过这两个方法的相互配合，我们对<code>Symbol</code>的基本使用能够形成一个闭环。</p><h3 id="Symbol的静态属性"><a href="#Symbol的静态属性" class="headerlink" title="Symbol的静态属性"></a><strong><em>Symbol</em></strong>的静态属性</h3><p><code>Symbol</code>的静态属性，主要用来提供给我们一些操纵<code>js</code>内部语言行为的一些接口。例如<code>Symbol.replace</code>，就是用于修改字符串的<code>String.prototype.replace()</code>方法的。当一个对象被<code>String.prototype.replace()</code>方法调用时，会使用对象的<code>Symbol.replace</code>属性对应的方法代替。从而达到修改<code>js</code>内部语言实现的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aStr = <span class="string">'some string'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.search(aStr,<span class="string">'some'</span>)</span><br><span class="line"><span class="comment">//等于以下代码</span></span><br><span class="line">aStr[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>,<span class="string">'some'</span>)</span><br></pre></td></tr></table></figure><p>具体的，我们就可以写出下面这样的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以修改replace的行为</span></span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">str,newstr</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(str,newstr)&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"hello"</span>.replace(x,<span class="string">"world"</span>) <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><p>当然，这种<code>Symbol</code>的使用方式很少被用到，所以在此也不再赘述。有想要了解的同学，为大家提供以下两个链接来对<code>Symbol</code>做更深入的学习。</p><ul><li><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">ECMAScript 6 入门 – Symbol 阮一峰</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN 文档 Symbol</a></li></ul><p>好啦，关于<code>ES6</code>的<code>Symbol</code>就为大家介绍到这里啦。谢谢，鞠躬退场^-^。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十三）：异步组件</title>
      <link href="/2018/04/23/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/"/>
      <url>/2018/04/23/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%89/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>如何加快核心组件和功能的加载速度，从而提升页面的访问速度和用户体验，是很多项目都面临的需要迫切解决的问题。</p><p>通过前端模块化，对于某些非核心组件和功能，进行按需和异步加载(又称懒加载)是比较常见的提高性能的手段。</p><p><code>Vue</code>的异步组件就是用来将组件设置为异步加载，从而达到减小打包后的文件尺寸，提高页面加载速度的效果。</p></blockquote><a id="more"></a><p><code>Vue</code>的异步组件，和<code>Angular</code>中的组件懒加载很相似，也都是为了实现相同的目的。对于懒加载，延迟加载，异步加载这些名词，我们在理解它们的实现方式后，其实完全可以将他们当成一种东西的不同叫法。</p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p><code>Vue</code>允许我们将组件的定义设置为一个返回组件定义的工厂函数，在组件被需要时调用这个函数得到组件定义，完成组件构建和渲染，从而达到异步加载组件的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-comp'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模拟一个异步请求组件的操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            template:<span class="string">'&lt;div&gt;a async component!&lt;/div&gt;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<a href="https://gyufei.github.io/2018/04/20/ES6%E4%B9%8BPromise/" target="_blank" rel="noopener">ES6之Promise</a>中我们介绍过<code>promise</code>对象的相关概念，如果看过那篇博客的同学，应该很容易就看出，异步组件的工厂函数，其实就是一个<code>promise</code>对象。</p><p>这个<code>promise</code>对象使用<code>resolve()</code>函数将异步加载的组件定义传递出去。当然也完全可以使用<code>reject()</code>来传递错误和异常。</p><h3 id="与webpack一起使用"><a href="#与webpack一起使用" class="headerlink" title="与webpack一起使用"></a>与<strong><em>webpack</em></strong>一起使用</h3><p><code>webpack</code>的<code>import()</code> 函数，用于动态加载模块。它接受一个模块名作为参数，并返回一个<code>promise</code>对象。</p><p>因此，配合着<code>webpack</code>，我们可以非常方便的在<code>vue</code>中进行组件的异步加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-comp'</span>,()=&gt;<span class="keyword">import</span>(<span class="string">'./my-async-component'</span>))</span><br></pre></td></tr></table></figure><blockquote><p>此方法属于<code>ES7</code>范畴，因此需要配合<code>babel</code>的<code>syntax-dynamic-import</code> 插件使用，从而将其转义为<code>ES5</code>。</p><p>具体使用方法如下：</p><ol><li><p>安装相关的插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>    npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt; 2. 在`webpack`中配置</span><br><span class="line">&gt;</span><br><span class="line">&gt;    ```js</span><br><span class="line">&gt;   use: [&#123;</span><br><span class="line">&gt;           loader: &apos;babel-loader&apos;,</span><br><span class="line">&gt;           options: &#123;</span><br><span class="line">&gt;             presets: [[&apos;es2015&apos;, &#123;modules: false&#125;]],</span><br><span class="line">&gt;             plugins: [&apos;syntax-dynamic-import&apos;]</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;         &#125;]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><p>在使用这种方法时，我们可以通过更多的配置项来对异步加载的状态进行控制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;      Vue.component(<span class="string">'async-comp'</span>,()=&gt;(&#123; </span><br><span class="line">&gt;       <span class="comment">//异步加载的组件</span></span><br><span class="line">&gt;       component: <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>),</span><br><span class="line">&gt;       <span class="comment">//加载时使用的组件</span></span><br><span class="line">&gt;       Loading: LoadingComp,</span><br><span class="line">&gt;       <span class="comment">//加载失败时使用的组件</span></span><br><span class="line">&gt;       error: ErrorComp,</span><br><span class="line">&gt;       <span class="comment">//组件加载的延迟事件，默认200ms</span></span><br><span class="line">&gt;       delay: <span class="number">200</span>,</span><br><span class="line">&gt;       <span class="comment">//组件加载的超时时间，默认Infinity</span></span><br><span class="line">&gt;       timeout: <span class="number">3000</span></span><br><span class="line">&gt;                   &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>同时，我们还可以通过以下的方式，将一些关系紧密的组件打包到一个<code>chunk</code>中，来保证它们的同时加载，也能够减少页面的<code>http</code>请求。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./A.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./B.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> C = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-abc" */</span> <span class="string">'./C.vue'</span>)</span><br></pre></td></tr></table></figure><h3 id="另一种异步加载方式"><a href="#另一种异步加载方式" class="headerlink" title="另一种异步加载方式"></a>另一种异步加载方式</h3><p>如果需要支持性比较好，更向后兼容的异步加载方式，也可以使用如下方式来进行异步加载组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-comp'</span>,(resolve) =&gt; <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>],resolve))</span><br></pre></td></tr></table></figure><blockquote><p><code>require()</code>函数接受两个参数，第一个参数为模块路径的数组，第二个参数为模块加载成功后的回调函数，加载成功后的模块会作为此回调函数的参数被传入。利用这个特性，我们使用<code>resolve</code>作为回调函数，可以巧妙的实现异步加载。</p></blockquote><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><p>关于异步组件有以下几个点需要了解和注意</p><ol><li>异步组件在首次加载完成后，会被缓存起来，不会在多次使用时被反复加载。</li><li>在多个页面使用同一个异步组件也不会被多次加载，同样会使用缓存。</li><li>在异步组件中嵌套异步组件，可能会由于组件的延迟加载造成页面的闪烁现象。</li><li>如果在同一个页面使用太多异步组件，页面在加载时会产生过多的<code>http</code>请求，从而导致页面加载过慢且出现各组件参差不齐的渲染效果。</li></ol><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十二）：动态组件</title>
      <link href="/2018/04/21/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/"/>
      <url>/2018/04/21/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%BA%8C/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在实际开发中，我们会遇到很多两个或多个组件互相切换显示的情况，最常见的如多个标签页之间的互相切换，列表展示页和列表详情页的互相切换等。</p><p>在特定情况下，为了提高页面性能，降低渲染消耗，我们并不想在每次离开一个组件时就销毁它，然后在进入时再重新请求数据和渲染它。我们希望将组件缓存起来，在再次使用时能够直接使用而不必再去新建组件的相关内容。</p><p>此时就需要使用到<code>Vue</code>的动态组件。本篇博客就主要是介绍<code>Vue</code>的动态组件。</p></blockquote><a id="more"></a><h3 id="组件的切换"><a href="#组件的切换" class="headerlink" title="组件的切换"></a>组件的切换</h3><p>如下代码所示，在组件的挂载点使用 <code>&lt;component&gt;</code>元素，并通过它的<code>is</code>特性，可以实现在同一个挂载点上动态切换多个组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComp"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        currentComp: <span class="string">'tab_one'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        tab_one:&#123;<span class="comment">/*组件选项*/</span>&#125;，</span><br><span class="line">        tab_two:&#123;<span class="comment">/*组件选项*/</span>&#125;，</span><br><span class="line">        tab_three:&#123;<span class="comment">/*组件选项*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// is 可以接受一个组件名，也可以接受一个组件对象，因此以上代码还可以写成如下形式：</span></span><br><span class="line"><span class="keyword">var</span> tab_one=&#123;<span class="comment">/*组件选项*/</span>&#125;</span><br><span class="line"><span class="keyword">var</span> tab_two=&#123;<span class="comment">/*组件选项*/</span>&#125;</span><br><span class="line"><span class="keyword">var</span> tab_three=&#123;<span class="comment">/*组件选项*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        currentComp: tab_one,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以通过以上方法来实现动态组件，但问题是，每次切换组件时，切换到的组件都会被重新渲染，就算前面加载过这个组件，它的状态和内容也并不会被保留。</p><p><code>Vue</code>的内置组件<code>keep-alive</code>就是用于解决这个问题的。</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><strong><em>keep-alive</em></strong></h3><p><code>keep-alive</code> 是 <code>Vue</code>的一个内置组件，它的作用就是在组件切换过程中，将组件的状态保存在内存中，从而避免重复渲染，提高页面性能。</p><p>它的使用很简单，只需要包裹在动态组件外部即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentCopm"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>被<code>keep-alive</code>包裹的动态组件，会在不活动状态时被缓存，而不是直接销毁。</p><p>因此在<code>keep-alive</code>中的组件，会有两个新的生命周期函数：</p><ul><li><strong><em>activated</em></strong> 组件被激活时此生命周期函数被调用</li><li><strong><em>deactivated</em></strong> 组件进入不活动状态时此生命周期函数被调用</li></ul><p>另外对于<code>keep-alive</code>有以下几点需要注意：</p><ol><li><code>Vue</code> 内部会将<code>DOM</code>节点抽象成一个个 <code>VNode</code>节点，所以 <code>keep-alive</code>的缓存也是基于<code>VNode</code>节点的。它会把<code>VNode</code>节点保存在<code>this.cache</code>中，在需要时根据其<code>name</code>取出并进行渲染。</li><li><code>keep-alive</code> 在很多情况下包裹的都是路由出口组件<code>router-view</code>，由于牵扯到<code>vue-router</code>且多数的情况比较复杂，将在后续的<code>vue-router</code>相关博客中进行详细解读。</li></ol><h4 id="include-和-exclude"><a href="#include-和-exclude" class="headerlink" title="include 和 exclude"></a><strong><em>include 和 exclude</em></strong></h4><p><strong><em>Vue 2.1.0</em></strong>新增的这两个<code>keep-alive</code>组件的属性<code>include</code>和<code>exclude</code>，允许我们有条件的对组件进行缓存。这两个属性都可以接受 <strong><em>逗号分割字符串</em></strong>，<strong><em>正则表达式</em></strong>，或<strong><em>数组</em></strong>作为其值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--逗号分割字符串--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--正则表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"/a|b/"</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"['a','b']"</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态组件"><a href="#静态组件" class="headerlink" title="静态组件"></a>静态组件</h3><p>在组件中包含大量<strong><em>静态内容</em></strong>时，可以使用 <code>v-once</code> 将渲染结果缓存起来。从而加快页面渲染速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">        a lot of things</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之Promise</title>
      <link href="/2018/04/20/ES6%E4%B9%8BPromise/"/>
      <url>/2018/04/20/ES6%E4%B9%8BPromise/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>随着<code>JS</code>在服务端的发展（例如<code>Node</code>），在处理数据库事务，操作文件等需要异步操作的地方，回调函数的缺点随着异步操作的复杂越来越明显，使用回调函数也越来越难以满足开发需要。</p><p>为了解决回调函数的种种缺点，使包含异步操作的代码更简洁和具有可读性，ES6提出了<code>Promise</code>的实现。</p></blockquote><a id="more"></a><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>为了不在进行表单检查，操作<code>DOM</code>等情况时阻塞页面，<code>JS</code>包含了大量的异步操作，随之诞生的就是回调函数。</p><p>回调函数是<code>JavaScript</code>中约定的一个俗称，指那些需要异步操作完成后才会进行调用的函数。主要用在那些需要花费时间，但又不能一直阻塞代码执行的情况，例如<code>Ajax</code> 和 <code>File</code>操作。</p><p>我们常见的<code>jQuery</code>库中的<code>ajax</code>相关<em>API</em>就是回调函数应用的一个比较显著的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'ajax/test.html'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> somehtml =data;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在上面代码中，ajax请求就是一个需要耗费时间的操作。</span></span><br><span class="line"><span class="comment">//我们通过回调函数，来在这个操作完成后，进行相应的处理，却不阻塞代码的继续运行。</span></span><br></pre></td></tr></table></figure><p>但是回调函数也存在以下的一些缺点:</p><ul><li>著名的 <strong><em>callback hell</em></strong> 回调地狱，在进行多个顺序依赖的异步操作时，很多个回调函数，一层层嵌套，导致代码可读性极低，不利于阅读和维护。</li><li>调用函数和回调函数并不会在同一个堆栈中运行，这会导致我们无法对回调函数内部发生的异常进行<code>try-catch</code>和准确定位，无法使用<code>throw</code>抛出异常，无法使用<code>return</code>终止函数的调用等问题。</li><li>回调函数使用了<code>JS</code>闭包，在比较复杂的项目环境时，容易出现变量污染等难以定位和调试的问题</li></ul><p>正是由于回调函数的这些缺点，<code>Promise</code>应运而生。</p><h3 id="promise的创建和使用"><a href="#promise的创建和使用" class="headerlink" title="promise的创建和使用"></a><code>promise</code>的创建和使用</h3><p>在<code>ES6</code>中被实现的<code>Promise</code>，主要用途就是进行异步计算，通过将异步操作队列化，使其按我们期望的顺序执行，并返回我们期望的结果。</p><h4 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建<code>promise</code>对象</h4><p>我们可以通过<code>Promise</code>这个原生构造函数来创建一个<code>promise</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//....异步操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*success*/</span>)&#123;</span><br><span class="line">       <span class="comment">//...执行代码</span></span><br><span class="line">       resolve(result)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//...执行代码</span></span><br><span class="line">       reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>构造函数<code>Promise</code>接受一个函数作为参数，这个函数有两个参数<code>resolve</code>和<code>reject</code>（可省略），这两个参数都是<code>Promise</code>对象的方法。</p><p>使用<code>new Promise()</code> 创建的<code>promise</code>对象有三个状态：</p><ul><li><strong><em>Pending</em></strong> <code>promise</code>对象刚被创建后的初始状态</li><li><strong><em>Fullfilled</em></strong> 异步操作成功状态，可使用<code>resolve</code>方法将<code>promise</code>置为此状态并将异步操作的结果传递出去</li><li><strong><em>Rejected</em></strong> 异步操作失败状态，可使用<code>reject</code>方法将<code>promise</code>置为此状态并将异步操作的错误传递出去</li></ul><p><em><code>promise</code></em>的状态改变是不可逆的，也就是说，从初始化状态 <strong><em>Pending</em></strong> 转换为 <strong><em>Fullfilled</em></strong> 或 <strong><em>Rejected</em></strong> 后，<code>promise</code>的状态就不会再改变了。</p><h4 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then()"></a><code>promise.then()</code></h4><p>在<code>Promise</code>对象的的创建中我们提到通过<code>resolve</code>方法传递结果和通过<code>reject</code>方法传递错误，那想要接收这些结果和错误，就需要用到<code>promise</code>对象的<code>then()</code>方法了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled,onRejected)</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个参数均为可选参数，可选择只传入任意一个</span></span><br><span class="line">promise.then(onFulfilled)</span><br><span class="line">promise.then(undefine,onRejected)</span><br></pre></td></tr></table></figure><p><code>.then</code>接受两个函数作为参数。这两个函数参数都是可选的。</p><ul><li><code>onFulfilled</code>在<code>promise</code>对象通过<code>resolve</code>将状态置为<code>Fulfilled</code>时会被调用，接受<code>resolve</code>传递过来的结果作为函数参数。</li><li><code>onRejected</code>在<code>promise</code>对象通过<code>reject</code>将状态置为<code>Rejected</code>时会被调用，接受<code>reject</code>传递过来的错误作为函数参数。</li></ul><p><code>.then</code>的参数函数的<strong>显式返回值</strong>会被包装为一个同样具有<code>.then</code>方法的新的<code>promise</code>对象，下一个<code>.then</code> 的<code>onFulfilled</code>和<code>onRejected</code>针对这个<code>promise</code>对象遵循相同的调用方式，从而实现<code>.then</code>的链式调用。</p><blockquote><p>使用<code>.then</code> 来进行异常处理时，可使用<code>promise.then(undefine,onRejected)</code>，只指定<code>reject</code>时的处理函数。</p><p>但其实更好的办法是使用<code>promise.catch(onRejected)</code> 这个专门用于处理异常的<code>promise</code>方法。它的优势在于在链式调用<code>.then</code>时，它可以捕捉到前面所有<code>then</code>中传递出的异常。</p><p>但要注意的是，除非<code>.then()</code> 和 <code>.catch()</code>内部抛出异常或使用了<code>rejecte()</code>将状态置为<code>rejected</code>，他们都会返回<code>Fulfilled</code>态的<code>promise</code>对象。</p></blockquote><h4 id="一个Promise的基本例子"><a href="#一个Promise的基本例子" class="headerlink" title="一个Promise的基本例子"></a>一个<code>Promise</code>的基本例子</h4><p>我们通过使用<code>promise</code>来实现一个类似<strong><em>jQuery</em></strong><code>$.get()</code>的函数，从而对以上介绍能有更直观的认识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">'GET'</span>,url,<span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(req.status === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="comment">//当请求成功时调用 resolve来将结果传递出去</span></span><br><span class="line">                resolve(req.responseText)</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当请求结果跟预期不符时使用 reject 传递一个错误</span></span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//当请求发生错误时同样使用 reject 传递一个错误</span></span><br><span class="line">        req.onerror = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText))</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">"http://someaddress.com/get"</span></span><br><span class="line"><span class="comment">//使用 .then 来接受包裹了异步操作的 promise 对象所传递出的结果</span></span><br><span class="line">getUrl(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">resolve_value</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//为了方便理解我们把函数命名为 onFulfilled</span></span><br><span class="line">    <span class="comment">//请求成功时传递的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(resolve_value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">reject_error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//为了方便理解我们把函数命名为 onRejected</span></span><br><span class="line">    <span class="comment">//请求失败时传递的错误</span></span><br><span class="line">    <span class="built_in">console</span>.error(reject_error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上的介绍和代码，我们就知道了<code>promise</code>的基本使用方法：</p><ul><li>使用 <code>new Promise</code> 创建<code>promise</code>对象，使用<code>resolve</code>和<code>reject</code>传递异步结果。</li><li>使用 <code>.then</code> 或 <code>.catch</code> 对<code>promise</code>对象传递出的结果进行处理。</li></ul><h3 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a><code>Promise</code>的静态方法</h3><p><code>Promise</code> 提供了几个静态方法，用于辅助我们使用<code>Promise</code>。</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><strong><em>Promise.resolve()</em></strong></h4><p><code>Promise.resolve()</code>也是用于创建一个<code>promise</code>对象，可以认为是如下形式的<code>new Promise()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'200'</span>)</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'200'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于<code>Promise.resolve()</code>，它总是返回一个<code>promise</code>对象，并且会将<code>promise</code>对象立刻置为<code>resolved</code>状态（除非解析发生错误或传入了状态为<code>rejected</code>的<code>promise</code>对象），进而触发后续<code>then()</code>中的<code>onFulfilled</code>函数。</p><p>有以下几点需要注意：</p><ul><li>如果传递给<code>Promise.resolve()</code>的参数为一个直接的值，它会把它包装为<code>promise</code>对象返回，下一个<code>.then</code>的<code>onfulfilled</code>函数会立即获得这个值，但<strong>仍然是异步的</strong>。</li><li>如果传递给 <code>Promise.resolve()</code> 的参数为一个<code>promise</code>对象，它不会做任何处理，而是直接返回传入的<code>promise</code>对象。</li><li>如果传递给<code>Promise.resolve()</code>的参数为一个具有<code>.then</code>方法的对象，它会将其包装为一个<code>promise</code>对象返回，并立即执行它的<code>then</code>方法。</li><li><code>Promise.then()</code>中的 <code>onFulfilled</code>函数的显式返回值，即是通过<code>Promise.resolve()</code>包装为<code>promise</code>对象供后续的<code>then</code>使用的。</li></ul><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a><strong><em>Promise.reject()</em></strong></h4><p>与<code>Promise.resolve()</code>类似，<code>Promise.rejct()</code>也是用于创建一个<code>promise</code>对象，可以认为是如下形式的<code>new Promise()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'错误'</span>))</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">null,reject</span>)</span>&#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'错误'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于<code>Promise.reject()</code>，它总是返回一个<code>promise</code>对象，并且会将这个<code>promise</code>对象立刻置为<code>rejected</code>状态，进而触发后续<code>then()</code>中的<code>onRejected</code>函数。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong><em>Promise.all()</em></strong></h4><p><code>Promise.all()</code>接受一个<code>promise</code>对象的数组作为参数，它会将数组中所有<code>promise</code>对象实例包装为一个新的<code>promise</code>对象。</p><p>这个新<code>promise</code>对象的状态由数组中所有<code>promise</code>对象的状态来决定。当数组中所有对象都<code>resolved</code>时，它也会转换为<code>resolved</code>状态。当数组中有一个对象转换为<code>rejected</code>状态时，它就会转换为<code>rejected</code>状态。</p><p>这个新<code>promise</code>对象的结果为传入数组中各个<code>promise</code>的结果组成的一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> promise_arr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">5</span>*x);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promise_arr).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);  <span class="comment">//[5,10,15]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<code>Promise.all()</code> 参数数组中所有<code>promise</code>对象包裹的异步操作都是并发执行的，他们的结果互不干扰互不依赖。</p><p>如果想实现队列型的异步操作，应该使用链式调用<code>.then()</code>的方式来实现。</p></blockquote><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong><em>Promise.race()</em></strong></h4><p><code>Promise.race()</code> 和 <code>Promise.all()</code>一样，也是接受一个<code>promise</code>对象的数组，将数组中的所有<code>promise</code>对象包装为一个新的<code>promise</code>对象。</p><p>但不同的是，这个新<code>promise</code>对象的状态由数组中率先发生状态变化的<code>promise</code>对象来决定(<strong><em>race</em></strong> 也就是赛跑的意思)。当数组中第一个发生状态变化的对象转换为<code>resolved</code>时，它也会转换为<code>resolved</code>状态。当数组中第一个发生状态变化的对象转换为<code>rejected</code>状态时，它也会转换为<code>rejected</code>状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(resolve,<span class="number">300</span>,<span class="string">'p1 finish'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(resolve,<span class="number">100</span>,<span class="string">'p2 finish'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(reject,<span class="number">200</span>,<span class="string">'p3 finish'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//p2 最快(很明显)</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)    <span class="comment">//p2 finshed</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);   <span class="comment">//并不会执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是， <code>Promise.race</code>在第一个promise对象改变状态之后，是不会去取消其他promise对象的执行的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是关于<code>ES6</code>中<code>Promise</code>的一些知识，在看完这篇文章之后，大家应该对<code>Promise</code>有了比较清晰的了解和认识。</p><p>但本人才疏学浅，错误和遗漏在所难免。如果想要进一步深入的学习<code>Promise</code>，为大家提供以下两个文章链接，供大家继续深入的了解和学习<code>promise</code>的相关知识：</p><ul><li><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="noopener">We have a problem with promises</a></li><li><a href="http://liubin.org/promises-book/#introduction" target="_blank" rel="noopener">Promise 迷你书(中文版)</a></li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十一）：组件的插槽</title>
      <link href="/2018/04/19/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/"/>
      <url>/2018/04/19/Vue%E7%B3%BB%E5%88%97%E5%8D%81%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>我们在组件的模板中，定义了组件的<code>HTML</code>。但在某些时候，我们可能需要在使用组件时，对组件的某些<code>HTML</code>内容，例如面板组件的填充内容，按钮组件的按钮文字等进行自定义。</p><p>也就是，我们想在使用组件时，向组件内插入一些非组件预定义的<code>HTML</code>内容。此时，就需要使用到<code>Vue</code>组件的插槽<code>slot</code>，它就是用来负责分发我们传入的这些非预定义<code>HTML</code>内容的。</p><p>本篇博客，主要就介绍了<code>Vue</code> 有关插槽的一些相关概念和要点。</p></blockquote><a id="more"></a><h3 id="插槽的使用"><a href="#插槽的使用" class="headerlink" title="插槽的使用"></a>插槽的使用</h3><p>当我们使用子组件时，向子组件中插入<code>HTML</code>内容，在子组件中未预设插槽<code>slot</code>的情况下，这些内容是不会显示的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-comp</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 默认子组件内部被插入的内容会被丢弃 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app1"</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'child-comp'</span>:&#123;</span><br><span class="line">            template:<span class="string">`&lt;button&gt;</span></span><br><span class="line"><span class="string">                        按钮文字</span></span><br><span class="line"><span class="string">                      &lt;/button&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>通过为子组件设置<code>slot</code> ，我们可以将父组件的<code>HTML</code>内容插入子组件，让其在指定位置显示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-comp</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 内容被插入到子组件slot标签的位置 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app1"</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'child-comp'</span>:&#123;</span><br><span class="line">            template:<span class="string">`&lt;button&gt;</span></span><br><span class="line"><span class="string">                        &lt;slot&gt;按钮文字&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                      &lt;/button&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件最终的<code>HTML</code>为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意以下几点：</p><ul><li><p>如果父组件向子组件插入多个并列的<code>HTML</code>标签，他们都会被替换到子组件的<code>&lt;slot&gt;</code>元素位置。</p><p>也就是相当于用插入子组件的整个内容片段，去替换子组件的<code>slot</code>标签。</p></li><li><p>父组件模板中插入到子组件中的内容，仍是属于父组件的，可以使用父组件实例中的数据，也会在父组件作用域中被编译。</p></li><li><p><code>&lt;slot&gt;</code>元素中原有的内容会被视为默认内容，在没有插入内容时显示。原有的内容跟插入内容不同的是，它属于子组件的作用域，也是在子组件的作用域中被编译。</p></li></ul></blockquote><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>对于插入内容的具体分发，为特定的插入内容指定特定的位置，就需要使用到具名插槽了。</p><p>为子组件的插槽元素<code>&lt;slot&gt;</code> 添加<code>name</code>特性，这个插槽就成为了具名插槽。</p><p>然后通过为插入内容设置 <code>slot</code> 属性值，来指定元素插入到哪个具名插槽。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-comp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>插入到header插槽中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未指定插槽名的会被默认插入到未命名的那个插槽中去<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>插入到footer插槽中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el:<span class="string">"#app1"</span>,</span><br><span class="line">       components:&#123;</span><br><span class="line">           <span class="string">'child-comp'</span>:&#123;</span><br><span class="line">               template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                           &lt;slot name="header"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                           &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                           &lt;slot name="footer"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                         &lt;div&gt;`</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>最后子组件的<code>HTML</code>如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>插入到header插槽中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>未指定插槽名的会被默认插入到未命名的那个插槽中去<span class="tag">&lt;/<span class="name">p</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>插入到footer插槽中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在使用具名插槽时，我们仍然可以设置一个匿名的插槽，供给那些未指定插入插槽名的插入内容使用。</p><p>如果没有这个匿名插槽的话，这些未指定插入位置的插入内容会被丢弃。</p></blockquote><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>通过作用域插槽，子组件可以将数据传递到父组件插入的内容中。</p><p>我们可以通过父级组件的 <code>slot-scope</code> 值，来获得子组件绑定在<code>slot</code>上的所有数据，进而就可以在插入内容上使用这些数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">child-comp</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 此种情况下，slot-scope 值为 &#123;data:222,otherData:444&#125; --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"child_prop"</span>&gt;</span>&#123;&#123;child_prop.data&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app1"</span>,</span><br><span class="line">        components:&#123;</span><br><span class="line">            <span class="string">'child-comp'</span>:&#123;</span><br><span class="line">                data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">val</span>:<span class="number">222</span>&#125;&#125;</span><br><span class="line">                template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                            &lt;slot :data="val" :other-data="val*2"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                          &lt;div&gt;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 2.5.0 版本前，<code>slot-scope</code> 只能在 <code>&lt;template&gt;</code>元素上使用。</p></blockquote><p>以上就是<code>Vue</code>插槽<code>slot</code>的一些知识，感谢阅读。*__*&amp;!</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS盒模型详解</title>
      <link href="/2018/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/12/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>CSS</code>盒模型作为前端面试中经常出现的问题，因为涉及到浏览器表现，页面布局，兼容，<code>CSS3</code>等前端多个重要领域，还是比较考验前端水平的。</p><p>在这篇博客中，对<code>CSS</code> 盒模型进行了一些介绍总结，涉及到的都是跟盒模型关系密切的一些知识点。</p></blockquote><a id="more"></a><h3 id="盒模型概述"><a href="#盒模型概述" class="headerlink" title="盒模型概述"></a>盒模型概述</h3><p>在<code>HTML</code>中，所有元素（除了图片和表单元素）都是按照盒模型（<strong><em>box model</em></strong>）的标准来进行排版和布局的。也就是说，除了内部无法再包含其他元素的图片和表单元素（这两者本质上都是作为其他内容占位符的替换元素），其他所有的<code>HTML</code>元素，如 <code>&lt;div&gt;</code> ，<code>&lt;span&gt;</code> ，<code>&lt;a&gt;</code> 元素，均相当于一个个盒子，堆叠嵌套，形成了我们看到的网页。</p><p>对应元素的每个盒子的具体表现，主要取决于元素的以下几个属性：</p><ul><li>边距<code>margin</code></li><li>边框 <code>border</code></li><li>填充 <code>padding</code></li><li>宽 <code>width</code> 和高<code>height</code></li></ul><p>元素在布局时，会根据以上几个属性来确定盒模型的宽高，即元素实际占据的宽高，从而完成布局。</p><h3 id="盒模型模式"><a href="#盒模型模式" class="headerlink" title="盒模型模式"></a>盒模型模式</h3><p>在根据以上几个属性来确定盒模型宽高时，存在两个计算标准，也可以说是两种模式。</p><p>一种是<code>W3C</code>规定的计算标准，又称为<strong>标准盒模型模式</strong>，另一种是 微软<code>IE</code> 规定的计算标准，又称为 <strong><code>IE</code>怪异盒模型模式</strong>。</p><h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h4><p><code>W3C</code>规定，元素的<code>width</code> 和 <code>height</code> 属性，表示的是元素内容 <code>content</code>的宽高，不包括元素的<code>padding</code>和 <code>border</code>。因此，在<code>W3C</code>的标准中，元素盒模型的宽高计算方式为：</p><blockquote><p>盒模型高 = 元素height + 上下padding之和 + 上下border之和 + 上下margin之和</p><p>盒模型宽 = 元素width + 左右padding之和 + 左右border之和 + 左右margin之和</p></blockquote><p>同时在标准盒模型下，元素以下各项与宽高有关的属性，控制的都是元素<code>content</code>的大小：</p><ul><li><code>height</code></li><li><code>width</code></li><li><code>min-height</code></li><li><code>min-width</code></li><li><code>max-height</code></li><li><code>max-width</code></li></ul><p>在这种模式下，元素的<code>width</code>和<code>height</code>确定时，我们对<code>padding</code>和<code>border</code>的修改，会导致盒模型的宽高相应变化，也就是元素在页面中的真实占据宽高变化。</p><h4 id="IE怪异盒模型"><a href="#IE怪异盒模型" class="headerlink" title="IE怪异盒模型"></a><code>IE</code>怪异盒模型</h4><p>由于历史遗留问题，在<code>IE</code>浏览器中，元素的<code>width</code>和<code>height</code> 在计算时，不光包括元素的<code>content</code>，还包括了元素的<code>padding</code> 和 <code>border</code>。因此，在<code>IE</code>怪异盒模型模式下，盒模型的宽高计算如下：</p><blockquote><p>盒模型高 = 元素height + 上下margin之和</p><p>盒模型宽 = 元素width + 左右margin之和</p></blockquote><p>在这种模式下，元素的<code>width</code>和<code>height</code>确定时，我们对<code>padding</code>和<code>border</code>的修改，会导致元素内容区域，也就是<code>content</code>的宽高变化，对元素在页面中的真实占据宽高没有影响。</p><h4 id="两种模式的切换"><a href="#两种模式的切换" class="headerlink" title="两种模式的切换"></a>两种模式的切换</h4><p>以上两种模式，可以通过 <code>CSS3</code>的属性 <code>box-sizing</code> 来进行切换。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标准模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE模型 */</span></span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，这种切换盒模型模式的方法，只在<code>IE8+</code> 浏览器和其他主流浏览器中被支持。</p><h3 id="引申出的问题"><a href="#引申出的问题" class="headerlink" title="引申出的问题"></a>引申出的问题</h3><h4 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h4><p>如上文所说，在<code>IE8+</code> 浏览器和其他主流浏览器中，我们可以通过<code>css3</code>属性<code>box-sizing</code> 来进行盒模型模式的切换。</p><p>但是在更早版本的<code>IE</code>浏览器中，是不支持此<code>css3</code>属性的，如果希望使用标准盒模型，可通过设置文档声明为 <code>&lt;!DOCTYPE html&gt;</code>实现，当然，此方法对所有<code>IE</code>浏览器都有效。</p><h4 id="IE怪异盒模型的应用"><a href="#IE怪异盒模型的应用" class="headerlink" title="IE怪异盒模型的应用"></a><code>IE</code>怪异盒模型的应用</h4><p>在<code>IE</code>怪异盒模型模式下，元素宽高固定时，<code>padding</code>和 <code>border</code>的改变，并不会影响到元素真实占据宽高的改变。</p><p>这在元素宽高为百分比时十分有用，例如我们想让并排的两个元素宽度各为<em>50%</em>，但又想通过设置<code>padding</code>让它们的内容靠的别那么近。如果在标准盒模型下，设置<code>padding</code>之后，元素的真实宽度就会增加，导致两元素撑破容器，无法并排显示。当然我们可以通过设置元素宽度为<em>49%</em>，<code>padding</code>为<em>1%</em>来实现，但这样非常不优雅。而此时通过设置<code>box-sizing</code>为<code>border-box</code>使用<code>IE</code>盒模型，就可以很轻松的实现我们的目的。</p><p>换句话说，<code>IE</code>盒模型的关键作用就在于此，<strong>让有<code>border</code>和 <code>padding</code>的元素，能更符合我们直觉的使用百分比宽高。</strong></p><h4 id="浏览器样式"><a href="#浏览器样式" class="headerlink" title="浏览器样式"></a>浏览器样式</h4><p>同样由于历史遗留问题，各个浏览器之间的默认样式存在一些区别，影响比较大的就是各个浏览器对元素添加的默认<code>margin</code> 和 <code>padding</code> 的尺寸大小不一，导致在各浏览器下，元素盒模型的表现不一致。</p><p>可以通过覆盖或清楚默认样式(<strong><em>css reset</em></strong>)的方法，来达到各浏览器表现一致的目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此种方法不论从效率还是bug发生概率上都不推荐使用 */</span></span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最好通过以下设定特定元素的内外边距来实现reset，安全且效率高 */</span></span><br><span class="line"> <span class="comment">/* structural elements 结构元素 */</span></span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>,</span><br><span class="line"> <span class="comment">/* list elements 列表元素 */</span></span><br><span class="line"><span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>,</span><br><span class="line"><span class="comment">/* text formatting elements 文本格式元素 */</span></span><br><span class="line"><span class="selector-tag">pre</span>, </span><br><span class="line"><span class="comment">/* form elements 表单元素 */</span></span><br><span class="line"><span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, </span><br><span class="line"><span class="comment">/* table elements 表格元素 */</span></span><br><span class="line"><span class="selector-tag">th</span>, <span class="selector-tag">td</span>  &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我总结的关于 <code>CSS</code> 盒模型的一些知识，希望对大家有所帮助。^-^。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习（三）：冒泡排序</title>
      <link href="/2018/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2018/04/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><script src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><blockquote><p>冒泡排序是最常见和简单的排序算法。</p><p>本篇博客主要介绍了冒泡排序的原理和<code>js</code>实现。同时也涉及到了基础冒泡算法的一些优化方法。</p></blockquote><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>冒泡排序<strong><em>(Bubble Sort)</em></strong>是一种经典的排序算法，它重复的走访要排序的数列，依次比较当前元素和下一个元素，如果两个元素的顺序错误就交换两个元素的顺序，直到没有元素需要交换为止。</p><p>因为最值数在排序时经由交换，像水中的泡泡冒到水面一样浮动到数列的顶端，因此称其为冒泡排序。</p><h4 id="运作过程"><a href="#运作过程" class="headerlink" title="运作过程"></a>运作过程</h4><p>根据上文冒泡排序的定义可知，冒泡排序运作的步骤如下：</p><ol><li>从第一个元素比较相邻的一对元素，如果第一个元素比第二个大，就交换它们两个。</li><li>移动到下一个元素，重复上一步骤，一直到倒数第二个元素，此时数列的最后一个元素，就会是最大值。</li><li>重复1，2 步骤一直到倒数第三个元素，此时数列的倒数第二个元素就会是数列第二大的值。</li><li>持续对越来越少的待排序元素重复以上的步骤，直到没有任何一对数字需要比较。</li></ol><p>下面是冒泡算法的一个运作过程动图，</p><p><img src="https://camo.githubusercontent.com/bc20131e2ee7ad70c06e7c71eefc04c3a3cc18a2/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313630373438333839" alt="img"></p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a><code>JS</code>实现</h3><p>根据冒泡算法的定义和运作过程，基础的冒泡算法实现过程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [ arr[j], arr[j+<span class="number">1</span>] ] = [ arr[j+<span class="number">1</span>],arr[j] ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的实现中，我们分析可得冒泡算法的时间频度<strong>(即具体执行次数)</strong>和问题规模<em>n</em> <strong>(即数组长度)</strong>的关系为</p><p><code>T(n)=(n-1)+(n-2)+(n-3)+...+1</code> , 简化表达式后，可得:$$T(n) = \frac{n^2-n}{2}$$</p><p>从而可以得出，冒泡算法的时间复杂度为 <strong>O( n<sup>2</sup> )</strong> 。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h4><p>在上面的冒泡算法<code>js</code>实现中，内层的<code>for</code>循环在每次循环时都会循环到上次结束循环减一的位置，考虑到在循环结束的位置之前可能已经存在很多顺序正确无需交换的元素，以上实现其实还有继续优化的空间。</p><p>根据冒泡算法的原理，遍历一对对相邻元素，顺序不正确的一对元素，会交换其位置，顺序正确的相邻元素不会发生交换。那么我们得出结论，<strong>一次循环中最后一次发生交换的位置，其后的所有元素一定是已排好顺序的</strong>。</p><p>那么我们可以记录每次循环中最后一次交换元素的位置，在下次循环中只需要循环到此位置即可，从而减少循环次数，优化冒泡算法，代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort_two</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=len<span class="number">-1</span>;i &gt; <span class="number">0</span>;i=pos)&#123;</span><br><span class="line">        pos = <span class="number">0</span>;        <span class="comment">//每次内层循环前将最后一次交换位置pos归0从而开始重新记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [ arr[j], arr[j+<span class="number">1</span>] ] = [ arr[j+<span class="number">1</span>],arr[j] ];</span><br><span class="line">                pos = j;  <span class="comment">//记录每次内层循环的最后交换位置。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h4><p>在上面的冒泡排序过程中，每一遍排序操作都是从头循环到尾找到一个最大值。</p><p>考虑到我们可以通过在每一遍排序中进行正向和反向两遍冒泡，从而一次得出两个最终值位于本次循环两端（一个最大一个最小），从而达到节约时间,优化算法的目的。</p><p>代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort_three</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//正向循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=len-i;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反向循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k=i;k&lt;len<span class="number">-1</span>-i;k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k]&lt;arr[k<span class="number">-1</span>])&#123;</span><br><span class="line">                [arr[k],arr[k<span class="number">-1</span>]] = [arr[k<span class="number">-1</span>],arr[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成以下更直观的形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">other_bubble_sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> right = len - <span class="number">1</span>;   <span class="comment">//排序范围右边界</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;          <span class="comment">//排序范围左边界</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//正向循环</span></span><br><span class="line">        <span class="keyword">for</span>(j = left;j&lt;right;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">//反向循环</span></span><br><span class="line">        <span class="keyword">for</span>(k = right;k&gt;left;k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k]&lt;arr[k<span class="number">-1</span>])&#123;</span><br><span class="line">                 [arr[k],arr[k<span class="number">-1</span>]] = [arr[k<span class="number">-1</span>],arr[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化三（鸡尾酒排序）"><a href="#优化三（鸡尾酒排序）" class="headerlink" title="优化三（鸡尾酒排序）"></a>优化三（鸡尾酒排序）</h4><p>自然而然的，我们可以综合使用以上两种优化方式，既从两端分别冒泡，又记录每次最后交换的位置。这样经过优化之后的冒泡排序，又称为<strong>鸡尾酒排序(<em>shaker Sort</em>)</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shaker_sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> right = len - <span class="number">1</span>;   <span class="comment">//排序范围的右边界</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;         <span class="comment">//排序范围的左边界</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        lastPosRight = <span class="number">0</span>;  <span class="comment">//正向最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">for</span>(j = left;j&lt;right;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">                lastPosRight = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = lastPosRight；</span><br><span class="line">        lastPOSLeft = len <span class="number">-1</span> ;    <span class="comment">//反向最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">for</span>(k = right;k&gt;left;k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k]&lt;arr[k<span class="number">-1</span>])&#123;</span><br><span class="line">                [arr[k],arr[k<span class="number">-1</span>]] = [arr[k<span class="number">-1</span>],arr[k]];</span><br><span class="line">                lastPosLeft = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = lastPosLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于冒泡排序算法的一些知识，谢谢阅读，希望对大家有所帮助。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习（二）：排序算法概述</title>
      <link href="/2018/04/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/04/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p>排序算法作为算法中比较常见的类型，我们在写代码时经常会遇到和使用。</p><p>此篇博客主要介绍了排序算法涉及的一些概念和常见的排序算法。</p></blockquote><a id="more"></a><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在排序算法中，在存在多个相同值项的情况下，如果在经过排序后，这些项的相对次序保持不变，则称这种排序算法是稳定的。否则称为不稳定的。</p><p>即如果 <em>a = b</em> , <em>a</em> 在 <em>b</em> 之前，如果在排序后，<em>a</em> 仍在 <em>b</em> 之前，则排序算法是稳定的。如果排序后，<em>a</em> 与 <em>b</em> 交换了位置，则称排序算法是不稳定的。</p><p>排序算法是否为稳定的是由算法的具体实现决定的。例如冒泡算法中，如果将比较条件修改为<code>a[j] &gt;= a[j+1]</code>，则此时的冒泡算法就成为了不稳定的排序算法。</p><p>当然，在数据的顺序没有什么特殊意义时，考虑算法稳定性其实也没什么意义。</p><h4 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h4><p><strong>内排序：</strong>即所有排序操作都在内存中完成的排序算法。</p><p><strong>外排序：</strong>在数据量比较大的情况下，将数据放在磁盘中。在排序时需要磁盘和内存的数据传输。</p><h4 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h4><p>常见的排序算法共有十种，关于它们的相关信息如下表所示：</p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center"><em>O(n)</em></td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center">O(n²)</td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n²)</td><td style="text-align:center"><em>O(n)</em></td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n²)</em></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log²n)</em></td><td style="text-align:center"><em>O(n log²n)</em></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center"><em>O(n log n)</em></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center"><em>O(n + k)</em></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><em>O(n × k)</em></td><td style="text-align:center"><em>O(n × k)</em></td><td style="text-align:center"><em>O(n × k)</em></td><td style="text-align:center">稳定</td></tr></tbody></table><blockquote><p>其中时间复杂度中的 <em>k</em> ，代表的是 “ 桶 “的个数。</p></blockquote><p>此篇博客仅对排序算法做了最基本的说明。每种排序算法的具体原理和详细的语言层面实现，将在后续算法学习相关博客中进行详细介绍。</p><p>同时在这里推荐两个可视化排序算法的网站，可以通过动画的形式，对各个排序算法有一个直观的了解。</p><ul><li><a href="http://www.webhek.com/post/comparison-sort.html" target="_blank" rel="noopener">排序算法可视化网站1</a></li><li><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">排序算法可视化网站2</a></li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习（一）：时间复杂度</title>
      <link href="/2018/04/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/04/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p>时间复杂度，在衡量算法效率时，经常被提及。</p><p>作为衡量算法效率的重要指标，我们需要对时间复杂度有一个更清晰和系统的认识。</p><p>本文主要介绍了时间复杂度的含义及其的计算方法。</p></blockquote><a id="more"></a><h3 id="算法基本概念"><a href="#算法基本概念" class="headerlink" title="算法基本概念"></a>算法基本概念</h3><p>一个算法的效率主要从两方面来衡量，即<strong>执行所需的时间长短</strong>和<strong>所需的存储空间大小</strong>。也就是算法中的两个复杂度：</p><ul><li><strong>时间复杂度</strong>：评估执行程序所需的时间，可以估算出程序对<strong>处理器</strong>的使用程度。</li><li><strong>空间复杂度</strong>：评估执行程序所需的存储空间，可以估算出程序对<strong>计算机内存</strong>的使用程度。</li></ul><p>在算法的效率研究中，因为时间复杂度比空间复杂度更容易产生问题。因此主要研究的是时间复杂度，在不特别说明的情况下，算法的复杂度通常是指算法的时间复杂度。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比。可将<strong>算法中的语句执行次数</strong>称为<strong>时间频度</strong>或<strong>语句频度</strong>。记为<code>T(n)</code>。其中<code>n</code> 为问题的规模，类似需要排序的数组的长度，需要查询的元素的多少等。</p><p>当<code>n</code>不断变化时，时间频度<code>T(n)</code>也不断变化。也就是说时间频度<code>T(n)</code>是关于问题规模<code>n</code>的一个函数。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>为了呈现时间频度<code>T(n)</code>随问题规模<code>n</code>的变化而变化时呈现出的规律，引入了<strong>时间复杂度</strong>的概念。</p><p>若存在某个辅助函数<code>f(n)</code>，使得当<code>n</code>趋近于无穷大时，<code>T(n)/f(n)</code>的极限值为不为0的常数，则称<code>f(n)</code>为<code>T(n)</code>的同数量级函数（最高阶数相同）。而此时有<code>T(n)=O(f(n))</code>,将<code>O(f(n))</code>称为算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度。</strong>表示随着问题规模<code>n</code>的增大，算法执行所需要的时间的增长可以用<code>O(f(n))</code>表示。</p><blockquote><p>在判断<code>f(n)</code>函数随<code>n</code>的变化而变化的规律时，最好和最准确的方法当然是求出函数的一阶导数。但在算法上，因为只需要大体了解算法的优劣即可，因此可以直接考虑<code>f(n)</code>函数中对增长速度影响最大的一项，即函数的<strong>最高阶数</strong>来评估算法的优劣。大O符号<code>O()</code>就是这样一种运算符号，作用为去除其他低阶项和与最高阶项相乘的常数，只保留最高阶项。</p></blockquote><h4 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h4><p>计算时间复杂度时，根据<code>O(f(n))</code>的定义，可得，<code>f(n)</code>去掉低阶项和最高阶项的常数后，即可得出时间复杂度。一般最高阶项可能值如下：</p><ul><li>常数阶<code>O(1)</code></li><li>线性阶<code>O(n)</code></li><li>平方阶 <code>O(n²)</code></li><li>平方根阶 <code>O(√n)</code></li><li>立方阶 <code>O(n³)</code></li><li>对数阶 <code>O(logn)</code></li><li>指数阶 <code>O(2ⁿ)</code></li><li>线性对数阶 <code>O(nlogn)</code></li><li>阶乘阶 <code>O(n!)</code></li></ul><p>各阶数下时间频度和问题规模的曲线如下：</p><p><img src="https://img.catqu.com/images/2018/04/13/19f1e1491f5294a2.jpg" alt="图1"></p><p>常用时间复杂度按照所需时间从小到大排序为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（十）：组件的自定义事件</title>
      <link href="/2018/03/29/Vue%E7%B3%BB%E5%88%97%E5%8D%81/"/>
      <url>/2018/03/29/Vue%E7%B3%BB%E5%88%97%E5%8D%81/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在前面的博客中介绍<code>Vue</code>组件时，我们提及到<code>Vue</code> 父子组件间的通信方式主要有两种：<code>Prop</code> 和 事件。</p><p>这篇博客中，主要介绍的就是后一种方式 —— 子组件通过自定义事件，向父组件传递信息。</p></blockquote><a id="more"></a><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>子组件通过 <code>$emit</code> 触发事件，父组件通过 <code>v-on</code> 指令来监听子组件的事件，达到子组件向父组件传递信息的目的。</p><p>子组件触发的事件，可以携带相应参数。</p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件实例中</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'someEvent'</span>, val)</span><br></pre></td></tr></table></figure><blockquote><ul><li>父组件只能通过在模板中使用<code>v-on</code>指令来绑定子组件的事件监听，不能使用<code>$on</code>。因为<code>$on</code>只能监听当前实例上<code>$emit</code>触发的事件。</li></ul></blockquote><h3 id="绑定原生事件到组件"><a href="#绑定原生事件到组件" class="headerlink" title="绑定原生事件到组件"></a>绑定原生事件到组件</h3><p>如果父组件想将监听绑定到子组件模板的<strong><em>原生事件</em></strong>，而不是自定义事件，可以使用 <code>.native</code> 修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-on:click.native</span>=<span class="string">"doSomeThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但<code>.native</code>修饰符只能监听子组件根元素上的原生事件。</p><p>如果需要监听子组件特定元素而非根元素的原生事件，可以使用实例的<code>$listeners</code>属性来将父组件中的事件监听绑定到特定的元素上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component('my-comp',&#123;</span><br><span class="line">    template:`</span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on</span>=<span class="string">"$listeners"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父模板中,会将此事件监听器绑定到input上，而不是label上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-on:input</span>=<span class="string">"handler"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>$listeners</code>包含了父作用域中绑定到子组件的 (不含 <code>.native</code> 修饰器的) 所有<code>v-on</code> 事件监听器。</p></blockquote><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a><code>.sync</code> 修饰符</h3><p>在<a href="https://gyufei.github.io/2018/02/24/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/#dxsjl" target="_blank" rel="noopener">上篇博客</a>我们说过<strong>单向数据流</strong>的概念，父组件传递到子组件的<code>prop</code>是单向绑定的，子组件对<code>prop</code>的修改并不会影响到父组件。</p><p>但有时我们需要对<code>prop</code>进行一个双向绑定。此时比较<code>Vue</code>的实现方式是通过子组件的事件将<code>prop</code>的变化传递到父组件，让父组件同步改变数据，从而达到双向绑定的目的。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绑定父组件的数据到prop，并在其改变时通过事件通知父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$emit('aPropChange',aProp++)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件模板中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 监听子组件的prop改变事件，在其改变时也改变父组件中的数据状态，从而达到双向绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:aProp</span>=<span class="string">"parentData"</span> @<span class="attr">aPropChange</span>=<span class="string">"parentData++"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.sync</code> 修饰符就是应用在这种场景下。在为子组件绑定父组件数据源时，使用此修饰符来使数据源也能自动同步子组件的变化。如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:aProp.sync</span>=<span class="string">"parentData"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>但需要注意的时，其实<code>.sync</code>修饰符只是我们上面实现双向绑定方式的语法糖。它只是<strong>自动的为父组件添加了一个<code>update</code>事件侦听器</strong>，用来响应子组件的<code>prop</code>变化。即以上的代码其实等价于如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:aProp</span>=<span class="string">"parentData"</span> @<span class="attr">update:aProp</span>=<span class="string">"childVal=&gt; parentData = childVal"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件在更新 <code>prop</code>值时，需要<strong>显式</strong>的触发<code>update</code>事件，从而完成双向绑定。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$emit('update:aProp',aProp++)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>v-bind</code>中，我们提到过绑定数据源到对象时可以使用直接绑定的方式，在这种情况下，<code>.sync</code>修饰符也是可以后缀使用的。如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind.sync</span>=<span class="string">"&#123;a:1,b:2&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--但不能使用 .sync 绑定到字面量对象，是不会生效的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind.sync</span>=<span class="string">"&#123;a : obj.main&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="自定义表单输入组件"><a href="#自定义表单输入组件" class="headerlink" title="自定义表单输入组件"></a>自定义表单输入组件</h3><p>在<a href="https://gyufei.github.io/2018/02/13/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/" target="_blank" rel="noopener">Vue系列（七）：表单</a>中，我们说过，<code>v-model</code>指令的双向绑定是一个语法糖，通过以下代码我们可以清楚的认识到，<code>v-model</code>相当于将需要双向绑定的数据绑定到表单的<code>value</code>上同时在输入事件触发时更新<code>value</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"message = $event.target.value"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当 v-model 在子组件上使用时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"message = arguments[0]"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- arguments[0] 为子组件内部事件触发时携带的参数 --&gt;</span></span><br></pre></td></tr></table></figure><p>那么我们在自定义表单输入组件时，如果需要让<code>v-model</code>在组件上能够生效，也必须使我们的自定义表单输入组件满足以下两点：</p><ul><li>接受一个 <code>value</code> <em>prop</em>，让<code>v-model</code>指令可以将数据绑定在它的上面</li><li>在输入改变时触发 <code>input</code>事件来更新<code>value</code></li></ul><p>下面是一个简单的自定义表单输入组件的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父组件的模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件实例</span></span><br><span class="line">Vue.component(<span class="string">'my-input'</span>,&#123;</span><br><span class="line">    props:[<span class="string">'value'</span>],</span><br><span class="line">    template:<span class="string">`&lt;input v-bind:value="value" v-on:input="update($event.target.value)"&gt;`</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        update:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>通常情况下，<code>v-model</code>指令都是默认的绑定到表单元素的<code>value</code> <em>prop</em>上和<code>input</code>事件上，但是表单的<code>value</code>属性有时会有其他的用途，例如单选框和复选框上的<code>value</code>，我们需要将<code>v-model</code>绑定到表单的其他属性上，例如<code>checked</code>。</p><p>我们可以通过组件配置选项的<code>model</code>选项，来为<code>v-model</code>指令指定绑定的属性和事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Vue.component(<span class="string">'my-input'</span>,&#123;</span><br><span class="line">       model:&#123;</span><br><span class="line">           prop:<span class="string">'checked'</span>,</span><br><span class="line">           event:<span class="string">'change'</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       props:[checked,value],</span><br><span class="line">    &#125;) </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 此时aBool的值就会绑定到 checked 上,同时在接收到子组件emit的change事件时进行    更新aBool值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">"aBool"</span> <span class="attr">:value</span>=<span class="string">"otherThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="非父子组件之间通过事件通信"><a href="#非父子组件之间通过事件通信" class="headerlink" title="非父子组件之间通过事件通信"></a>非父子组件之间通过事件通信</h3><p>每个<code>Vue</code>实例，都实现了以下两个事件接口：</p><ul><li><code>$on(eventName,callback)</code> ，用于监听当前实例上发生的事件</li><li><code>$emit(eventName, optionalPayload)</code> ， 用于在当前实例上触发事件名为<code>eventName</code>，携带<code>optionalPayload</code>参数的事件。携带的参数会传递给事件监听器的<code>callback</code>函数。</li></ul><p><strong><em>具体看如下代码：</em></strong></p><figure class="highlight js"><figcaption><span>Vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听事件</span></span><br><span class="line">vm.$on(<span class="string">'epop'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">vm.$emit(<span class="string">'epop'</span>,<span class="string">'take msg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//=&gt; 'take msg'</span></span><br></pre></td></tr></table></figure><p>对于简单的非父子关系的组件间通信，我们可以通过一个空的<code>Vue</code>实例作为事件总线，通过这个总线实例的<code>$on</code> 和 <code>$emit</code> 事件接口，搭起两个组件间的通信桥梁。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bridge = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件A中使用空Vue实例触发事件，传递数据</span></span><br><span class="line">bridge.$emit(<span class="string">'aEvent'</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件B中使用空Vue实例监听触发的事件，接收数据</span></span><br><span class="line">bridge.$on(<span class="string">'aEvent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>在复杂的非父子关系组件通信时，上面的方法并不适用。需要使用专门的状态管理模式，例如<code>vuex</code>。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的VIM配置</title>
      <link href="/2018/03/19/%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/03/19/%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><em>VIM</em> 作为编辑器之神，历久而不衰。自己也折腾了很久，但是一直也没有对很多配置进行系统的梳理和思考。</p><p>在经过一个多月的整理和反复衡量，最终确定了我在多端下能够比较统一和方便使用<em>VIM</em>的一个配置。</p></blockquote><a id="more"></a><h4 id="我的vim配置"><a href="#我的vim配置" class="headerlink" title="我的vim配置"></a>我的<code>vim</code>配置</h4><p>在使用了数个编辑器和<em>IDE</em> 后，我最终还是选择了重回<em>VIM</em>怀抱。可能是因为前面配置<code>vim</code>时那种焦头烂额的感觉已经淡去，也可能是因为我终于决定遇见问题时沉下心来去一一解决，而不再是逃避。我打算将<code>vim</code>配置为我的终极代码编辑器，从此无论写什么，都可以以不变应万变了。</p><p>早先把<code>vim</code>当做尝鲜的编辑器去使用，所以很多重度使用时会遇到的问题都并没有亲身感觉。经过一个多月的重度使用后，各种问题解决了一大箩筐之后，也终于归纳整理出了适合我的一套<code>vim</code>配置。</p><p>在使用过程中，对于插件的添加我保持了尽量克制的态度，并没有使用太多插件。经过磨合和调试，这一套配置也已经能完全满足我的工作流要求，包括涉及到<code>js</code> ,<code>php</code>,<code>python</code>,<code>ts</code> 及<code>HTML</code>的<code>coding</code>各项需求。</p><p>经过这一个多月的大修大补的折腾，我也终于可以开心的卸载掉了包括 <em>sublime</em>，<em>vscode</em>，<em>pycharm</em>，<em>webstorm</em>等电脑上的一众 <em>IDE</em>，瞬间感觉神清气爽，四肢通畅（^-^)。</p><p>以下是我的<code>vim</code>配置，基本所有配置项都做了中文注释和相应的分类划分。需要注意的有以下几点：</p><ol><li><p>字体设置，也就是<code>set guifont</code>这一配置项在 <em>win &amp; mac</em> 上直接空格分割字体，字号就行，但在 <em>linux</em>上，需要使用<code>\</code> 对空格进行转义。类似<code>set guifont=Nimbus\ Mono\ L\ 14</code></p></li><li><p><em>YouCompleteMe</em> 补全插件需要自行编译，编译的步骤百度或<em>google</em>即可。对于各种语言的补全，此插件有相应的方案和配置，在需要时可以搜索相关教程进行修改和拓展。此插件属于<code>vim</code>的灵魂插件之一。</p></li><li><p><code>ALE</code>语法检查插件类似于早先的<em>synatic</em>，但比其在性能上更有优势且使用较为简单。需要安装语法检查相应的组件环境，例如检查<code>js</code>需要安装<code>eslint</code>，检查<code>python</code>需要安装<code>flake8</code>，这个插件是<code>vim</code>以不变应万变的依靠之一。</p></li><li><p>tern-for-vim插件</p><p>安装后需要进入插件目录执行 npm install，并且需要在 用户主目录下 创建 配置文件 .ts-confi</p></li><li><p>ALE 语法检查插件</p></li></ol><p>​ eslint 的语法检查配置需要在主目录下拷贝一份 规则文件这样所有的 js 文件都可以通过这份规则文件进行语法检查。</p><ol start="6"><li><p>ag全局查找插件</p><p>需要在命令行安装</p></li></ol><p>ps：在vim的使用过程中，我也在不断调整和优化我的.vimrc文件，因此就不再在下面贴出我的vim配置了。</p><p><del>为了保证此篇博客能跟随我的.vimrc文件的更新，这里就只提供一个我的.vimrc文件的链接，以便能够使大家追踪到我的最新配置。</del></p><p>2018-7-20: 将<code>.vimrc</code>文件进行了拆分模块化，不在放到根目录下，而是移动到<code>.vim</code>中，便于进行版本管理，同时也方便增删和修改。</p><p><a href="https://github.com/Gyufei/MyVimrc" target="_blank" rel="noopener">我的vim配置</a></p><p>另外，推荐一个vim插件网站，上面几乎收集了市面上所有常用的vim插件，在想要为vim添加新功能而搜寻插件时，十分有用。</p><p><a href="https://vimawesome.com/" target="_blank" rel="noopener">vimawesome</a></p><p>如果你在vim使用中遇到了什么问题，也十分欢迎你给我留言，一起来探讨和解决。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（九）：组件的Prop</title>
      <link href="/2018/02/24/Vue%E7%B3%BB%E5%88%97%E4%B9%9D/"/>
      <url>/2018/02/24/Vue%E7%B3%BB%E5%88%97%E4%B9%9D/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在前面的博客中介绍<code>Vue</code>组件时，我们提及到<code>Vue</code> 父子组件间的通信方式主要有两种：<code>Prop</code> 和 事件。</p><p>这篇博客中，主要介绍的就是前一种方式 —— 父组件通过<code>props</code>，向子组件传递数据。</p></blockquote><h3 id="Prop的使用"><a href="#Prop的使用" class="headerlink" title="Prop的使用"></a><code>Prop</code>的使用</h3><p>因为组件作用域的互相隔离，在子组件的模板中是无法直接引用父组件中的数据的。父组件需要通过 <code>prop</code> 才能将数据下发到子组件中。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>在子组件中，需要显式的使用 <code>props</code> 选项来声明它需要从<strong>处于父组件作用域的模板中</strong>获取的<code>prop</code>数据。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">    <span class="comment">//声明 props</span></span><br><span class="line">    props:[<span class="string">'myText'</span>],</span><br><span class="line">    <span class="comment">//在模板中，可以像在 data 中一样使用 props 中声明过的 prop </span></span><br><span class="line">    template:<span class="string">'&lt;h1&gt;&#123;&#123; myText &#125;&#125;&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在使用的不是<em>字符串模板</em> 而是 <em>HTML模板</em> 时，需要注意 <em>HTML</em> 不区分大小写的特性，因此要将驼峰命名的 <code>prop</code> 在模板中使用时转换为对应的短横线分割形式的命名。形如<code>&lt;child my-text=&quot;sometext&quot;&gt;&lt;child&gt;</code></p></blockquote><h4 id="绑定到字符串"><a href="#绑定到字符串" class="headerlink" title="绑定到字符串"></a>绑定到字符串</h4><p>当在父组件的模板中使用上面声明的子组件时，可向<code>prop</code> 传入一个普通字符串值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">text</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最终渲染DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="绑定到js表达式"><a href="#绑定到js表达式" class="headerlink" title="绑定到js表达式"></a>绑定到<code>js</code>表达式</h4><p>可以使用<code>v-bind</code> 指令将 <code>prop</code> 绑定到 <code>js</code> 表达式上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:text</span>=<span class="string">"1+1+1"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最终渲染DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态绑定到父组件数据"><a href="#动态绑定到父组件数据" class="headerlink" title="动态绑定到父组件数据"></a>动态绑定到父组件数据</h4><p>可以使用 <code>v-bind</code> 指令将 <code>props</code> 动态的绑定到父组件的数据上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- vue实例HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentText"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:text</span>=<span class="string">"parentText"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>Vue实例：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app1'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        parentMsg:<span class="string">'text from parent'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>可以为组件的<code>prop</code> 指定验证规则，在传入的数据不符合要求时，<code>Vue</code>会发出警告。在开发给他人使用的组件时非常有用。</p><p>在为 <code>prop</code> 指定规则时，不能再使用字符串数组来定义<code>props</code>，而需要使用对象的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        <span class="comment">//基础类型检测</span></span><br><span class="line">        propA:<span class="built_in">Number</span>,</span><br><span class="line">        <span class="comment">//多种类型检测</span></span><br><span class="line">        propB:[<span class="built_in">String</span>,<span class="built_in">Number</span>],</span><br><span class="line">        <span class="comment">//限定类型的必传值</span></span><br><span class="line">        propC:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            required:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//限定类型且有默认值</span></span><br><span class="line">        propD:&#123;</span><br><span class="line">            type:<span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="number">100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//限定类型且使用函数返回默认值（数组和对象需要使用此种方法）</span></span><br><span class="line">        propE:&#123;</span><br><span class="line">            type：<span class="built_in">Object</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">massage</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//自定义验证函数</span></span><br><span class="line">        propF:&#123;</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ol><li>当类型为<code>null</code>时，指允许任何类型</li><li><code>type</code>可以是 <code>js</code> 的原生构造器，也可以是自定义构造器函数，在检测类型时会调用 <code>instanceof</code> 检测。</li><li>检测发生在组件实例构造前，因此无法在<code>default</code>或<code>validator</code>函数中使用组件实例的其他属性。</li></ol></blockquote><p><span id="dxsjl"></span></p><h4 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h4><p>父组件数据到 <code>prop</code> 的动态绑定是单向的。也就是说，父组件的数据变化会传递到子组件，但反向不会。</p><p>为了防止破坏这种<strong>单向数据流</strong>，造成数据状态的混乱和不一致，在子组件中不应该去改变<code>prop</code>的值，<code>vue</code>也会对这种行为做出警告。</p><p>子组件需要修改 <code>prop</code> 的情况主要有以下两种：</p><ol><li><p>将 <code>prop</code> 当做初始值传入，作为子组件的局部数据来使用，不需要再响应 <code>prop</code> 的变化。</p><p>这种情况下，可以定义一个组件的局部变量，并使用 prop 作为初始值初始化这个组件的局部变量，后续对局部变量的操作都与 <code>prop</code> 无关。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">'initdata'</span>],</span><br><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">counter</span>:<span class="keyword">this</span>.initdata&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子组件需要对<code>prop</code> 原始值做一些处理后再使用</p><p>这种情况下，可以定义一个计算属性，从而能够响应<code>prop</code>的变化并进行相应处理又不影响到父组件的原始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props:[<span class="string">'text'</span>],</span><br><span class="line">computed:&#123;</span><br><span class="line">    childText:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text.trim().toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>但需要注意的是，在以上两种情况下，如果 <code>prop</code> 为 <code>js</code>引用类型的数据，例如对象或数组，在子组件内改变它是会同时影响到父组件的状态的，此时可以考虑使用<strong>深拷贝</strong>等手段来保证单向的数据流。</p></blockquote><h3 id="非Prop-特性"><a href="#非Prop-特性" class="headerlink" title="非Prop 特性"></a>非<code>Prop</code> 特性</h3><p>为了给予组件接收数据更大的自由度，以应对组件被使用的各种场景。<code>Vue</code>的组件可以接收传入的任意特性，这些特性都会被添加到<strong>组件的根元素</strong>上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-input</span> <span class="attr">data-scroll-bar-show</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">bs-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>添加<code>data-scroll-bar-show=&quot;true&quot;</code>属性后，它会自动出现在组件的根元素上。</p></blockquote><h4 id="非prop特性的覆盖和合并"><a href="#非prop特性的覆盖和合并" class="headerlink" title="非prop特性的覆盖和合并"></a>非<code>prop</code>特性的覆盖和合并</h4><p>对于组件的大多数特性来说，传递给组件的特性值都会覆盖掉组件自身的设定值。</p><p>例外的是<code>class</code> 和 <code>Style</code> ，组件在对待这两个特性时，会采取<strong>合并(<em>merge</em>)</strong>的策略，将传入的特性值和组件自身的特性值进行合并操作。</p><h4 id="禁用特性的继承"><a href="#禁用特性的继承" class="headerlink" title="禁用特性的继承"></a>禁用特性的继承</h4><p>如果不希望父组件传递给子组件的非<code>prop</code>特性被子组件的根元素继承，可以在组件选项中设置<code>inheritAttrs:false</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    inheritAttrs:<span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时，可以通过实例的<code>$attrs</code>属性，来将这些非<code>prop</code>特性绑定到需要绑定的元素上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的非prop特性会绑定到input元素上，而不是默认的根元素label上</span></span><br><span class="line">Vue.component(<span class="string">'my-input'</span>,&#123;</span><br><span class="line">    inheritAttrs:<span class="literal">false</span>,</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &lt;input v-bind="$attrs"&gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件模板中，会将placeholder绑定到input元素上，而不是label元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">placeholdr</span>=<span class="string">"请输入"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>实例的<code>$attrs</code> 属性，包含了父组件作用域中除了<code>class</code>和<code>style</code>的其他所有非<code>prop</code>特性绑定。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（八）：组件的使用</title>
      <link href="/2018/02/17/Vue%E7%B3%BB%E5%88%97%E5%85%AB/"/>
      <url>/2018/02/17/Vue%E7%B3%BB%E5%88%97%E5%85%AB/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>组件作为<code>Vue</code>的灵魂功能，为前端开发提供了更大的空间和可能。</p><p>本篇博客主要介绍<code>Vue</code>组件的核心概念和使用方法。</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29724295&auto=0&height=66"></iframe><h3 id="组件简介"><a href="#组件简介" class="headerlink" title="组件简介"></a>组件简介</h3><p>组件是 <code>Vue.js</code> 最为强大的功能之一。它相当于自定义的元素，主要作用为扩展<code>HTML</code>元素和封装可重用代码。组件也可以使用 <code>is</code> 特性来扩展原生的 <code>HTML</code>元素。</p><p>所有<code>Vue</code>组件同时也都是 <code>Vue</code> 实例，拥有和实例相同的生命周期钩子，可接受相同的选项对象（除了一些根级实例特有的选项）。</p><h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><p>组件在注册之后即可作为自定义元素在实例的模板中使用。需要注意的一点是<strong>组件必须在初始化根实例之前注册</strong>。</p><p>组件有两种注册方式，即全局注册和局部注册。</p><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>使用<code>Vue.component(tagname,options)</code> 来注册一个全局组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    <span class="comment">//组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>组件命名的推荐规则为 小写并包含一个短杠。</p></blockquote><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>组件可以局部注册在 <strong><code>Vue</code>实例或其他组件</strong>的实例选项的 <code>components</code>中，也仅在其局部注册的作用域中可用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">    template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'my-comp'</span>:child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件的模板"><a href="#组件的模板" class="headerlink" title="组件的模板"></a>组件的模板</h3><p><code>Vue</code> 中有多种方式来定义组件的模板。需要注意的一点是，在<strong>使用HTML模板</strong>时，在一些特殊的元素中使用组件可能会出现异常，例如<code>&lt;ul&gt;</code> , <code>&lt;ol&gt;</code> , <code>&lt;table&gt;</code> , <code>&lt;select&gt;</code> ,可能会出现渲染异常，需要使用 特殊的 <code>is</code> 特性来解决。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Vue</code>定义组件模板的方式主要有以下几种：</p><ul><li><p><strong>字符串模板</strong></p><p>即使用字符串格式的<code>HTML</code>，将其声明在组件的<code>template</code>属性中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    template:<span class="string">'&lt;div class="show_detail"&gt;&lt;p&gt;detail&lt;/p&gt;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此方法较难维护，唯一优点在于广泛的浏览器支持。</p></blockquote><p>另外也可以通过<code>ES6</code> 新增的<strong><em>模板字面量</em></strong>语法来定义多行模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="show_detail"&gt;</span></span><br><span class="line"><span class="string">           &lt;p&gt;detail&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>，</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此方法更易阅读，但<code>ES6</code>可能存在兼容风险。</p></blockquote></li></ul><ul><li><p><strong><code>x-templates</code></strong></p><p>在类型为<code>text/x-template</code> 的<code>script</code>标签中定义模板。在定义组件时通过<code>id</code>来引用此类型模板。</p><p><strong><em>js:</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue.component(<span class="string">'my-comp'</span>,&#123;</span><br><span class="line">    template:<span class="string">'#x-tl'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><em>html:</em></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"x-tl"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"show_detail"</span>&gt;</span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此方法可以使用真正的<code>HTML</code> 来书写模板，但会将组件的模板定义和其他定义分隔在两个地方或文件中。</p><p>需要注意，x-template 模板定义需要在<code>vue.js</code>引入前。</p></blockquote></li><li><p><strong>内联模板<code>inline template</code></strong></p><p>通过为组件的 <code>HTML</code> 添加<code>inline-template</code>来向 <code>vue</code> 声明，其中内容为模板，而不是分发内容的<code>slot</code>。</p><p><strong><em>js:</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-comp'</span>,&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong><em>html:</em></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"show_detail"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此方法的优点在于可以直接将模板放置在组件要出现的位置，所以不需要等到<code>js</code>执行就会被渲染。</p><p>缺点同样是会将组件的定义分隔在两个地方或文件中。</p></blockquote></li><li><p><strong>单文件组件</strong></p><p>单文件组件文件的文件扩展名为 <code>.vue</code> 。你可以将组件的 <code>HTML</code>，<code>JS</code>, <code>CSS</code>全部放置在此文件中，从而集中组件的所有关注点在相同的文件中。</p><p><code>.vue</code> 文件中包含三种类型的语言块。通过设置语言块的<code>lang</code>属性，可以使用非默认语言。通过配置工具的各种<code>loader</code>处理，可以将文件最终导出为一个<code>vue</code>组件对象。三种语言块的基本信息如下:</p><ul><li><p><code>&lt;template&gt;</code></p><p>默认语言为<code>HTML</code>。</p><p>每个<code>.vue</code>文件最多包含一个<code>&lt;template&gt;</code>块。其中的内容将被提取并作为<code>Vue</code>组件的<code>templates</code>选项。</p></li><li><p><code>&lt;script&gt;</code></p><p>默认语言为<code>js</code>。</p><p>每个<code>.vue</code> 文件最多包含一个 <code>&lt;script&gt;</code> 块，块中的脚本必须导出组件对象。</p></li><li><p><code>&lt;style&gt;</code></p><p>默认语言为<code>css</code> 。</p><p>每个<code>.vue</code>文件中可以包含多个<code>&lt;Style&gt;</code>块。默认会将其中的样式动态加入编译生成文件的<code>&lt;head&gt;</code> 中，也可以通过配置将其提取到单个<code>CSS</code>文件中。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"jade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"show_detail"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> otherComponent <span class="keyword">from</span> <span class="string">'./otherComponent.vue'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="undefined">        data()&#123;&#125;,</span></span><br><span class="line"><span class="undefined">        component:&#123;</span></span><br><span class="line"><span class="undefined">            otherComponent</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"stylus"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    p</span></span><br><span class="line"><span class="undefined">      font-size 2em</span></span><br><span class="line"><span class="undefined">      text-align center</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>缺点：需要使用构建工具（这真的能算缺点吗？^*^!)</p></blockquote></li><li><p><strong><code>render</code>函数和 <code>JSX</code> 语法</strong></p><p>在一些特殊的情况下，可能需要使用渲染函数<code>render</code>来生成模板，为了简化<code>render</code>函数书写，也可以引入<code>JSX</code>语法。</p></li></ul><h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的<code>data</code></h3><p>定义组件时可以使用大部分构造<code>Vue</code>实例时传入的各种选项。但需要注意的是：</p><p><strong><em>组件的 data 必须是函数</em></strong></p><p>这样在组件的复用时，才能基本保证各组件间的状态不因为引用问题而互相影响和冲突。但即使<code>data</code>为函数时，仍需要注意避免组件复用时共享到某些对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即也要避免以下情况</span></span><br><span class="line"><span class="keyword">var</span> one = &#123;<span class="attr">total</span>:<span class="number">0</span>&#125;;</span><br><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> one</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而应该使用以下写法</span></span><br><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">total</span>:<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件的关系"><a href="#组件的关系" class="headerlink" title="组件的关系"></a>组件的关系</h3><p>在组件中使用组件，即组件间为父子关系，是组件使用中常见的情况。<code>Vue</code>设置了父子组件间的两种通信方式：</p><ul><li>父组件<strong>通过<code>prop</code></strong>下发数据给子组件</li><li>子组件<strong>通过事件</strong>传递信息给父组件</li></ul><p>以上两种通信方式的具体实现和相关规则，因为篇幅原因，将放在后续两篇博客中进行详细介绍。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby 学习笔记（一）:基本语法</title>
      <link href="/2018/02/14/RUBY%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/02/14/RUBY%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>Ruby 的一些基本语法。</p><p>其实是我随手记的一些笔记。。。。。</p><p>管它呢，反正拽进博客里也算一篇。。。（逃</p></blockquote><a id="more"></a><h4 id="启动命令行解释器命令"><a href="#启动命令行解释器命令" class="headerlink" title="启动命令行解释器命令"></a>启动命令行解释器命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-      //使用中文编码</span></span><br><span class="line">puts  /<span class="regexp">/带回车换行符</span></span><br><span class="line"><span class="regexp">print /</span><span class="regexp">/不带</span></span><br></pre></td></tr></table></figure><h4 id="运行ruby文件"><a href="#运行ruby文件" class="headerlink" title="运行ruby文件"></a>运行ruby文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby hello.rb</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure><h4 id="字符串插值："><a href="#字符串插值：" class="headerlink" title="字符串插值："></a>字符串插值：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'this is a <span class="subst">#&#123;car&#125;</span>'</span>     /<span class="regexp">/只能在双引号标记的字符串中使用</span></span><br></pre></td></tr></table></figure><h4 id="格式化字符串："><a href="#格式化字符串：" class="headerlink" title="格式化字符串："></a>格式化字符串：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'this is a %s'</span> % car </span><br><span class="line"><span class="string">'this is a %s and that is a %s'</span> % [car,pen]</span><br></pre></td></tr></table></figure><h4 id="转义符号："><a href="#转义符号：" class="headerlink" title="转义符号："></a>转义符号：</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\             /<span class="regexp">/单引号字符串只允许使用 \\ 和 \'</span></span><br></pre></td></tr></table></figure><h4 id="文件语法"><a href="#文件语法" class="headerlink" title="文件语法"></a>文件语法</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&lt;&lt;SOMENAME</span></span><br><span class="line"><span class="string">this is a car;</span></span><br><span class="line"><span class="string">this is a pen</span></span><br><span class="line"><span class="string">SOMENAME</span></span><br></pre></td></tr></table></figure><h4 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prints <span class="string">"how old are you?"</span></span><br><span class="line">age = gets.chomp()  /<span class="regexp">/gets为获取输入，chomp()函数用于去掉字符串尾换行符</span></span><br><span class="line"><span class="regexp">puts "so,you're <span class="subst">#&#123;age&#125;</span> old"</span></span><br></pre></td></tr></table></figure><h4 id="BEGIN-和-END-语句"><a href="#BEGIN-和-END-语句" class="headerlink" title="BEGIN 和 END 语句"></a>BEGIN 和 END 语句</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>&#123;code&#125;     /<span class="regexp">/会在程序运行之前被调用</span></span><br><span class="line"><span class="regexp">END&#123;code&#125;/</span><span class="regexp">/会在程序结尾被调用</span></span><br></pre></td></tr></table></figure><h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> name   /<span class="regexp">/可省略后缀.rb,不会多次加载，用于加载外部库或源文件</span></span><br><span class="line"><span class="regexp">load name。    /</span><span class="regexp">/不可省略后缀，会多次加载，用于加载配置文件</span></span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>数字类型NUMBER</strong></p><ul><li>整型 Integer<ul><li>Fixnum 类 Fixnum 的对象<ul><li>Bignum 类 Bignum 的对象</li></ul></li></ul></li><li>浮点型 Float 类 Float 的 对象</li></ul><blockquote><p>前导符号：0开头为八进制，0x为十六进制，0b二进制</p><p>下划线在数字中被忽略</p><p>加减乘除 + - * /</p><p>指数 **</p></blockquote><p><strong>字符串类型 String</strong> ( 类 String 的对象)</p><p><strong>数组类型Array</strong></p><p><strong>哈希类型 Hash</strong></p><p><strong>范围类型 Range</strong></p><p>​</p><p>​</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rails 学习笔记（二）:目录结构</title>
      <link href="/2018/02/14/Rails%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/02/14/Rails%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在初次面对一个<code>Rails</code>项目时，遇到的第一个问题就是：这一个个文件夹都是干嘛的？</p><p>本篇博客主要介绍了一个<code>Rails</code>下，各个文件夹和一些文件的用途和作用。</p></blockquote><a id="more"></a><h1 id="Rails项目下的文件夹"><a href="#Rails项目下的文件夹" class="headerlink" title="Rails项目下的文件夹"></a>Rails项目下的文件夹</h1><h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>​ <code>app</code>包含应用的控制器，模型，视图等重要部分，是 <code>rails</code>里最重要的组成部分。</p><ul><li><p><code>assets</code> 静态文件目录，主要用来存放<code>js</code>,<code>css</code>,<code>image</code></p></li><li><p><code>controllers</code> 控制器文件,包含控制器的类。所有的类都是继承自 <code>ActionController：:Base</code> 。所有的 这些文件中的每一个应该命名为它们的 <code>Model</code> 名后面加上 <code>_controller.rb</code> , 目的是 URL 能够自动匹配到它们。</p></li><li><p><code>models</code> 用来存放 model 层，数据库表结构。大多数 <code>Model</code> 类 继承自 <code>ActiveRecord::Base</code> 。</p></li><li><p><code>helpers</code> 一个<code>controllers</code> 对应一个 <code>helper</code> 文件，公共的可以放到 <code>application_helper.rb</code>。</p><p>文件中主要是一些可以使用的一些方法，主要是用来解决一些比较复杂的模板显示，不应该存</p><p>放业务代码。</p></li><li><p><code>views</code> 视图层</p></li><li><p><code>jobs</code> 用来存放任务文件</p><blockquote><p>Active Job 是用来声明任务，并把任务放到多种多样的队列后台中执行的框架。从定期地安排清理，费用账单到发送邮件，任何事情都可以是任务。任何可以切分为小的单元和并行执行的任务都可以用 Active Job 来执行。</p><p>主要是确保所有的 Rails 程序有一致任务框架，即便是以 “立即执行”的形式存在。</p></blockquote></li><li><p><code>mailers</code> 用来存放发送邮件功能的文件</p></li><li><p><code>chaannerls</code> 结合 <code>websocket</code> 来实现浏览器端实时的消息通知。</p></li></ul><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>​ 一些脚本文件，<code>bundle</code>, <code>rails</code>, <code>rake</code>, <code>setup</code>(用于初始化并启动服务), <code>spring</code>(<code>rails</code> 的预加载器，可提高启动速度) , <code>update</code>(更新数据库)</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>​ 配置应用的<strong>路由</strong>，<strong>数据库</strong>，<strong>环境变量</strong>，<strong>启动文件</strong>等一些配置文件</p><ul><li><code>environments/</code><ul><li><code>development.rb</code> 开发环境配置文件</li><li><code>production.rb</code> 生产环境配置文件</li><li><code>test.rb</code> 测试环境配置文件</li></ul></li><li><code>initializers/</code> 加载完框架及程序中使用的 gem 后，<code>rails</code> 会加载初始化脚本。初始化脚本是个 RUBY 文件，存储在此文件夹。初始化脚本可在框架和<code>gem</code> 加载完成后做设置。</li><li><code>application.rb</code> 根据不同的启动环境加载不同的 <code>rails gems</code>，配置应用程序。</li><li><code>routes.rb</code> <code>rails</code> 程序的路由文件，添加路由时需要在此文件中添加。</li><li><code>database.yml</code> 用于配置 <code>rails</code> 程序连接数据库的文件，包括连接的数据库类型，数据库连接池限制数量等。</li></ul><h2 id="db"><a href="#db" class="headerlink" title="db"></a>db</h2><p>​ 数据库迁移文件，及种子文件</p><ul><li><code>migrate／</code> 存放数据库的迁移文件，</li><li><code>schema.rb</code> 记录当前迁移的版本编号，同时匹配最新的数据库结构。</li><li><code>seeds.rb</code> 通过此文件可直接将初始化数据存入数据库。</li></ul><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><p>​ 扩展模块</p><ul><li><code>assets/</code> 放置我们使用的插件中用到的 <code>assets</code></li><li><code>tasks</code> Rake 的任务一般存放在此处。</li></ul><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>​ 日志目录</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>​ 可以从外部直接访问的文件夹</p><h2 id="spec"><a href="#spec" class="headerlink" title="spec"></a>spec</h2><pre><code>spec 测试文件目录</code></pre><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>​ test 文件测试文件目录</p><h2 id="tmp"><a href="#tmp" class="headerlink" title="tmp"></a>tmp</h2><p>​ 临时文件，如<code>server</code> 的 <code>pid</code></p><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><pre><code>第三方代码，例如    **插件** 和 `gem`。</code></pre><hr><h1 id="Rails项目下的文件"><a href="#Rails项目下的文件" class="headerlink" title="Rails项目下的文件"></a>Rails项目下的文件</h1><h2 id="config-ru"><a href="#config-ru" class="headerlink" title="config.ru"></a>config.ru</h2><p>​ rack 配置，用于启动应用</p><h2 id="Gemfile"><a href="#Gemfile" class="headerlink" title="Gemfile"></a>Gemfile</h2><p>​ Gem 的列表</p><h2 id="Gemfile-lock"><a href="#Gemfile-lock" class="headerlink" title="Gemfile.lock"></a>Gemfile.lock</h2><p>​ 主要是 <code>rails</code> 所依赖的 <code>gem</code> 包，主要是 <code>bundle</code> 命令用到，类似于 package.json 文件。</p><h2 id="Procfile"><a href="#Procfile" class="headerlink" title="Procfile"></a>Procfile</h2><p>​ 在部署时，在云服务器上，类似于 heroku , 用来描述自己服务的文件。</p><h2 id="Rakefile"><a href="#Rakefile" class="headerlink" title="Rakefile"></a>Rakefile</h2><p>​ 类似于<code>Makefile</code> 文件。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SCSS入门指南</title>
      <link href="/2018/02/14/SCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/14/SCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>我为什么想用<code>Scss</code>呢，这还要从项目打算增加一个功能——支持不同颜色主题配置说起。</p><p>唉，都是泪。</p><p>本文主要介绍了<code>SCSS</code>的基本语法和核心概念，希望对需要的同学有帮助。</p></blockquote><a id="more"></a><h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><h4 id="SCSS-与-Sass-的关系"><a href="#SCSS-与-Sass-的关系" class="headerlink" title="SCSS 与 Sass 的关系"></a>SCSS 与 Sass 的关系</h4><p>SCSS 完全兼容 CSS3 ，是 Sass 3 引入的新语法。</p><p>即 Sass 有两种语法。</p><blockquote><p>一种是 SCSS，支持 CSS3。</p></blockquote><blockquote><p>另一种是 缩排语法，也称作 Sass。这种语法不使用花括号，通过缩排来表达层级，通过换行符来分隔属性。</p></blockquote><p><strong>下文提到的 Sass 均指使用 Scss 语法书写的，后缀名为 scss 的 Sass 文件</strong></p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>sass 的导入使用 <code>@import “css_file_name&quot;；</code>。</p><blockquote><p>导入 sass 文件会在编译时将导入的 sass 文件和被导入的 sass 文件合并为一个文件。</p><p>这种导入还可以省略后缀名 <code>.scss</code> ,且可以省略文件前的 下划线 <code>_</code></p></blockquote><blockquote><p>导入 CSS 文件编译后依然是以 <code>@import</code> 形式存在，不会被合并为一个文件</p></blockquote><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>标准注释 <code>/* */</code> ，在编译后的 CSS 文件中仍然存在</p><p>单行注释 <code>//</code> ，在编译后 不会被编译进 CSS 文件</p><h3 id="SCSS变量"><a href="#SCSS变量" class="headerlink" title="SCSS变量"></a>SCSS变量</h3><h4 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h4><p>sass 变量必须以 <code>$</code> 开头,后面紧跟变量名。</p><p>变量名和变量值之间使用冒号<code>:</code>分隔，类似 CSS 属性设置。</p><p>变量值后面加上 <code>!default</code> 表示默认值。可以在默认变量之前为其重新赋值从而覆盖默认值，在组件开发时会很有用。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">14px</span>;      <span class="comment">//定义之后可以在全局使用</span></span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">2</span>;   <span class="comment">//覆盖默认值</span></span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span>!default;  <span class="comment">//默认值</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="variable">$fontSize</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="variable">$baseLineHeight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>如果变量不是作为属性值使用 而是 <strong>作为属性名</strong> 使用，或某些特殊情况下的变量，需要以 <code>#{$variables}</code> 形式使用。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$borderDirection</span> : top!default</span><br><span class="line"><span class="variable">$baseFontSize</span>: <span class="number">12px</span> !default</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span>!default</span><br><span class="line">     </span><br><span class="line">.border-#&#123;<span class="variable">$borderDirection</span>&#125;&#123;   //变量应用于类 </span><br><span class="line">    border-#&#123;<span class="variable">$borderDirection</span>&#125;: <span class="number">1px</span> solid <span class="number">#ccc</span>;  <span class="comment">//应用于属性名</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:#&#123;<span class="variable">$baseFontSize</span>&#125;/#&#123;<span class="variable">$baseLineHeight</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多值变量"><a href="#多值变量" class="headerlink" title="多值变量"></a>多值变量</h4><p>分为 <code>list</code> 类型(类似数组) 和 <code>map</code>类型(类似变量)。</p><h5 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$colorArr</span>: <span class="number">#ccc</span> <span class="number">#fff</span> <span class="number">#ddd</span>; <span class="comment">//可使用空格，小括号，逗号三种方式来分隔各项</span></span><br><span class="line"><span class="comment">//使用nth($var,$index)取值</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:nth(<span class="variable">$colorArr</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$head</span>:&#123; h1:<span class="number">2em</span>, h2:<span class="number">1.5em</span>, h3:<span class="number">1.2em</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 map-get($map,$key)来取值</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:map-get(<span class="variable">$head</span>,h1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在变量值后加上 <code>！global</code>即声明为全局变量。(目前版本暂不支持)</p><p>目前的变量机制为：<strong>局部变量会覆盖全局变量</strong></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h4 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">40px</span>;</span><br><span class="line">  <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    </span><br><span class="line">    &amp;:hover&#123;     <span class="comment">//可以使用 &amp; 来表示父元素</span></span><br><span class="line">      <span class="attribute">color</span>:blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @at-root .child&#123;   <span class="comment">//@at-root 可用于跳出父级元素嵌套</span></span><br><span class="line">    <span class="attribute">color</span>:yellow;</span><br><span class="line">  &#125;</span><br><span class="line">  @at-root&#123;</span><br><span class="line">    <span class="selector-class">.parent</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>:black;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.grand</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:&#123;</span><br><span class="line">    style:solid;</span><br><span class="line">    <span class="attribute">left</span>:&#123;</span><br><span class="line">      width:<span class="number">4px</span>;</span><br><span class="line">      <span class="attribute">color</span>:$<span class="number">888</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="attribute">right</span>:&#123;</span><br><span class="line">      width:<span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">color</span>:<span class="number">#999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>sass 使用 <code>@mixin</code> 声明混合，可传递参数，参数名以 <code>$</code>符号开始，多个参数以逗号隔开，可以为参数设置默认值。</p><p>声明后的 <code>@mixin</code> 通过 <code>@include</code> 调用</p><h4 id="无参数-mixin"><a href="#无参数-mixin" class="headerlink" title="无参数 mixin"></a>无参数 mixin</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*无参数 @mixin */</span></span><br><span class="line">@<span class="keyword">mixin</span> center-block&#123;  <span class="comment">// @mixin 的声明</span></span><br><span class="line">  <span class="attribute">margin-left</span>:auto;</span><br><span class="line">  <span class="attribute">margin-right</span>:auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">  @<span class="keyword">include</span> center-block; <span class="comment">//@mixin 的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参数-mixin"><a href="#有参数-mixin" class="headerlink" title="有参数 mixin"></a>有参数 mixin</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有参数 @mixin */</span></span><br><span class="line">@<span class="keyword">mixin</span> opacity(<span class="variable">$opt</span>:<span class="number">100</span>)&#123;</span><br><span class="line">  opcaity:<span class="variable">$opt</span>/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">  @<span class="keyword">include</span> opacity;   <span class="comment">//使用默认值调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">  @<span class="keyword">include</span> opacity(<span class="number">40</span>);  <span class="comment">//传递参数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若 @mixin 定义了多个参数，当传入参数小于定义的参数个数时，后面未获得传入的参数使用默认值，无默认值时则报错。</span></span><br><span class="line"><span class="comment">//也可以通过 参数名和值 同时传入 来选择性的传入参数</span></span><br><span class="line">@<span class="keyword">include</span> hmixin(<span class="variable">$font-size</span>:<span class="number">20px</span>)</span><br></pre></td></tr></table></figure><h4 id="多组值参数-mixin"><a href="#多组值参数-mixin" class="headerlink" title="多组值参数 mixin"></a>多组值参数 mixin</h4><p>类似于 <code>box-shadow</code>,<code>transition</code>等多组值的参数类型，需要在定义 mixin 时 在变量后加 三个点 表示，形如 <code>$var...</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> box-shadow(<span class="variable">$shadow</span>...)&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="variable">$shadow</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  @<span class="keyword">include</span> box-shadow(<span class="number">0</span> 2px 2px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>),<span class="number">0</span> 3px 3px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="content"><a href="#content" class="headerlink" title="@content"></a>@content</h4><p><code>@content</code> 可以使 @mixin 接受一整块样式，接受的样式 从 <code>@content</code> 开始。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> max-screen(<span class="variable">$res</span>)&#123;</span><br><span class="line">  @<span class="keyword">media</span> only screen and (max-width:<span class="variable">$res</span>)&#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">include</span> max-screen(<span class="number">480px</span>)&#123;      <span class="comment">//接收一整块样式</span></span><br><span class="line">  <span class="selector-tag">body</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>继承使用关键词 <code>@extend</code>, 后面需要紧跟需要继承的选择器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#c40000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.speaker</span>&#123;        <span class="comment">//继承即相当于联合声明，即成为 h1, .speaker&#123;...&#125;</span></span><br><span class="line">  @<span class="keyword">extend</span> h1;</span><br><span class="line">  <span class="attribute">border-width</span>:<span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="占位选择器"><a href="#占位选择器" class="headerlink" title="占位选择器 %"></a>占位选择器 %</h4><p>占位选择器，如果不调用的话不会有任何的多余 css。避免了在基础样式较多时继承很多无用 css。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%lr&#123;</span><br><span class="line">  <span class="attribute">color</span>:transparent;</span><br><span class="line">  <span class="attribute">text-shadow</span>:none;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  @<span class="keyword">extend</span> %lr;      <span class="comment">//只用在被调用时才会解析</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps: 在 @media 中展示不能继承 外部的 代码片段。</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数与 @mixin 不同之处 在于函数返回的是值，不能直接使用，必须配合样式。</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$baseFontSize</span>:<span class="number">10px</span> !default;</span><br><span class="line"></span><br><span class="line">@function pxToRem(<span class="variable">$px</span>)&#123;</span><br><span class="line">  @return <span class="variable">$px</span> / <span class="variable">$baseFontSize</span> * 1rem;  <span class="comment">//返回的是值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:pxToRem(<span class="number">16px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h5 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ragb(blue,0.2) =&gt; rgba(0,0,255,0.2);</span><br><span class="line">darken(<span class="variable">$color</span>,<span class="variable">$amount</span>)  <span class="comment">//将$color 变暗 $amount 个百分比</span></span><br><span class="line">lighten(<span class="variable">$color</span>,<span class="variable">$amount</span>) <span class="comment">//将$color 变亮 $amount 个百分比</span></span><br></pre></td></tr></table></figure><h5 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">percentage(<span class="variable">$value</span>)   <span class="comment">//将一个没有单位的数字转为百分比形式</span></span><br><span class="line">unitless(<span class="variable">$number</span>)  <span class="comment">//返回这个数是否没有单位</span></span><br><span class="line">unit(<span class="variable">$number</span>)  <span class="comment">//得到数的单位</span></span><br></pre></td></tr></table></figure><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nth(<span class="variable">$list</span>,<span class="variable">$n</span>)  <span class="comment">//返回列表里面第 n 个位置的值</span></span><br></pre></td></tr></table></figure><h5 id="三目判断"><a href="#三目判断" class="headerlink" title="三目判断"></a>三目判断</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="variable">$condition</span>,<span class="variable">$if-true</span>,<span class="variable">$if-false</span>)</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><code>SCSS</code>可进行加减乘除运算，运算符前后都需要有空格，否则会报错。</p><h3 id="条件判断及循环"><a href="#条件判断及循环" class="headerlink" title="条件判断及循环"></a>条件判断及循环</h3><h4 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h4><p>可以一个单独使用，也可以和<code>@else</code> 和 <code>@else if</code> 结合 多条件使用。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$type</span>:mons;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$type</span> == ocean&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == mons&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == mate&#123;</span><br><span class="line">    <span class="attribute">color</span>:greem;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p><code>for 循环</code>分为两种形式。</p><p><code>@for $var from &lt;strat&gt; through &lt;end&gt;</code>（包含 end 值）</p><p><code>@for $var from &lt;start&gt; to &lt;end&gt;</code>（不包含 end 值）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 4&#123;</span><br><span class="line">  item-#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sass 的 @if 使用 not ，or , and 表示 非，或，与</span></span><br><span class="line"><span class="comment">//使用 == , != 表示 等于 与 不等于</span></span><br></pre></td></tr></table></figure><h4 id="each循环"><a href="#each循环" class="headerlink" title="each循环"></a>each循环</h4><p>语法为 <code>@each $var in &lt;list or map&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$animal-list</span>:puma,sea-sl,eg,sala;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$ani</span> in <span class="variable">$animal-list</span>&#123;</span><br><span class="line">  .#&#123;<span class="variable">$ani</span>&#125;-<span class="attribute">icon</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>:url(<span class="string">'/images/#&#123;$ani&#125;.png'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//支持多字段循环</span><br><span class="line">//支持 map 的 key/value 循环</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> SCSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（七）：表单</title>
      <link href="/2018/02/13/Vue%E7%B3%BB%E5%88%97%E4%B8%83/"/>
      <url>/2018/02/13/Vue%E7%B3%BB%E5%88%97%E4%B8%83/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>表单作为前端开发中的一个重要组成部分，每个前端框架都提供了各自的一些解决方案。但不管怎么说，双向绑定和表单验证都是绕不开的东西，只不过各框架的实现方式有一些异同。</p><p><code>Vue</code>作为一个渐进增强的前端框架，并没有提供类似<code>Angular</code>那样比较完善和齐整的表单解决方案（例如响应式表单），因此涉及到的概念也都比较简单。</p><p>本篇博客主要介绍了<code>Vue</code>表单的基础概念和使用方法。</p></blockquote><a id="more"></a><h2 id="v-model双向绑定"><a href="#v-model双向绑定" class="headerlink" title="v-model双向绑定"></a><code>v-model</code>双向绑定</h2><p><code>Vue</code> 使用<code>v-model</code>指令在表单元素（<code>&lt;input&gt;</code> ,<code>&lt;textarea&gt;</code>等）上创建双向绑定。</p><p>在本质上，<code>v-model</code>指令只是一个语法糖，相当于将数据绑定到表单的<code>value</code>同时在输入事件触发时更新<code>value</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"message = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时需要注意以下几点：</p><ol><li><code>v-model</code> 会根据控件类型自动选取正确的方法来更新元素。</li><li><code>v-model</code> 会忽略所有表单元素的 <code>value</code>，<code>checked</code>，<code>selected</code> 等特性的初始值，<strong>总是将 <code>Vue</code> 实例的数据作为数据来源</strong>。如果想设置初始值，可在<code>Vue</code>实例的<code>data</code>选项中声明数据的初始值。</li><li><code>v-model</code> 的事件<span id="input"></span>触发不同于<code>v-on:input</code>的一点是<strong>不会在中文输入法组合文字的过程中更新数据</strong>。</li><li><code>v-model</code> 通常绑定到布尔值或静态字符串或静态字符串的数组。如果我们想将值绑定到<code>Vue</code>实例的动态属性上，可以使用<code>v-bind</code>绑定相应表单元素的<code>value</code>值 ,也可以为<code>value</code>绑定对象,数组等类型值 。</li></ol><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多行文本输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单个复选框，v-model 会绑定到 布尔值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"checked"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可通过true-value 和 false-value 将单个复选框的布尔值绑定到其他字符串值(无法绑定到数据属性)  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span> <span class="attr">true-value</span>=<span class="string">"yes"</span> <span class="attr">false-value</span>=<span class="string">"no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多个复选框，v-model 会绑定到 value 数组 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要保证 checkedList 的初始值为数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"checkedList"</span> <span class="attr">value</span>=<span class="string">"car"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"checkedList"</span> <span class="attr">value</span>=<span class="string">"plane"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"checkedList"</span> <span class="attr">value</span>=<span class="string">"bicyle"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选，v-model 会绑定到选中的 value 值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span> a<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"b"</span>&gt;</span> b<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h3><blockquote><p><code>v-model</code>不存在初始值时，<code>&lt;select&gt;</code> 元素会被渲染为未选中状态。这种情况会导致在 <em>IOS</em> 系统中无法触发<code>change</code>事件，用户无法选择第一个选项。</p><p>解决办法为：提供一个值为空的禁用选项。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选时，v-model 会绑定到单个 value 值(无value值则绑定到option的文本字符串值) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"b"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"c"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选时，v-model 会绑定到一个 value 数组（无value值则绑定到option的文本字符串值的数组)  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><p><code>.lazy</code></p><p><code>v-model</code>默认在每次 <code>input</code> 事件触发时进行数据的更新和同步(除<a href="#input">上述输入法组合文字时</a>)。</p><p><code>.lazy</code> 修饰符 用于将<code>v-model</code> 转换为当触发 <code>change</code> 事件时同步。（即<strong>内容改变且失去焦点时</strong>同步)</p></li><li><p><code>.number</code></p><p><code>.number</code>用于自动将用户输入的数字值转换为数字类型（如果无法转换为数字类型则什么也不做）。</p><p>需要注意的是，即使在设置<code>type = number</code>后，<em>HTML</em> 输入元素的值也总是返回字符串。</p></li><li><p><code>.trim</code></p><p><code>.trim</code> 用于自动过滤用户输入的首尾空白字符。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rails学习笔记（一）:基本概念</title>
      <link href="/2018/02/12/Rails%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/02/12/Rails%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在项目中接触<code>Rails</code>也有一段时间了，但由于时间关系，一直也没有系统的对<code>Rails</code>进行深入的了解和学习。很多东西只是在遇到时才会去留意以下。</p><p>因此决定通过这个系列，系统的对<code>Rails</code>进行一个学习。当然，<code>Rails</code>主要还是一个基于<code>ruby</code>的后端框架，我对<code>Ruby</code>的了解也仅限于基本语法，所以这一系列博客可能也仅仅是起一个记录作用，对于<code>rails</code>更深层次的理解和使用，可能较少涉及。&amp;__&amp;。</p><p>本篇博客介绍了<code>Rails</code>整体的<code>MVC</code>架构。</p></blockquote><a id="more"></a><h1 id="MVC-框架简介"><a href="#MVC-框架简介" class="headerlink" title="MVC 框架简介"></a>MVC 框架简介</h1><blockquote><p>MVC 全名 Model View Controller。即模型，视图，控制器。强制的将应用程序的输入，处理和输出分开。</p></blockquote><ul><li><code>Model(模型)</code> : 处理数据及业务逻辑，通常负责对数据库进行存取操作。</li><li><code>View(视图)</code> ：显示用户界面，处理数据显示，通常依据模型数据来创建。</li><li><code>Controller(控制器)</code> ：处理用户请求及应用逻辑，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。控制器是连接视图和模型的桥梁。</li></ul><h1 id="Rails-中的-MVC-框架"><a href="#Rails-中的-MVC-框架" class="headerlink" title="Rails 中的 MVC 框架"></a>Rails 中的 MVC 框架</h1><blockquote><p>Rails 是一个全栈式的 MVC 框架。</p></blockquote><ul><li><code>ActiveRecord</code> (Model 层) : 是 <code>Rails</code> 的 <code>ORM</code>组件。负责与数据库沟通，让我们可以用面向对象的语法操作数据库。</li><li><code>ActionView</code> (View 层) ：在 <code>rails</code> 中处理 <code>View</code> 的组件。负责显示用户界面以及 <code>controllers</code> 传来的数据。</li><li><code>ActionController</code> (Controller层) : 主要负责处理 WEB 请求，检索模型数据并按要求将数据传递给视图。</li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（六）：事件处理</title>
      <link href="/2018/02/10/Vue%E7%B3%BB%E5%88%97%E5%85%AD/"/>
      <url>/2018/02/10/Vue%E7%B3%BB%E5%88%97%E5%85%AD/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>事件处理，作为网页开发中的重要组成部分，是所有前端框架都必须的一个实现。</p><p>在前端的事件处理中，如何做到关注点分离和代码的简洁优雅，是一个值得思考的问题。</p><p>本篇博客主要介绍了<code>Vue</code>框架事件处理的方法和注意事项。</p></blockquote><a id="more"></a><h2 id="监听和处理事件"><a href="#监听和处理事件" class="headerlink" title="监听和处理事件"></a>监听和处理事件</h2><p><code>Vue</code>使用 <code>v-on</code> 指令监听 <code>DOM</code> 事件。</p><p>在事件触发时，执行相应<code>JavaScript</code>代码，有三种写法：</p><ol><li><p><strong>绑定到 <code>JS</code> 表达式</strong></p><p>在事件处理逻辑非常简单时，可以使用此种方法。在逻辑较为复杂时严重不推荐。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app1'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        counter:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>绑定到方法名称</strong></p><p>在事件处理逻辑比较复杂时，<code>v-on</code> 可以接收一个方法名称用于在事件触发时调用此方法。</p><blockquote><p>方法默认传入的参数 <code>event</code> 为 原生 <code>DOM</code> 事件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"addCounter"</span>&gt;</span>加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>按钮被点击了 &#123;&#123;counter&#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app2"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        name:<span class="string">'astr'</span>,</span><br><span class="line">        counter:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        addCounter:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name + <span class="string">"click button"</span>);</span><br><span class="line">            <span class="keyword">if</span>(event)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.counter ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>绑定到方法调用</strong></p><p>也可以在<code>v-on</code> 的内联<code>js</code> 语句中直接调用方法。</p><blockquote><p>在内联的方法调用时，如果需要访问原始的<code>DOM</code>事件，可以显式的传入特殊变量<code>$event</code>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi',$event)"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('bye',$event)"</span>&gt;</span>再见<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你说了：&#123;&#123; word &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app3 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app3"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        word:<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        say:<span class="function"><span class="keyword">function</span>(<span class="params">word,event</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word；</span><br><span class="line">            <span class="built_in">console</span>.log(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>为了使事件所绑定触发方法能更纯粹的处理数据逻辑，而不必再去处理常见的<code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 等。<code>vue</code>提供了一系列的事件修饰符，使用方式形如<code>v-on:click.stop</code>。</p><p>事件修饰符有以下几种：</p><ul><li><code>.stop</code> 阻止事件的进一步传播</li><li><code>.prevent</code> 阻止事件的默认行为（例如点击链接的跳转等）</li><li><code>.capture</code> 使用事件捕获模式（即元素的事件在捕获阶段触发）</li><li><code>.self</code> 只有当前元素自身才能触发事件(即只有在目标阶段触发)</li><li><code>.once</code> <em>vue 2.1.4</em> 新增事件只触发一次。此修饰符<strong>特殊之处</strong>在于可以使用在自定义的<strong>组件事件</strong>上。</li><li><code>.passive</code> <em>vue 2.3.0</em> 新增，用于在事件触发时默认行为立即发生，不必等待事件响应函数完成，可显著提高移动端性能。<strong>此修饰符的优先级高于<code>.prevent</code></strong>。</li></ul><p>事件修饰符可以串联使用。形如<code>v-on:click.stop.prevent</code> 。</p><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>可以通过为<code>v-on</code>添加按键修饰符，来监听对应按键的键盘事件。例如<code>v-on:keyup.13</code> ，即在<code>keyCode</code>为 <em>13</em> 的按键弹起时触发事件。</p><h3 id="自定义按键修饰符别名"><a href="#自定义按键修饰符别名" class="headerlink" title="#自定义按键修饰符别名"></a>#自定义按键修饰符别名</h3><p>可以通过<code>Vue</code> 的 <code>Vue.config.keyCodes</code> 方法来<strong>自定义按键修饰符别名</strong>。</p><blockquote><p><code>Vue.config.keyCodes</code>　为一个对象，对象中属性的属性名为按键修饰符别名，属性值为按键的<code>keyCode</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 keyCode 为 112 的按键别名设置为 f1</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br><span class="line"><span class="comment">//即可通过 v-on:keyup.f1 使用</span></span><br></pre></td></tr></table></figure><h3 id="预置的按键修饰符别名"><a href="#预置的按键修饰符别名" class="headerlink" title="#预置的按键修饰符别名"></a>#预置的按键修饰符别名</h3><p><code>Vue</code> 为一些最常用的按键预置了别名，分别有：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.delete</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h3 id="自动匹配按键修饰符"><a href="#自动匹配按键修饰符" class="headerlink" title="#自动匹配按键修饰符"></a>#自动匹配按键修饰符</h3><p>在按键事件的原生<code>DOM</code>事件<code>$event</code>中，<code>$event.key</code> 即为按下的键名。</p><p>在 <em>Vue 2.5.0</em> 之后，可将此键名作为按键修饰符来使用（需转换为短横线形式），形如 <code>&lt;input @keyup.page-down=&quot;onPageDown&quot;&gt;</code> ,在 <code>$event.key === &quot;pageDown&quot;</code> 时会被调用。</p><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><p>系统修饰符主要用于系统按键的组合操作，例如<code>alt + q</code>，<code>ctrl + 点击</code> 等类似情况。</p><p>系统修饰符有以下这些：</p><ul><li><p><code>.ctrl</code></p></li><li><p><code>.alt</code></p></li><li><p><code>shift</code></p></li><li><p><code>meta</code> 在 <em>Mac</em> 上对应<code>command</code>键，在 <em>windows</em> 上对应<code>win</code>键</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在按下 ALT 时 C 键弹起会触发 clear 事件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ALT 键的弹起并不会触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span> = <span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>exact</code></p><p><code>.exact</code>用于更精确的控制系统修饰符组合的触发，<strong>当且仅当被其修饰的按键按下时</strong>才会触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当没有任何系统修饰符所属按键被按下时才会触发事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当且仅当 ctrl 被按下时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>EEEE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="#鼠标按键修饰符"></a>#鼠标按键修饰符</h3><p>有以下三个鼠标按键修饰符用于鼠标按键的事件触发：</p><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（五）：列表渲染</title>
      <link href="/2018/02/07/Vue%E7%B3%BB%E5%88%97%E4%BA%94/"/>
      <url>/2018/02/07/Vue%E7%B3%BB%E5%88%97%E4%BA%94/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>本文主要介绍<code>Vue</code>中列表渲染的相关知识。详细介绍了<code>Vue</code>列表渲染指令<code>ｖ-for</code>的使用方法和一些注意事项。</p><p>对正在学习<code>Vue</code>的同学有一定帮助。</p></blockquote><a id="more"></a><p><code>v-for</code>可以用来迭代渲染数组，对象，整数，字符串。当迭代整数时，会从1开始重复整数次模板。当迭代字符串时，会迭代每个字符。</p><p>类似<code>v-if</code>，<code>v-for</code>也可以使用在<code>&lt;template&gt;</code>上，来达到渲染多个元素的目的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span> = <span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用v-for迭代数组"><a href="#使用v-for迭代数组" class="headerlink" title="使用v-for迭代数组"></a>使用<code>v-for</code>迭代数组</h3><p><code>Vue</code>使用<code>v-for</code>来根据一个数组渲染一个列表。<code>v-for</code>指令需要使用特殊形式的语法<code>item in items</code>或者<code>item of items</code>。其中<code>items</code>是源数据数组，<code>item</code>是所迭代数组元素的别名。</p><p><code>v-for</code>还支持一个可选的第二个参数为当前项的索引。形如<code>v-for=“ (item, index) in items&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'ex1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"cat,index in cats"</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125;-&#123;&#123;cat.color&#125;&#125;-&#123;&#123;cat.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">        cats:[</span></span><br><span class="line"><span class="javascript">            &#123;<span class="attr">color</span>:<span class="string">'red'</span>,<span class="attr">name</span>:<span class="string">'lili'</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="attr">color</span>:<span class="string">'balck'</span>,<span class="attr">name</span>:<span class="string">'sisi'</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="attr">color</span>:<span class="string">'blue'</span>,<span class="attr">name</span>:<span class="string">'daxi'</span>&#125;</span></span><br><span class="line"><span class="undefined">        ]</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用v-for迭代对象属性"><a href="#使用v-for迭代对象属性" class="headerlink" title="使用v-for迭代对象属性"></a>使用<code>v-for</code>迭代对象属性</h3><p><code>v-for</code>可以用来迭代对象属性,支持第二项键名参数和第三项索引参数(此指令通过<code>Object.keys()</code>遍历，在不同引擎下可能会有不同的表现顺序)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ex2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in sObj"</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ex3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in sObj"</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">data:&#123;</span></span><br><span class="line"><span class="undefined">    sObj:&#123;</span></span><br><span class="line"><span class="javascript">        f1:<span class="string">'base'</span>,</span></span><br><span class="line"><span class="javascript">        f2:<span class="string">'socc'</span>,</span></span><br><span class="line"><span class="javascript">        f3:<span class="string">'tenn'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="特殊属性key"><a href="#特殊属性key" class="headerlink" title="特殊属性key"></a>特殊属性<code>key</code></h4><p><code>key</code>属性主要用于提高渲染列表时的性能。因为<code>Vue</code>在渲染时会尽量复用相同元素，在不加<code>key</code>时，改变列表顺序时这种复用机制会增加渲染成本（可能因为改变一项的顺序导致所有项都互相复用重新渲染）。</p><p>而在使用<code>key</code>属性时，在列表某个节点改变时，会通过<code>key</code>识别节点，从而高效的更新渲染。</p><p><code>key</code>属性的工作方式类似一个属性，所以要使用<code>v-bind</code>来绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="列表渲染数组时的变动检测"><a href="#列表渲染数组时的变动检测" class="headerlink" title="列表渲染数组时的变动检测"></a>列表渲染数组时的变动检测</h3><h4 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h4><p>对被渲染数组使用以下方法时，会改变调用方法的原数组，进而触发视图更新，这些方法被称为数组的<strong>变异方法</strong>。</p><ul><li><code>push()</code></li><li><code>unshift</code></li><li><code>shift()</code></li><li><code>pop()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li><li><code>splice()</code></li></ul><h4 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h4><p>非变异方法<strong>不会改变原始数组</strong>，但会返回一个新数组。当使用非变异方法时，可以使用返回值的新数组赋值替换旧数组。</p><ul><li><code>filter()</code></li><li><code>concat()</code></li><li><code>slice()</code></li></ul><h4 id="关于数组变动检测需要注意的地方"><a href="#关于数组变动检测需要注意的地方" class="headerlink" title="关于数组变动检测需要注意的地方"></a>关于数组变动检测需要注意的地方</h4><p><code>vue</code>对于以下方式的变动是无法检测的：</p><ol><li>通过索引直接设置数组项时。形如<code>vm.items[index] = newval</code></li><li>修改数组的长度时，形如 <code>vm.items.length = newlen</code></li></ol><p>对于第一种问题，可以通过以下三种方式实现可以变动检测的目的：</p><ol><li>使用<code>Vue.set()</code>全局方法。形如<code>Vue.set( vm.items, index，newval)</code>。</li><li>使用<code>vm.$set()</code>实例方法，此方法是全局方法 <code>Vue.set()</code>的一个别名。</li><li>使用数组的<code>splice</code>方法。形如 <code>vm.items.splice(index,1,newval)</code>。</li></ol><p>对于第二种问题，也可以使用数组的<code>splice</code>方法，形如<code>vm.items.splice(newlen)</code></p><h4 id="数组的过滤和排序"><a href="#数组的过滤和排序" class="headerlink" title="数组的过滤和排序"></a>数组的过滤和排序</h4><p>在想要显示一个数组的过滤或排序副本，但不实际改变原始数据时，可以创建返回过滤或排序后数组的计算属性。(注意在计算属性中需使用非变异方法)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span> = <span class="string">"n in relist"</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">    data:&#123;</span></span><br><span class="line"><span class="undefined">        oldlist:[1,2,3,4,5]</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    computed:&#123;</span></span><br><span class="line"><span class="javascript">        relist:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">return</span> <span class="keyword">this</span>.oldlist.filter(<span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span>==<span class="number">0</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当无法使用计算属性时，例如在嵌套的<code>v-for</code>循环中，可以使用<code>method</code>方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span> = <span class="string">"item in oldlist"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span> = <span class="string">"n in re(item)"</span>&gt;</span>&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">    data:&#123;</span></span><br><span class="line"><span class="undefined">        oldlist:[1,[2,6,12,31],3,4,5]</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    method:    </span></span><br><span class="line"><span class="javascript">        re:<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span>==<span class="number">0</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="列表渲染对象时的变动检测"><a href="#列表渲染对象时的变动检测" class="headerlink" title="列表渲染对象时的变动检测"></a>列表渲染对象时的变动检测</h3><p>由于<code>JavaScript</code>的机制，<strong>Vue不能检测其对象属性的添加和删除</strong>。也就是说，<code>vue</code>无法动态的添加<strong>根级别</strong>的响应式属性。但可以为嵌套对象添加响应式属性。</p><h4 id="为嵌套对象添加响应式属性"><a href="#为嵌套对象添加响应式属性" class="headerlink" title="为嵌套对象添加响应式属性"></a>为嵌套对象添加响应式属性</h4><p>可以通过<code>Vue.set(object, key, value)</code> 方法向嵌套的对象添加响应式属性。形如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="undefined">    data:&#123;</span></span><br><span class="line"><span class="undefined">        user:&#123;</span></span><br><span class="line"><span class="javascript">            name:<span class="string">'andi'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过<code>Vue.set(app1.data, &#39;age&#39;, 33)</code>来添加响应属性到嵌套的<code>user</code>对象。</p><p>或者使用此全局方法的别名，即<code>实例方法</code>app1.$set(app1.data, ‘age’, 33)`。</p><h4 id="为嵌套对象添加多个响应式新属性"><a href="#为嵌套对象添加多个响应式新属性" class="headerlink" title="为嵌套对象添加多个响应式新属性"></a>为嵌套对象添加多个响应式新属性</h4><p>在需要为已有对象赋予多个新属性时，比如使用<code>Object.assign()</code>或 <code>_.extend()</code>。</p><p>应该用新旧对象的属性创建一个新对象，而不是直接将新对象加入旧对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用此种方式无法添加</span></span><br><span class="line"><span class="built_in">Object</span>.assign(app1.user,&#123;<span class="attr">age</span>:<span class="number">27</span>,<span class="attr">weight</span>:<span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//而应该使用此种方式</span></span><br><span class="line">app1.user = <span class="built_in">Object</span>.assign(&#123;&#125;,app1.user,&#123;<span class="attr">age</span>:<span class="number">27</span>,<span class="attr">weight</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for和v-if"><a href="#v-for和v-if" class="headerlink" title="v-for和v-if"></a><code>v-for</code>和<code>v-if</code></h3><p>当<code>v-for</code>和<code>v-if</code>处于同一节点时，<code>v-for</code>的优先级高于<code>v-if</code>。也就是说，<code>v-if</code>会分别重复作用于<code>v-for</code>的<strong>每次循环</strong>中。</p><p>如果想要有条件的跳过循环的执行，可以考虑将<code>v-if</code>置于<code>v-for</code>的外层的元素（或<code>template</code>）上。</p><h3 id="组件的v-for"><a href="#组件的v-for" class="headerlink" title="组件的v-for"></a>组件的<code>v-for</code></h3><p>在组件上使用<code>v-for</code>，需要注意的是，<strong>任何数据都不会自动的传递到组件中</strong>，因为组件有自己独立的作用域。</p><p>如果想将迭代数据传递到组件中，需要将数据绑定到组件的 <code>props</code>属性上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span> <span class="attr">v-bind:item</span>=<span class="string">"item"</span> <span class="attr">v-bind:index</span> = <span class="string">"index"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（四）：条件渲染</title>
      <link href="/2018/02/05/Vue%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
      <url>/2018/02/05/Vue%E7%B3%BB%E5%88%97%E5%9B%9B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>条件渲染，指的是根据相应条件来决定是否渲染相关模板。</p><p><code>Vue</code>的条件渲染，与其他的前端框架差别不大。但也有一些需要注意的地方。</p><p>本篇博客主要介绍了<code>Vue</code>的条件渲染指令和常见使用方法。</p></blockquote><a id="more"></a><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h3><p>在<code>Vue</code>中，使用 <code>v-if</code>指令来实现条件渲染。形如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"flag == 'ok'"</span>&gt;</span>now ok<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用 v-else-if 添加条件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">"flag == 'nice'"</span>&gt;</span>now nice<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用 v-else 添加所有条件失败后的渲染模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>now bad<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>v-else</code>和 <code>v-else-if</code> 都必须紧跟在带 <code>v-if</code> 和 <code>v-else-if</code>的元素之后，才能发挥作用。</p><h4 id="lt-template-gt-元素的使用"><a href="#lt-template-gt-元素的使用" class="headerlink" title="&lt;template&gt;元素的使用"></a><code>&lt;template&gt;</code>元素的使用</h4><p>在使用<code>v-if</code>控制一组元素的渲染时，可以使用<code>&lt;template&gt;</code>元素来包裹需要控制渲染的元素，在最终的渲染结果中，<code>&lt;template&gt;</code>元素将不会被渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ok title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>bad title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>paragraph 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用key管理可复用的元素"><a href="#使用key管理可复用的元素" class="headerlink" title="使用key管理可复用的元素"></a>使用<code>key</code>管理可复用的元素</h4><p><code>vue</code>对于已有元素不会重新进行渲染，而是尽可能的复用。在切换渲染模板时，如果两个模板中有相同元素时，不会被删除重新渲染，而会被继续复用。</p><p>类似如下的两个模板中，在切换渲染的模板时，<code>input</code>元素并不会被重新渲染，只有<code>placeholder属性</code>会被替换掉，也就是说输入框中的文字仍会留存。<code>&lt;h1&gt;</code>元素也会被复用，只是内容被替换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ok title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">palceholder</span>=<span class="string">"ooook"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>bad title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"baaaad"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要使两个模板中元素互相独立，不在切换时进行复用，可以为元素添加一个具有唯一值的<code>key</code>属性来实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ok title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">palceholder</span>=<span class="string">"ooook"</span> <span class="attr">key</span>=<span class="string">"ok_input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>bad title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"baaaad"</span> <span class="attr">key</span>=<span class="string">"bad_input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h3><p><code>v-show</code>指令用于根据条件控制元素的<strong>是否显示</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>v-show</code>指令控制的元素始终会被渲染。只是会简单的<strong>通过切换元素的display属性</strong>来进行显示和隐藏。</p><h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a><code>v-if</code>和<code>v-show</code>的区别</h3><p><code>v-if</code>指令控制的元素，会根据条件动态的渲染和销毁，包括子组件和事件监听器都会被适当的销毁和重建。若<code>v-if</code>的初始条件为假，它什么也不会做，直到条件切换为真时才会进行渲染，即<code>v-if</code>是<strong>惰性的</strong>。</p><p>而 <code>v-show</code> 指令控制的元素不管初始条件是真或假，都始终会被渲染。</p><p><strong>一般来说，v-if 切换时有更高的渲染开销，而 v-show 在初始化时有更高的渲染开销</strong>。</p><p>因此，频繁切换时使用 <code>v-show</code> 更合适，运行时条件较少改变时使用<code>v-if</code>更合适。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（三）：Class与Style</title>
      <link href="/2018/02/01/Vue%E7%B3%BB%E5%88%97%E4%B8%89/"/>
      <url>/2018/02/01/Vue%E7%B3%BB%E5%88%97%E4%B8%89/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>class</code> 和　<code>style</code>　作为元素的属性，可以通过指令 <code>v-bind</code> 来数据绑定字符串值。但存在字符串拼接比较麻烦且容易出错的问题。因此<code>Vue</code>专门针对<code>class</code>和<code>style</code>做了相应的增强。</p><p>本文主要介绍了<code>Vue</code>针对<code>class</code>和<code>Style</code>绑定的一些知识。</p></blockquote><a id="more"></a><h3 id="绑定Class"><a href="#绑定Class" class="headerlink" title="绑定Class"></a>绑定<code>Class</code></h3><h4 id="绑定Class的对象语法"><a href="#绑定Class的对象语法" class="headerlink" title="#绑定Class的对象语法"></a>#绑定<code>Class</code>的对象语法</h4><p><code>v-bind:class</code>可以绑定一个类型为对象的值，用于动态的切换 <code>Class</code>。形如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive,'text-dange':hasError&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObj"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"computedClassObj"</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">    data:&#123;</span><br><span class="line">        isActive: true,</span><br><span class="line">        hasError: false,</span><br><span class="line">        classObj:&#123;</span><br><span class="line">            active:true,</span><br><span class="line">            'text-danger':false</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        computedClassObj:function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                active: this.isActive &amp;&amp; !this.hasError,</span><br><span class="line">                'text-danger': this.hasError &amp;&amp; !this.isActive,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="绑定class的数组语法"><a href="#绑定class的数组语法" class="headerlink" title="# 绑定class的数组语法"></a># 绑定<code>class</code>的数组语法</h4><p><code>v-bind:class</code>可以绑定一个类型为数组的值，用于绑定多个 <code>class</code>。形如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[ a, b ]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以使用三元表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[ is?b:c, d]"</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可以使用对象语法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[ &#123;active:isActive&#125;, d, c ]"</span></span></span><br></pre></td></tr></table></figure><h4 id="组件的class绑定"><a href="#组件的class绑定" class="headerlink" title="#组件的class绑定"></a>#组件的<code>class</code>绑定</h4><p>组件声明时绑定的<code>class</code>属性和使用时绑定的<code>class</code>属性均会被渲染使用，不会互相覆盖。</p><h3 id="绑定Style"><a href="#绑定Style" class="headerlink" title="绑定Style"></a>绑定<code>Style</code></h3><h4 id="绑定style的对象语法"><a href="#绑定style的对象语法" class="headerlink" title="# 绑定style的对象语法"></a># 绑定<code>style</code>的对象语法</h4><p>可使用 <code>v-bind:style</code>将样式绑定到一个<code>JS</code>对象值，对象的<code>key</code>为<code>css</code>属性名（驼峰形式或单引号包括的单横线形式），<code>value</code>为属性值。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123;color:activeColor,fontSize:fontSize+'px'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123;styleObj&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123;styleObj2&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">....</span></span><br><span class="line"><span class="undefined">data:&#123;</span></span><br><span class="line"><span class="javascript">    activeColor:<span class="string">'red'</span>,</span></span><br><span class="line"><span class="undefined">    fontSize:20,</span></span><br><span class="line"><span class="undefined">    styleObj:&#123;        </span></span><br><span class="line"><span class="javascript">        color:<span class="string">'red'</span>,</span></span><br><span class="line"><span class="undefined">        fontSize:20</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;,</span></span><br><span class="line"><span class="undefined">computed:&#123;</span></span><br><span class="line"><span class="javascript">    styleObj2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            color:<span class="string">'red'</span>,</span></span><br><span class="line"><span class="javascript">            fontSize:<span class="keyword">this</span>.fontSize*<span class="number">2</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">....</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="绑定Style的数组语法"><a href="#绑定Style的数组语法" class="headerlink" title="# 绑定Style的数组语法"></a># 绑定<code>Style</code>的数组语法</h4><p>可将<code>v-bind:style</code>绑定到一个包含多个样式对象的数组值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyle,overStyle]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="style前缀的添加"><a href="#style前缀的添加" class="headerlink" title="#style前缀的添加"></a>#<code>style</code>前缀的添加</h4><p>当<code>v-bind:style</code>使用需要浏览器引擎前缀的<code>css</code>属性时，会自动侦测并添加相应前缀。例如<code>transform</code>属性。</p><p>同时也可以为 <code>style</code>绑定对象中的属性的属性值提供一个数组，用于为属性提供多个带前缀的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123;display:&#123;'-webkit-box','ms-flexbox','flex'&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器只会渲染数组中最后一个被支持的值。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（二）：计算属性和侦听器</title>
      <link href="/2018/01/22/Vue%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
      <url>/2018/01/22/Vue%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>Vue</code>的计算属性和侦听器在处理一些复杂逻辑和数据交互时是很有用的。</p><p>本文主要对<code>Vue</code>的计算属性和侦听器进行了介绍，并总结了两者的一些异同。</p></blockquote><a id="more"></a><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><strong>计算属性用于属性的值依赖于实例的某个或多个状态，需要经过较为复杂的逻辑生成时</strong>。</p><p>计算属性定义在实例的<code>computed</code>属性中，其对应的函数相当于它的　<code>getter</code>　。当计算属性依赖的其他属性发生变化时，计算属性会同样进行更新。</p><p>计算属性的基础例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你购买了 &#123;&#123; good.name &#125;&#125; 共 &#123;&#123; good.count &#125;&#125; 件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>需支付: &#123;&#123; total_money &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="undefined">    data:&#123;</span></span><br><span class="line"><span class="undefined">        good:&#123;</span></span><br><span class="line"><span class="javascript">            name:<span class="string">'可乐'</span>,</span></span><br><span class="line"><span class="javascript">            price:<span class="number">5</span>,<span class="comment">//价格</span></span></span><br><span class="line"><span class="javascript">    count:<span class="number">4</span>,<span class="comment">//件数</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">        delivery:７, <span class="comment">//配送费</span></span></span><br><span class="line"><span class="javascript">        rebate:<span class="number">0.8</span>, <span class="comment">//折扣</span></span></span><br><span class="line"><span class="javascript">        text: <span class="string">'请付款'</span>　　　　　　　<span class="comment">//提示语</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    computed:&#123;</span></span><br><span class="line"><span class="javascript">        total: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> (<span class="keyword">this</span>.good.price　* <span class="keyword">this</span>.good.count * <span class="keyword">this</span>.rebate) + <span class="keyword">this</span>.delivery</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的<code>setter</code></h4><p>计算属性的值除了定义为一个作用相当于 <code>getter</code>　的函数外，同样可以定义 <code>setter</code>，用于在主动改变计算属性值时进行相应的操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.....</span></span><br><span class="line"><span class="undefined">computed:&#123;</span></span><br><span class="line"><span class="undefined">    total:&#123;</span></span><br><span class="line"><span class="javascript">        get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> (<span class="keyword">this</span>.good.price　* <span class="keyword">this</span>.good.count * <span class="keyword">this</span>.rebate) + <span class="keyword">this</span>.delivery;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.text = <span class="string">'请不要擅自修改总价！！！'</span>        </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">......</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="计算属性与方法的不同点"><a href="#计算属性与方法的不同点" class="headerlink" title="计算属性与方法的不同点"></a>计算属性与方法的不同点</h4><p>计算属性是<strong>基于它的依赖进行缓存的</strong>。也就是说，当重复使用计算属性时，如果它依赖的那些属性没有变化的话，计算属性的对应函数不会被重复调用，而是直接返回缓存的值。</p><p>而方法在每次调用时，都会执行。</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><code>Vue</code>通过侦听器来进行数据侦听，响应数据的变化。主要用于在数据变化时<strong>执行一些开销较大或异步的操作</strong>。如数据请求和<code>Ajax</code>请求。</p><p>侦听器主要在实例的<code>watch</code>属性中定义，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="undefined">    data:&#123;</span></span><br><span class="line"><span class="javascript">        question:<span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        answer:<span class="string">'to be'</span>,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    watch:&#123;</span></span><br><span class="line"><span class="javascript">        question:<span class="function"><span class="keyword">function</span>(<span class="params">newvalue,oldvalue</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $ajax(<span class="string">'www.baidu.com'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="keyword">this</span>.answer = res)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="计算属性和侦听器的不同"><a href="#计算属性和侦听器的不同" class="headerlink" title="计算属性和侦听器的不同"></a>计算属性和侦听器的不同</h4><p>计算属性相比侦听器，代码更清晰简明。计算属性完全基于其依赖的属性。</p><p>对于一些异步的操作或需要对数据变化更复杂的响应时，计算属性无法实现，只能使用侦听器。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue系列（一）:基础概念</title>
      <link href="/2018/01/10/Vue%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>/2018/01/10/Vue%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>对于<code>Vue</code>这一个中国人自己开发的前端框架，我一直有着非常大的兴趣和好奇。以前只是边边角角的了解过一些，这次打算从头到尾，真正细致系统的学习一下这个号称<code>渐进式增强</code>的前端框架。</p><p>作为<code>Vue</code>系列的第一篇，送上一句但丁的名言给自己：</p><p><strong><em>人生就像一支箭，不能回头，回头就意味着坠落。</em></strong></p><p>我相信所有努力的人，也都一定会是有回报的，加油。</p></blockquote><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a>创建Vue实例</h5><ol><li>使用 <code>new Vue()</code>来生成一个 <code>Vue</code> 实例，其接收一个对象参数。</li><li>对象参数的 <code>el</code> 属性为实例绑定的 <code>DOM</code> 元素</li><li>对象参数的 <code>data</code> 属性为 实例所拥有的 数据</li><li>对象参数的 <code>methods</code> 为 实例所拥有的 方法</li></ol><h5 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h5><ol><li>使用 双花括号式 的插值表达式 将实例数据绑定到 <code>DOM</code></li><li>使用 <code>v-bind</code> 指令将数据绑定到 <code>DOM</code> 元素特性,形如 <code>v-bind:title = &quot;somedata&quot;</code></li></ol><h5 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h5><p>使用 <code>v-model</code> 指令将 Vue实例数据 与表单进行双向绑定, 形如 <code>v-model = &quot;somedata&quot;</code></p><h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>使用 <code>v-on</code> 指令将 Vue 实例的函数绑定到元素的事件响应,形如 <code>v-on:click = &quot;funcname&quot;</code></p><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>使用 <code>v-if</code> 指令来控制条件渲染</p><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>使 用 <code>v-for</code>指令来重复渲染数组内数据,形如 <code>v-for = &quot;item in array&quot;</code></p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p>在<code>Vue</code> 中, 一个组件本质上是一个拥有预定义选项(例如模板选项)的 <code>Vue</code>实例 。<br>使用 <code>Vue.component()</code> 来注册组件,第一个参数为组件名，第二个参数为组件的预定义选项。形如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component('a-com',&#123;</span><br><span class="line">    props:['input_data']       //相当于输入属性，使用 v-bind 将数据绑定到此输入属性</span><br><span class="line">    template:'<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;input_data.text&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>注意事项：</p><pre><code>1. 组件的注册必须在组件要绑定的数据声明前（可能是与 Vue 的生命周期有关）</code></pre><h4 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a><code>Vue</code> 实例</h4><p>通过 <code>Vue</code> 构造函数创建一个 <code>Vue</code> 实例，通常使用变量名<code>vm（ViewModel）</code>来表示<code>Vue</code> 实例。<br>所有的组件都是<code>Vue</code> 实例。一个 <code>Vue</code> 应用是由一个根实例 和多个可选的嵌套的组件树组成。</p><h5 id="数据属性-data"><a href="#数据属性-data" class="headerlink" title="数据属性  data"></a>数据属性 <code>data</code></h5><p><strong>创建 <code>Vue</code> 实例时</strong>其中的 <code>data</code> 属性对象中的所有属性都会被加入 <code>Vue</code> 的响应式系统中。<br>使用 <code>Object.freeze()</code> 可冻结对象类型的响应属性。</p><h5 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h5><p><code>Vue</code> 实例还暴露了一些 实例属性 和 方法,均以 <code>$</code> 为前缀。</p><p><code>$data</code> ：实例的数据属性对象。</p><p><code>$el</code> ：实例绑定的 <code>DOM</code> 对象。</p><p><code>$watch</code> ：实例的一个方法，用于为数据的改变添加回调。</p><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p><code>Vue</code> 的生命周期主要包括 <strong>设置数据监听</strong>，<strong>编译模板</strong>，<strong>将实例挂载到<code>DOM</code></strong>，<strong>更新</strong>，<strong>销毁</strong> 这几个阶段。</p><p>在生命周期各个阶段会有相应的被称为 <strong>生命周期钩子</strong> 的函数运行。有以下几个函数：</p><ul><li><code>beforeCreate</code><ul><li>在此阶段 <code>Vue</code> 实例开始响应式监听 <code>data</code> 的数据。</li></ul></li><li><code>created</code><ul><li>在此阶段编译 <code>DOM</code> 元素（编译的 <code>DOM</code> 元素为<code>虚拟 DOM</code>，还未将 <code>data</code> 渲染进去。）</li><li>首先判断是否有 <code>$el</code> 属性，若无则停止生命周期，直到使用 <code>vm.$mount(el)</code>绑定 <code>$el</code> 属性</li><li>若存在 <code>template</code>，则使用其编译模板，若不存在则使用 <code>outerHTML</code> 编译模板。</li></ul></li><li><code>beforemount</code><ul><li>在此阶段将 <code>data</code> 数据渲染到上一步编译模板形成的虚拟 <code>DOM</code> 中 形成 <code>Vue</code> 的 <code>$el</code>替换掉<code>虚拟DOM</code></li></ul></li><li><code>mounted</code></li><li><code>beforeUpdate</code><ul><li>在此阶段组件重新渲染</li></ul></li><li><code>updated</code></li><li><code>beforeDestory</code><ul><li>此阶段 移除实例所有的数据和事件绑定，并销毁所有子实例。</li></ul></li><li><code>destoryed</code><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4></li></ul><h5 id="文本"><a href="#文本" class="headerlink" title="#文本"></a>#文本</h5><p>使用插值表达式（双大括号）进行数据绑定，形如 <code>&lt;span&gt;&lt;/span&gt;</code></p><p>使用 <code>v-once</code> 指令来执行一次性的插值。(当数据改变时，插值内容不会更新)，形如 <code>&lt;span v-once&gt; &lt;/span&gt;</code></p><p>插值表达式会将数据解释为普通文本，若需要插入 <code>HTML</code>内容(插入内容中的数据绑定会被忽略)，可使用 <code>v-html</code> 指令。形如</p><p><code>&lt;span v-html=&#39;htmltext&#39;&gt;&lt;/span&gt;</code></p><h5 id="元素特性"><a href="#元素特性" class="headerlink" title="#元素特性"></a>#元素特性</h5><p>使用 <code>v-bind</code> 指令将数据绑定到元素特性。</p><h5 id="模板表达式"><a href="#模板表达式" class="headerlink" title="#模板表达式"></a>#模板表达式</h5><p>在所有数据绑定中都可以使用 <code>js</code> 表达式，但限制是只能使用单个表达式（不能使用语句）</p><p>模板表达式位于 <code>Vue</code> 实例的数据作用域下，只能访问全局变量的一个白名单，例如 <code>Math对象</code>和 <code>Date对象</code>。</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令是指带有 <code>v-</code> 前缀的特殊属性。除 <code>v-for</code>外，指令的预期值都为 <strong>单个js表达式</strong>。</p><p>指令的作用是 <strong>当表达式值改变时，将其产生的连带影响，响应式的作用于 <code>DOM</code></strong></p><h5 id="参数"><a href="#参数" class="headerlink" title="#参数"></a>#参数</h5><p>一些指令能接收一个 ‘参数’，跟在指令的冒号后。形如 <code>v-bind:title=&quot;text&quot;</code> 。</p><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="#修饰符"></a>#修饰符</h5><p>修饰符是以 <code>.</code> 跟随在指令后的一个特殊后缀，用于指明指令以特殊方式绑定。形如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--此 prevent 修饰符用于指定指令在事件触发式调用 event.preventDefault()--&gt;</span><br><span class="line">&lt;form v-on:sumbit.prevent=&quot;onSumbit&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure><h5 id="缩写"><a href="#缩写" class="headerlink" title="#缩写"></a>#缩写</h5><p><code>v-bind</code> 可缩写为 <code>：</code> 。</p><p>S<code>v-on</code> 可缩写为 <code>@</code> 。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS库 Mock 使用指南</title>
      <link href="/2017/12/22/JS%E5%BA%93Mock%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2017/12/22/JS%E5%BA%93Mock%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>对于前端开发来说，Ajax 请求是必不可少的，但是很多时候前后端分离的项目，前端需要接口来进行页面逻辑开发，可后端接口还没有开发完全，或者我们自己写一些前端小测试Demo，不想很麻烦的去自己搭环境写后端。你肯定会想，要是有一个模拟接口的工具就好了，我们只需要定义好数据格式，就可以把它当做真接口来使用，完全不需要后端就能进行前端开发。</p><p><code>Mock.js</code>就是来做这件事的。</p><p><code>Mock.js</code> 是用于帮助前端攻城狮进行前后端分离开发的一个 JS 库。它能够无侵入的拦截 <code>ajax</code> 请求，生成多种随机数据如文本，数字，布尔值，图片等。从而使前端攻城狮能够方便快捷的处理需要后端接口返回数据情况下的前端开发。</p></blockquote><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>mock.js</code> 可以通过 Node 方便的安装，只需要以下命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><p>​ 然后就可以在文件中通过 <code>require</code> 使用 Mock 库了。</p><p>​ 更简单的方法是直接在 HTML 文件中引入 mock.js 文件。类似如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://mockjs.com/dist/mock.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>一个简单的例子如下:</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(</span><br><span class="line">    <span class="string">'www.a.com/user'</span>, &#123;</span><br><span class="line">        <span class="string">"id|1-1000"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"@cname"</span>,</span><br><span class="line">        <span class="string">"birthday: "</span>@date(<span class="string">'yy-MM-DD'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在进行如上定义后，我们就可以在项目中直接使用我们定义的<strong><em>url</em></strong>来作为模拟接口了，<code>Mock库</code>会自动的拦截<code>Ajax</code>请求，我们不需要额外的做任何事情，可以完全的将<strong><em>url</em></strong>当做真正的接口来使用。</p><h3 id="API-详解"><a href="#API-详解" class="headerlink" title="API 详解"></a><strong><em>API </em></strong>详解</h3><h4 id="Mock-mock"><a href="#Mock-mock" class="headerlink" title="Mock.mock"></a><strong><em>Mock.mock</em></strong></h4><p><code>Mock</code>的核心方法, 就像我们上面的例子中那样，它接受三个参数，具体如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(rurl?,rtype?,template|<span class="function"><span class="keyword">function</span>(<span class="params">options</span>))</span></span><br></pre></td></tr></table></figure><p></p><p>解释一下三个参数：</p><ul><li><p><code>rurl</code></p><p>可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。</p></li><li><p><code>rtype</code></p><p>同样可选。表示需要拦截的 Ajax 请求类型。如 GET，POST，PUT，DELETE等。</p></li><li><p><code>template</code></p><p>可选。表示数据模板，可以是对象或字符串，关于数据模板，就是<code>Mock</code>生成假接口返回数据格式的模板，具体在下面会详细解释。</p></li><li><p><code>function(options)</code></p><p>可选，用于通过函数来自定义响应数据，不依赖于模板。一般使用在接口的交互比较复杂的情况下。</p><p><code>options</code>参数为指向本次请求的 Ajax 选项集，含有请求路径 <code>url</code>,请求类型<code>type</code>,请求体<code>body</code>三个属性。</p></li></ul><hr><p>如上所说，<code>Mock.mock()</code>的多个参数都是可选的。根据选择的参数的不同，主要有以下几种调用形式：</p><ul><li><p><code>Mock.mock(template)</code></p><p>根据数据模板生成模拟数据，并直接返回。</p></li><li><p><code>Mock.mock(rurl,template)</code></p><p>记录数据模板。当拦截到匹配 <code>rurl</code> 的 Ajax 请求时，根据数据模板 <code>template</code> 生成模拟数据，并作为响应数据返回。</p></li><li><p><code>Mock.mock(rurl,function( options ))</code></p><p>记录用于生成响应数据的函数。当拦截到匹配 <code>rurl</code>的 Ajax 请求时，函数 <code>function(options)</code> 将被执行，函数执行结果作为响应数据返回。</p></li><li><p><code>Mock.mock(rulr,rtype,function( options ))</code></p><p>记录用于生成响应数据的函数，当拦截到匹配 <code>rurl</code> 和 <code>rtype</code> 的 Ajax 请求时，函数 <code>function(options)</code> 将被执行，并把执行结果作为响应数据返回。</p></li></ul><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p><code>Mock.mock</code>方法可以根据数据模板来生成模拟数据。数据模板相当于我们定义的一个返回数据格式。<br>对于返回数据的每个属性，我们都可以定义生成规则来产生符合规则的随机值，使我们的假接口适用范围更多，更逼真。</p><p>数据模板中的每个属性定义类似如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性名   name</span></span><br><span class="line"><span class="comment">// 生成规则 rule</span></span><br><span class="line"><span class="comment">// 属性值   value</span></span><br><span class="line"><span class="string">'name|rule'</span>: value</span><br></pre></td></tr></table></figure><p></p><p>就像上面例子中的<code>id|1-100: 1</code>，就是表示假接口相应的数据中有一个<code>id</code>属性，它的值为一个 1-100 的随机数。</p><p>有多种生成规则，关于生成规则的约定具体如下：</p><ul><li>生成规则是可选的。</li><li>生成规则有 7 种格式：<ol><li><code>&#39;name|min-max&#39;: value</code></li><li><code>&#39;name|count&#39;: value</code></li><li><code>&#39;name|min-max.dmin-dmax&#39;: value</code></li><li><code>&#39;name|min-max.dcount&#39;: value</code></li><li><code>&#39;name|count.dmin-dmax&#39;: value</code></li><li><code>&#39;name|count.dcount&#39;: value</code></li><li><code>&#39;name|+step&#39;: value</code></li></ol></li></ul><ul><li><p><em>属性值</em> 中可以含有 <code>@占位符</code>。关于占位符，<code>Mock.random</code>中的所有方法，都可以通过占位符来轻松愉快的引用，占位符与<code>Mock.Random</code>类中对应的方法同样的参数。<br>我们上面例子中的<code>&quot;name&quot;:&#39;@cname&#39;</code>即表示生成一个随机的中文名。同时，占位符也可以引用数据模板中的属性，类似如下数据模板：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"height|1-100"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"width|1-100"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"area"</span>: <span class="string">"@height * @width"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>属性值</em> 的类型，即为响应数据值的初始值和类型。</p></li></ul><p>对于不同的属性值来说，上面的生成规则，具有不同的效果。我们来一一说明:</p><p><strong>当属性值是字符串 String</strong></p><ol><li><p><code>&#39;name|count&#39;: string</code></p><p>​ 通过重复 <code>string</code> 生成一个字符串，重复次数等于 <code>count</code>。</p></li><li><p><code>&#39;name|min-max&#39;: string</code></p><p>通过重复 <code>string</code> 生成一个字符串，重复次数大于等于 <code>min</code>，小于等于 <code>max</code>。</p></li></ol><p><strong>属性值是数字 Number</strong></p><ol><li><p><code>&#39;name|+1&#39;: number</code></p><p>属性值自动加 1，初始值为 <code>number</code>。</p></li><li><p><code>&#39;name|min-max&#39;: number</code></p><p>生成一个大于等于 <code>min</code>、小于等于 <code>max</code> 的整数，属性值 <code>number</code> 只是用来确定类型。</p></li><li><p><code>&#39;name|min-max.dmin-dmax&#39;: number</code></p><p>生成一个浮点数，整数部分大于等于 <code>min</code>、小于等于 <code>max</code>，小数部分保留 <code>dmin</code> 到 <code>dmax</code>位。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(&#123;</span><br><span class="line">    <span class="string">'number1|1-100.1-10'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'number2|123.1-10'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'number3|123.3'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'number4|123.10'</span>: <span class="number">1.123</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"number1"</span>: <span class="number">12.92</span>,</span><br><span class="line">    <span class="string">"number2"</span>: <span class="number">123.51</span>,</span><br><span class="line">    <span class="string">"number3"</span>: <span class="number">123.777</span>,</span><br><span class="line">    <span class="string">"number4"</span>: <span class="number">123.1231091814</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性值是布尔型 Boolean</strong></p><ol><li><p><code>&#39;name|1&#39;: boolean</code></p><p>随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</p></li><li><p><code>&#39;name|min-max&#39;: value</code></p><p>随机生成一个布尔值，值为 <code>value</code> 的概率是 <code>min / (min + max)</code>，值为 <code>!value</code> 的概率是 <code>max / (min + max)</code>。</p></li></ol><p><strong>属性值是数组 Array</strong></p><ol><li><p><code>&#39;name|1&#39;: array</code></p><p>从属性值 <code>array</code> 中随机选取 1 个元素，作为最终值。</p></li><li><p><code>&#39;name|+1&#39;: array</code></p><p>从属性值 <code>array</code> 中顺序选取 1 个元素，作为最终值。</p></li><li><p><code>&#39;name|min-max&#39;: array</code></p><p>通过重复属性值 <code>array</code> 生成一个新数组，重复次数大于等于 <code>min</code>，小于等于 <code>max</code>。</p></li><li><p><code>&#39;name|count&#39;: array</code></p><p>通过重复属性值 <code>array</code> 生成一个新数组，重复次数为 <code>count</code>。</p></li></ol><p><strong>属性值是对象 Object</strong></p><ol><li><p><code>&#39;name|count&#39;: object</code></p><p>从属性值 <code>object</code> 中随机选取 <code>count</code> 个属性。</p></li><li><p><code>&#39;name|min-max&#39;: object</code></p><p>从属性值 <code>object</code> 中随机选取 <code>min</code> 到 <code>max</code> 个属性。</p></li></ol><p><strong>属性值是函数 Function</strong></p><ol><li><p><code>&#39;name&#39;: function</code></p><p>执行函数 <code>function</code>，取其返回值作为最终的属性值，函数的上下文为属性 <code>&#39;name&#39;</code> 所在的对象。</p></li></ol><p><strong>属性值是正则表达式 RegExp</strong></p><ol><li><p><code>&#39;name&#39;: regexp</code></p><p>根据正则表达式 <code>regexp</code> 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(&#123;</span><br><span class="line">    <span class="string">'regexp1'</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span>,</span><br><span class="line">    <span class="string">'regexp2'</span>: <span class="regexp">/\w\W\s\S\d\D/</span>,</span><br><span class="line">    <span class="string">'regexp3'</span>: <span class="regexp">/\d&#123;5,10&#125;/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"regexp1"</span>: <span class="string">"pJ7"</span>,</span><br><span class="line">    <span class="string">"regexp2"</span>: <span class="string">"F)\fp1G"</span>,</span><br><span class="line">    <span class="string">"regexp3"</span>: <span class="string">"561659409"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a><strong><em>Mock.Random</em></strong></h4><p><code>Mock.Random</code> 是Mock的一个工具类，可以借助它来生成各种随机数据。<br>在上面我们说过，它的各种方法可以在数据模板中通过占位符来引用。<br>也即是说，我们可以通过以下方式来使用 <strong><em>Random</em></strong> 的各种方法。<br>以<code>email</code>生成一个随机邮箱的方法举例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mock.Random.email()</span><br><span class="line">// =&gt; &quot;a.b@c.com&quot;</span><br><span class="line"></span><br><span class="line">Mock.mock(&apos;@email&apos;)</span><br><span class="line"></span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">    &apos;email&apos;: &apos;@email&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><code>Random</code>类中有各种生成随机数据的方法。可以分为以下几类：</p><p>基础数据</p><ul><li>boolean,integer,natural, float, character, string, range, date , time, datetime, now</li></ul><p>姓名</p><ul><li>first, last, name</li><li>cfirst, clast, cname (c开头标识中文)</li></ul><p>文本</p><ul><li>paragraph,sentence,word,title</li><li>cparagraph,csentence,cword,ctitle　(c开头标识中文)</li></ul><p>日期</p><ul><li>date, time, datetime,now</li></ul><p>标识</p><ul><li>guid, id</li></ul><p>图片</p><ul><li>image, dataImage</li></ul><p>网址</p><ul><li>url, domain, email, ip, tld</li></ul><p>地址</p><ul><li>area, region</li></ul><p>颜色</p><ul><li>color,hex,rgb,rgba,hsl</li></ul><p>其他</p><ul><li>capitalize, upper, lower, pick, shuffle</li></ul><p>这些随机方法从名字就可以看出是要随机生成什么数据。在此只做简单介绍，如果需要更详细的使用方法，可以去查阅<a href="https://github.com/nuysoft/Mock/wiki/Mock.Random" target="_blank" rel="noopener">MockJs的文档</a></p><h4 id="Mock-valid"><a href="#Mock-valid" class="headerlink" title="Mock.valid"></a><strong><em>Mock.valid</em></strong></h4><p><code>Mock.valid(template, data)</code>, 用于检验真实数据<code>data</code>与数据模板<code>template</code>是否匹配，通常用于确定我们书写的数据模板是否可以正确的返回我们所需的数据。</p><h4 id="Mock-setup"><a href="#Mock-setup" class="headerlink" title="Mock.setup"></a><strong><em>Mock.setup</em></strong></h4><p>用于设置拦截<code>Ajax</code>请求时的配置，目前只支持<code>timeout</code>这一个配置项，用于指定拦截请求时的相应时间。<br></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: <span class="number">400</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//　也可以是字符串格式的范围</span></span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">    timeout: <span class="string">'200-300'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p>关于<code>MockJs</code>的基本使用，大概就是这些，这是一个相当简单的库，却相当的有用，尤其是在前端开发中，能在项目开发和个人学习中给我们提供很多帮助。<br>这篇博客就到这里，谢谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序的支付和退款流程</title>
      <link href="/2017/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%94%AF%E4%BB%98%E5%92%8C%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/11/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%94%AF%E4%BB%98%E5%92%8C%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>近期在做微信小程序时，涉及到了小程序的支付和退款流程，所以也大概的将这方面的东西看了一个遍，就在这篇博客里总结一下。</p><p>首先说明一下，微信小程序支付的<strong>主要逻辑集中在后端</strong>，前端只需携带支付所需的数据请求后端接口然后根据返回结果做相应成功失败处理即可。我在后端使用的是php，当然在这篇博客里我不打算贴一堆代码来说明支付的具体实现，而主要会侧重于整个支付的流程和一些细节方面的东西。所以使用其他后端语言的朋友有需要也是可以看一下的。很多时候开发的需求和相应问题的解决真的要跳出语言语法层面，去从系统和流程的角度考虑。好的，也不说什么废话了。进入正题。</p></blockquote><a id="more"></a><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>支付主要分为几个步骤：</p><ol><li>前端携带支付需要的数据发起支付请求</li><li>后端在接收到支付请求后，处理支付数据，然后携带处理后的支付数据请求 <strong>微信服务器</strong> 的 <strong>支付统一下单接口</strong></li><li>后端接收到上一步请求微信服务器的返回数据，再次处理，然后返回前端让前端可以开始支付。</li><li>前端进行支付动作</li><li>前端支付完成后，微信服务器会向后端发送支付通知（也就是微信要告诉你客户已经付过钱了），后端根据这个通知确定支付完成，然后就去做支付完成后的相应动作，比如修改订单状态，添加交易日志啊等等。</li></ol><p>从这几个步骤可以看出，后端主要的作用就是将支付需要的数据传给微信服务器，再根据微信服务器的响应确定支付是否完成。</p><p>这个流程还是蛮容易理解的。形象的说，前端就是个顾客，后端就是店家，微信服务器的统一下单接口就像收银员。顾客跟店家说，我是谁谁谁，现在我要付多少多少钱给你买什么什么。店家就跟收银员说，那个谁谁谁要付多少钱，你准备收钱吧。收银员收到钱后，就去告诉店家，我已经收到钱了，你给他东西吧。</p><p>下面就详细的说明一下<strong>各个步骤的具体实现</strong>。</p><h4 id="前端请求支付"><a href="#前端请求支付" class="headerlink" title="前端请求支付"></a>前端请求支付</h4><p>​ 前端请求支付，就是简单的携带支付需要的数据，例如用户标识，支付金额，支付订单 ID 等等跟 <strong>你的业务逻辑有关</strong> 或者跟 <strong>下一步请求微信服务器支付统一下单接口需要的数据有关</strong> 的相关数据，使用微信小程序的 wx.request( ) 去请求后端的支付接口。</p><h4 id="后端请求微信服务器"><a href="#后端请求微信服务器" class="headerlink" title="后端请求微信服务器"></a>后端请求微信服务器</h4><p>​ 后端接收到前端发送的支付请求后，可以进行一下相关验证，例如判断一下用户有没有问题，支付金额对不对等等。</p><p>​ 在验证没什么问题，可以向微信服务器申请支付之后，后端需要使用 <strong>微信规定的数据格式</strong> 去请求微信的支付统一下单接口。</p><p>微信规定的请求数据 这需要较多代码实现。因为需要的数据个数较多，而且还需要加密并以 XML 格式发送。</p><p>首先，有以下数据是使用小程序支付必须提供给微信服务器的参数。</p><ul><li><p>小程序 <code>appid</code>。写小程序的大概没有不知道这个的。。。</p></li><li><p>用户标识 <code>openid</code>。也就是用户的小程序标识，在我<a href="http://www.cnblogs.com/afei-qwerty/p/7161634.html" target="_blank" rel="noopener">上篇博客</a>中说明了如何获取。</p></li><li><p>商户号 <code>mch</code>_id 。申请开通微信支付商户认证成功后微信发给你的邮件里有</p></li><li><p>商户订单号 <code>out_trade_no</code> 。商户为这次支付生成的订单号</p></li><li><p>总金额 <code>total_fee</code> 。订单总金额，很重要的一点是<strong>单位是分</strong>，要特别注意。</p></li><li><p>微信服务器回调通知接口地址 <code>notify_url</code>。微信确认钱已经到账后，会往这个地址多次发送消息，告诉你顾客已经付完钱了，你需要返回消息给微信表示你已经收到了通知。。这个地址不能有端口号，同时要能直接接受<code>POST</code>方法请求。</p></li><li><p>交易类型 <code>trade_type</code> 。微信小程序支付此值统一为 <code>JSAPI</code></p></li><li><p>商品信息 <code>Body</code>。类似<strong>“腾讯-游戏”</strong>这种格式</p></li><li><p>终端IP地址 <code>spbill_create_ip</code> 。终端地址IP，也就是请求支付的 IP 地址。</p></li><li><p>随机字符串 <code>nonce_str</code> 。需要后端随机生成的字符串用于保证数据安全。微信要求不长于32位。</p></li><li><p>签名 <code>sign</code> 。使用上面的所有参数进行相应处理加密生成签名。</p></li></ul><p>在处理好以上所有数据后，将这些数据以 XML 格式整理并以 POST 方法发送到 <strong>微信支付统一下单接口</strong> <a href="https://api.mch.weixin.qq.com/pay/unifiedorder" target="_blank" rel="noopener">https://api.mch.weixin.qq.com/pay/unifiedorder</a> 。</p><h4 id="3-后端接受微信服务器返回数据"><a href="#3-后端接受微信服务器返回数据" class="headerlink" title="3.后端接受微信服务器返回数据"></a>3.后端接受微信服务器返回数据</h4><p>微信服务器在接收到支付数据之后，如果数据没有问题，其会返回用于支付的相应数据，其中非常重要的是 名称为 prepay_id 的数据字段，需要将此数据返回前端，前端才能继续支付。</p><p>因此，在后端接收到微信服务器的返回数据后，需要进行相应的处理，最终返回到前端如下数据：</p><ul><li>appid 不需多说</li><li>timeStamp 当前时间戳<ul><li>nonceStr 随机字符串</li><li>package 就是上面提到的 prepay_id，不过切记格式如 “prepay_id= prepay_id_item“。否则会导致错误。</li><li>signType 加密方式，一般应该是 MD5</li><li>paySign 对以上数据进行相应处理并加密。</li></ul></li></ul><p>到这里，后端的支付接口已经完成了接收前端支付请求，并返回了前端支付所需数据的功能。</p><h4 id="前端发起支付"><a href="#前端发起支付" class="headerlink" title="前端发起支付"></a>前端发起支付</h4><p>​ 前端在接收到返回数据后，使用 <code>wx.requestPayment()</code>来请求发起支付。此 API 需要的对象参数各项值就是我们上一步返回的各个数据。</p><h4 id="后端接受微信服务器回调"><a href="#后端接受微信服务器回调" class="headerlink" title="后端接受微信服务器回调"></a>后端接受微信服务器回调</h4><p>​ 前端完成支付后，微信服务器确认支付已经完成。就会向第一步中设置的回调地址发送通知。后端的接收回调接口在接收到通知后，就可以判断支付是否完成，从而决定后续动作。</p><p>​ 需要注意的是，在接收到微信服务器的回调通知后，需要返回success数据向微信服务器告知已得到回调通知。否则微信服务器会不停的向后端发送消息。</p><p>​ 微信的大概支付流程就是这样。以下是PHP语法的微信支付类，可以比照上面的步骤介绍，加深理解。在需要支付时，直接传入参数实例化此类再调用类的 pay 方法即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//微信支付类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXinPay</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=======【基本信息设置】=====================================</span></span><br><span class="line">    <span class="comment">//微信公众号身份的唯一标识</span></span><br><span class="line">    <span class="keyword">protected</span> $APPID = appid;<span class="comment">//填写您的appid。微信公众平台里的</span></span><br><span class="line">    <span class="keyword">protected</span> $APPSECRET = secret;</span><br><span class="line">    <span class="comment">//受理商ID，身份标识</span></span><br><span class="line">    <span class="keyword">protected</span> $MCHID = <span class="string">'11111111'</span>;<span class="comment">//商户id</span></span><br><span class="line">    <span class="comment">//商户支付密钥Key</span></span><br><span class="line">    <span class="keyword">protected</span> $KEY = <span class="string">'192006250b4c09247ec02edce69f6a2d'</span>;</span><br><span class="line">    <span class="comment">//回调通知接口</span></span><br><span class="line">    <span class="keyword">protected</span> $APPURL =      <span class="string">'https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers'</span>;</span><br><span class="line">    <span class="comment">//交易类型</span></span><br><span class="line">    <span class="keyword">protected</span> $TRADETYPE = <span class="string">'JSAPI'</span>;</span><br><span class="line">    <span class="comment">//商品类型信息</span></span><br><span class="line">    <span class="keyword">protected</span> $BODY = <span class="string">'wx/book'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//微信支付类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($openid,$outTradeNo,$totalFee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;openid = $openid; <span class="comment">//用户唯一标识</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;outTradeNo = $outTradeNo; <span class="comment">//商品编号</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;totalFee = $totalFee; <span class="comment">//总价</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//微信支付类向外暴露的支付接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;weixinapp();</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//对微信统一下单接口返回的支付相关数据进行处理</span></span><br><span class="line">     <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">weixinapp</span><span class="params">()</span></span>&#123;</span><br><span class="line">         $unifiedorder=<span class="keyword">$this</span>-&gt;unifiedorder();</span><br><span class="line"></span><br><span class="line">         $parameters=<span class="keyword">array</span>(</span><br><span class="line">          <span class="string">'appId'</span>=&gt;<span class="keyword">$this</span>-&gt;APPID,<span class="comment">//小程序ID</span></span><br><span class="line">          <span class="string">'timeStamp'</span>=&gt;<span class="string">''</span>.time().<span class="string">''</span>,<span class="comment">//时间戳</span></span><br><span class="line">          <span class="string">'nonceStr'</span>=&gt;<span class="keyword">$this</span>-&gt;createNoncestr(),<span class="comment">//随机串</span></span><br><span class="line">          <span class="string">'package'</span>=&gt;<span class="string">'prepay_id='</span>.$unifiedorder[<span class="string">'prepay_id'</span>],<span class="comment">//数据包</span></span><br><span class="line">          <span class="string">'signType'</span>=&gt;<span class="string">'MD5'</span><span class="comment">//签名方式</span></span><br><span class="line">             );</span><br><span class="line">         $parameters[<span class="string">'paySign'</span>]=<span class="keyword">$this</span>-&gt;getSign($parameters);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> $parameters;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *请求微信统一下单接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">unifiedorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $parameters = <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'appid'</span> =&gt; <span class="keyword">$this</span>-&gt;APPID,<span class="comment">//小程序id</span></span><br><span class="line">            <span class="string">'mch_id'</span>=&gt; <span class="keyword">$this</span>-&gt;MCHID,<span class="comment">//商户id</span></span><br><span class="line">            <span class="string">'spbill_create_ip'</span>=&gt;$_SERVER[<span class="string">'REMOTE_ADDR'</span>],<span class="comment">//终端ip</span></span><br><span class="line">            <span class="string">'notify_url'</span>=&gt;<span class="keyword">$this</span>-&gt;APPURL, <span class="comment">//通知地址</span></span><br><span class="line">            <span class="string">'nonce_str'</span>=&gt; <span class="keyword">$this</span>-&gt;createNoncestr(),<span class="comment">//随机字符串</span></span><br><span class="line">            <span class="string">'out_trade_no'</span>=&gt;<span class="keyword">$this</span>-&gt;outTradeNo,<span class="comment">//商户订单编号</span></span><br><span class="line">            <span class="string">'total_fee'</span>=&gt;floatval(<span class="keyword">$this</span>-&gt;totalFee), <span class="comment">//总金额</span></span><br><span class="line">            <span class="string">'open_id'</span>=&gt;<span class="keyword">$this</span>-&gt;openid,<span class="comment">//用户openid</span></span><br><span class="line">            <span class="string">'trade_type'</span>=&gt;<span class="keyword">$this</span>-&gt;TRADETYPE,<span class="comment">//交易类型</span></span><br><span class="line">            <span class="string">'body'</span> =&gt;<span class="keyword">$this</span>-&gt;BODY, <span class="comment">//商品信息</span></span><br><span class="line">        );</span><br><span class="line">        $parameters[<span class="string">'sign'</span>] = <span class="keyword">$this</span>-&gt;getSign($parameters);</span><br><span class="line">        $xmlData = <span class="keyword">$this</span>-&gt;arrayToXml($parameters);</span><br><span class="line">        $xml_result = <span class="keyword">$this</span>-&gt;postXmlCurl($xmlData,<span class="string">'https://api.mch.weixin.qq.com/pay/unifiedorder'</span>,<span class="number">60</span>);</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;xmlToArray($xml_result);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//数组转字符串方法</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">arrayToXml</span><span class="params">($arr)</span></span>&#123;</span><br><span class="line">        $xml = <span class="string">"&lt;xml&gt;"</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $key=&gt;$val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_numeric($val))&#123;</span><br><span class="line">                $xml.=<span class="string">"&lt;"</span>.$key.<span class="string">"&gt;"</span>.$val.<span class="string">"&lt;/"</span>.$key.<span class="string">"&gt;"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 $xml.=<span class="string">"&lt;"</span>.$key.<span class="string">"&gt;&lt;![CDATA["</span>.$val.<span class="string">"]]&gt;&lt;/"</span>.$key.<span class="string">"&gt;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $xml.=<span class="string">"&lt;/xml&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> $xml;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">xmlToArray</span><span class="params">($xml)</span></span>&#123;</span><br><span class="line">        $array_data = json_decode(json_encode(simplexml_load_string($xml, <span class="string">'SimpleXMLElement'</span>, LIBXML_NOCDATA)), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> $array_data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送xml请求方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">postXmlCurl</span><span class="params">($xml, $url, $second = <span class="number">30</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line">        <span class="comment">//设置超时</span></span><br><span class="line">        curl_setopt($ch, CURLOPT_TIMEOUT, $second);</span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">FALSE</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="keyword">FALSE</span>); <span class="comment">//严格校验</span></span><br><span class="line">        <span class="comment">//设置header</span></span><br><span class="line">        curl_setopt($ch, CURLOPT_HEADER, <span class="keyword">FALSE</span>);</span><br><span class="line">        <span class="comment">//要求结果为字符串且输出到屏幕上</span></span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="keyword">TRUE</span>);</span><br><span class="line">        <span class="comment">//post提交方式</span></span><br><span class="line">        curl_setopt($ch, CURLOPT_POST, <span class="keyword">TRUE</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_POSTFIELDS, $xml);</span><br><span class="line">        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, <span class="number">20</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_TIMEOUT, <span class="number">40</span>);</span><br><span class="line">        set_time_limit(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//运行curl</span></span><br><span class="line">        $data = curl_exec($ch);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">if</span> ($data) &#123;</span><br><span class="line">            curl_close($ch);</span><br><span class="line">            <span class="keyword">return</span> $data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $error = curl_errno($ch);</span><br><span class="line">            curl_close($ch);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> WxPayException(<span class="string">"curl出错，错误码:$error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对要发送到微信统一下单接口的数据进行签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getSign</span><span class="params">($Obj)</span></span>&#123;</span><br><span class="line">         <span class="keyword">foreach</span> ($Obj <span class="keyword">as</span> $k =&gt; $v)&#123;</span><br><span class="line">          $Parameters[$k] = $v;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//签名步骤一：按字典序排序参数</span></span><br><span class="line">         ksort($Parameters);</span><br><span class="line">         $String = <span class="keyword">$this</span>-&gt;formatBizQueryParaMap($Parameters, <span class="keyword">false</span>);</span><br><span class="line">         <span class="comment">//签名步骤二：在string后加入KEY</span></span><br><span class="line">         $String = $String.<span class="string">"&amp;key="</span>.<span class="keyword">$this</span>-&gt;KEY;</span><br><span class="line">         <span class="comment">//签名步骤三：MD5加密</span></span><br><span class="line">         $String = md5($String);</span><br><span class="line">         <span class="comment">//签名步骤四：所有字符转为大写</span></span><br><span class="line">         $result_ = strtoupper($String);</span><br><span class="line">         <span class="keyword">return</span> $result_;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *排序并格式化参数方法，签名时需要使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">formatBizQueryParaMap</span><span class="params">($paraMap, $urlencode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $buff = <span class="string">""</span>;</span><br><span class="line">        ksort($paraMap);</span><br><span class="line">        <span class="keyword">foreach</span> ($paraMap <span class="keyword">as</span> $k =&gt; $v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>($urlencode)</span><br><span class="line">            &#123;</span><br><span class="line">               $v = urlencode($v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//$buff .= strtolower($k) . "=" . $v . "&amp;";</span></span><br><span class="line">            $buff .= $k . <span class="string">"="</span> . $v . <span class="string">"&amp;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $reqPar;</span><br><span class="line">        <span class="keyword">if</span> (strlen($buff) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            $reqPar = substr($buff, <span class="number">0</span>, strlen($buff)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $reqPar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成随机字符串方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createNoncestr</span><span class="params">($length = <span class="number">32</span> )</span></span>&#123;</span><br><span class="line">         $chars = <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789"</span>;</span><br><span class="line">         $str =<span class="string">""</span>;</span><br><span class="line">         <span class="keyword">for</span> ( $i = <span class="number">0</span>; $i &lt; $length; $i++ ) &#123;</span><br><span class="line">          $str.= substr($chars, mt_rand(<span class="number">0</span>, strlen($chars)<span class="number">-1</span>), <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> $str;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是微信支付的相关流程。在理清思路后，流程还是比较清晰和简单的。重点在于需要注意一些细节问题，例如数据格式，加密方法等。</p><h3 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h3><p>小程序退款的流程和付款需要的参数类似，除了一些细节上的不同，流程均是后端向微信服务器发送退款请求，前端逻辑较为简单。</p><p>首先退款的步骤通常如下:</p><ol><li>用户前端点击退款按钮后，后端接收到用户的退款请求呈现给商户，商户确定允许退款后，后端再发起向微信退款接口的请求来请求退款。</li><li>后端向微信退款接口发送请求后，得到响应信息，确定退款是否完成，根据退款是否完成再去进行改变订单状态等业务逻辑。</li></ol><p>退款的步骤相对微信支付来说比较简单。</p><p>值得注意的是，向微信退款接口请求退款后，根据得到的响应是可以直接确定退款是否完成的。不再需要设置专门的回调接口等待微信通知。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序的登录和登录状态维护</title>
      <link href="/2017/10/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86%E5%92%8C%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2017/10/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E9%99%86%E5%92%8C%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在微信小程序开发中，登录和登录状态维护，是一套比较固定的流程。</p><p>本篇博客对小程序的用户登录及登录状态的维护的流程，进行了总结和介绍。</p><p>也涉及到了获取用户信息这一常见的开发需求。</p></blockquote><a id="more"></a><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>微信小程序的登录主要步骤如下：</p><ol><li><p>客户端调用 <code>wx.login()</code> ，获得返回参数 <code>code</code></p></li><li><p>客户端调用 <code>wx.request()</code> 将 <code>code</code> 发送到服务器</p></li><li><p>服务器将 <code>code</code> 和存储在服务器的 <code>appid</code> 和 <code>appSecret</code> 共三个参数作为请求参数，向微信服务器接口发起请求获得返回参数 <code>openid</code> 和 <code>session_key</code> 。</p><p><code>openid</code> 是用户唯一标识。</p><p><code>session_key</code> 是针对用户数据进行加密签名的密匙。session_key在文件校验，获取用户信息时均需使用</p><p>微信服务器返回的两个参数一般为了安全起见，都不会发往客户端。</p><p>微信服务器的请求接口地址为：<code>https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</code></p></li><li><p>服务器使用 <code>openid</code> 和 <code>session_key</code> 生成 <code>3rd_session</code> 作为自己派发的登陆态标识<code>token</code>，将其发送到小程序客户端。</p><p>在生成 <code>3rd_session</code> 时，将 <code>3rd_session</code> 作为键，将<code>session_key + openid</code> 作为值，存储在 服务器的 <code>session</code> 存储中。每个<code>3rd_session</code>都需要设置一个失效时间。</p></li><li><p>小程序客户端将 <code>3rd_session</code> 存入 <code>storage</code></p></li><li><p>后续用户进入小程序时，首先调用<code>wx.checksession()</code> 检测登陆态，如果失败，重新发起登陆流程。</p></li><li><p>如果登陆状态未失效，则从 <code>storage</code> 中读取 <code>3rd_session</code>。在需要用户标识的 wx.request() 时作为用户标识发送到服务器检验,服务器判断其是否合法。</p></li></ol><h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><p>获取用户信息时，根据微信请求用户信息接口<code>wx.getUserinfo()</code>函数的请求参数<code>withCredentials</code>的布尔值及用户的登陆状态不同，会有不同的返回值。</p><ol><li><p><strong>当<code>withCredentials</code> 为 <code>true</code> 且 用户登陆态未到期</strong></p><p>返回的数据会包括 <code>encryptedData</code>，<code>iv</code>等敏感数据。如下：</p><ol><li><p><code>userinfo</code> 不包含敏感数据的用户信息</p></li><li><p><code>rawData</code> 不包含敏感数据的原始数据字符串,用于签名校验</p></li><li><p><code>signature</code>。 使用<code>sha1( rawData + sessionkey )</code> 得到的字符串，用于签名校验数据</p></li><li><p><code>encryptedData</code> 包含 <code>openId</code>，<code>unionId</code> 等用户敏感数据的加密数据</p></li><li><p><code>iv</code> 加密算法的初始向量</p></li></ol></li></ol><ol start="2"><li><p><strong>当withCredentials 为 <code>false</code> 时</strong></p><p>不要求登陆状态，返回数据不包含敏感数据。</p></li></ol><hr><h4 id="小程序的数据签名校验和数据解密"><a href="#小程序的数据签名校验和数据解密" class="headerlink" title="小程序的数据签名校验和数据解密"></a>小程序的数据签名校验和数据解密</h4><p><strong>签名校验(用于校验数据完整性等)：</strong></p><p>需要使用<code>session_key</code>。客户端将 <code>signature</code> 和 <code>rawData</code> 发送到服务器，服务器通过相同的 <code>sha1( rewData + session_key)</code> 算法计算出 <code>signature2</code>，并与客户端发送过来的<code>signature</code>对比，校验数据完整性。</p><hr><p><strong>加密数据encryptedData的解密：</strong></p><p>需要客户端将接口返回的<code>encryptedData</code>发送到服务器，服务器使用 <code>appId</code> 和 <code>session_key</code> ，根据加密算法的初始向量 <code>iv</code> 对 <code>encryptedData</code> 进行解密（微信提供有后端解密代码，包括python，php等(无java)</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端兼容相关的一些知识</title>
      <link href="/2017/08/18/%E5%89%8D%E7%AB%AF%E5%85%BC%E5%AE%B9%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/08/18/%E5%89%8D%E7%AB%AF%E5%85%BC%E5%AE%B9%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>由于各种原因，前端的兼容问题一直都是开发中不得不面对，又十分繁琐和令人苦恼的问题。</p><p>本文主要用于记录我在前端开发中遇到的一些浏览器兼容问题的解决方法。</p><p>会持续更新。。。。。</p></blockquote><a id="more"></a><h4 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h4><p>1.设置浏览器的兼容模式版本，表示如果在 IE 浏览器下<strong>使用最新标准渲染当前文档</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE-edge"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.条件注释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;!--用于在 IE 时让浏览器能识别 HTML5 标签&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">      &lt;!--用于在 IE 时让浏览器能识别 CSS3 媒体查询&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>​ 条件注释的作用：当判断条件满足时，就会执行注释中的 HTML 代码。</p><h4 id="移动端兼容"><a href="#移动端兼容" class="headerlink" title="移动端兼容"></a>移动端兼容</h4><p>1.视口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ 视口的作用 ：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，会将页面容器缩放到设备这么大，然后展示。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器兼容 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySql 的数据类型</title>
      <link href="/2017/08/14/MySql%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/08/14/MySql%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>MySql 作为常见的数据库，有多种数据类型，用于存储不同类型的一些数据。</p><p>本文主要对 MySql 的数据类型进行了一些介绍和总结。</p></blockquote><a id="more"></a><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p><strong>整数</strong></p><ul><li><p><code>TINYINT</code> 小整数值 （0-255 or -128-127) 1字节</p></li><li><p><code>SMALLINT</code> 大整数值 2字节</p></li><li><p><code>MEDIUMINT</code> 大整数值 3字节</p></li><li><p><code>INT</code> 或 <code>INTEGER</code> 大整数值 4字节</p></li><li><p><code>BIGINT</code> 极大整数值 8字节</p></li></ul><p><strong>浮</strong>点数</p><ul><li><code>FLOAT</code> 单精度浮点数值 4字节</li><li><code>DOUBLE</code> 双精度浮点数值 8字节</li><li><code>DECIMAL</code> 小数值</li></ul><hr><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><strong>字符字符串（存储过程中不进行大小写转换)</strong></p><ul><li><code>CHAR</code> 定长字符串 0-255字节</li><li><code>VARCHAR</code> 变长字符串</li></ul><p><strong>字节字符串（二进制字符串）</strong></p><ul><li><code>TINYBLOB</code> 不超过255字节的二进制字符串</li><li><code>BLOB</code> 长二进制字符串</li><li><code>MEDIUMBLOB</code> 中等长度二进制字符串</li><li><code>LONGBLOB</code> 极大长度二进制字符串</li></ul><p><strong>文本</strong></p><ul><li><code>TINTTEXT</code> 短文本字符串</li><li><code>TEXT</code> 长文本字符串</li><li><code>MEDIUMTEXT</code> 中等长度文本字符串</li><li><code>LONGTEXT</code> 极大长度文本字符串</li></ul><hr><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p><strong>年</strong></p><p><code>YEAR</code> 年份值（ YYYY ） 1字节</p><p><strong>日期</strong></p><p><code>DATE</code> 日期值（YYYY-MM-DD） 3字节</p><p><strong>时间</strong></p><p><code>TIME</code> 时间值 （HH:MM:SS) 3字节</p><p><strong>日期</strong>和时间</p><p><code>DATETIME</code> 混合日期时间值 （YYYY-MM-DD HH:MM:SS）8字节</p><p><strong>时间戳</strong></p><p><code>TIMESTAMP</code> 时间戳字符串 （YYYYMMDD HHMMSS）4字节</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NPM 的一些常用命令和使用方法</title>
      <link href="/2017/06/14/npm/"/>
      <url>/2017/06/14/npm/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>npm</code> 是 <code>node package manager</code> 的缩写，字面意义即可解释它的作用：<code>node</code> 的包管理工具。</p><p>本文主要介绍了一些<code>npm</code>常用的命令和基本的配置项。</p></blockquote><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>查看npm版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>升级npm至最新版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install npm -g</span><br></pre></td></tr></table></figure></li><li><p>模块的安装和使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;  ##本地安装模块</span><br><span class="line">npm install &lt;Module Name&gt; -g ##全局安装模块</span><br><span class="line">npm install &lt;Module Nmae&gt;@"0.1.1" ##安装对应版本模块</span><br></pre></td></tr></table></figure></li><li><p>全局安装和本地安装的区别</p><blockquote><p>本地安装后安装包位于运行npm命令时所在目录的 ./node_modules下,若无此目录会直接生成。安装后可以通过 require() 在代码文件中直接引入安装的包模块。</p></blockquote><blockquote><p>全局安装命令需要 -g 选项</p><p>全局安装会将安装包放在 /usr/local 下或者你的 node 安装目录下。安装的模块可以直接在命令行里使用。</p></blockquote></li></ol><ol start="5"><li><p>查看安装信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm ls -g ##查看全局安装的所有模块</span><br><span class="line">npm ls ##查看当前目录安装了哪些模块</span><br><span class="line">npm ls &lt;Module Name&gt;            ##查看某个模块的基本信息</span><br><span class="line">npm info &lt;Module Name&gt; ##查看某个模块的详细信息</span><br></pre></td></tr></table></figure></li><li><p>卸载和更新和搜索模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;Module Name&gt;  ##卸载</span><br><span class="line">npm uninstall &lt;Module Nmae&gt;@"0.1.1" ##卸载对应版本模块</span><br><span class="line">npm update &lt;Module Name&gt;  ##更新</span><br><span class="line">npm search &lt;Module Name&gt; ##搜索</span><br></pre></td></tr></table></figure></li><li><p>创建模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init  ##初始化目录为模块目录，会生成 package.json 文件（相关信息需自行填写最后输入yes确认）</span><br><span class="line">npm adduser  ##在npm资源库中注册用户，需要输入用户名和密码以及邮箱</span><br><span class="line">npm publish  ##发布模块</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config list ##查看所有设置</span><br><span class="line">npm config edit ##直接进入配置文件修改</span><br><span class="line">npm cache clean ##清理缓存</span><br></pre></td></tr></table></figure></li><li><p>代理 proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy &lt;url&gt; ##设置代理地址（可设置为null即为无代理）</span><br><span class="line">npm set proxy &lt;url&gt;  ##上条命令的简写</span><br><span class="line">npm config get proxy  ##查看代理地址</span><br><span class="line">npm get proxy       ##上条命令的简写</span><br><span class="line">npm delete proxy  ##删除代理</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="包的package-json"><a href="#包的package-json" class="headerlink" title="包的package.json"></a>包的<code>package.json</code></h2><ol><li><code>package.json</code> 文件用于定义包的属性，部分属性如下<ul><li><strong><code>name</code></strong> - 包名。</li><li><strong><code>version</code></strong> - 包的版本号。</li><li><strong><code>description</code></strong> - 包的描述。</li><li><strong><code>homepage</code></strong> - 包的官网 url 。</li><li><strong><code>author</code></strong> - 包的作者姓名。</li><li><strong><code>contributors</code></strong> - 包的其他贡献者姓名。</li><li><strong><code>dependencies</code></strong> - 依赖包列表。<strong>如果依赖包没有安装，npm 会自动将依赖包安装在 <code>node_module</code> 目录下。</strong></li><li><strong><code>devDependencies</code> </strong>- package的开发依赖模块，即别人要在这个package上进行开发`</li><li><strong><code>repository</code></strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li><li><strong><code>main</code></strong> - <code>main</code> 字段指定了程序的主入口文件，<code>require(&#39;moduleName&#39;)</code> 就会加载这个文件。这个字段的默认值是模块根目录下面的 <code>index</code>.js。</li><li><strong><code>keywords</code></strong> - 关键字</li><li><strong><code>scripts</code></strong> - 定义脚本命令，使用 <code>npm run sname</code> 即可执行，</li></ul></li></ol><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图片模态框效果实现(二)：BootStrap插件实现</title>
      <link href="/2017/06/12/%E5%9B%BE%E7%89%87%E6%A8%A1%E6%80%81%E6%A1%86%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%8C/"/>
      <url>/2017/06/12/%E5%9B%BE%E7%89%87%E6%A8%A1%E6%80%81%E6%A1%86%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在上一篇文章中，我们使用 js+css 实现了模态框效果，在理解了模态框的基本实现方法和实现效果后，我们就要寻找更快捷的方法，又快又好的来完成模态框开发需求，从而节约时间，提高效率。一个好的轮子，不仅能大幅减轻工作量，而且能让我们的代码更简明和优雅。</p><p>今天我们选择使用著名的 <em>bootstrap</em> 库的模态框插件 <em>modal</em>.<em>js</em> 来实现模态框效果，同时也使大家进一步熟悉 <em>bootstrap</em> 的插件使用。</p></blockquote><a id="more"></a><h3 id="bootstrap-的-js-插件"><a href="#bootstrap-的-js-插件" class="headerlink" title="bootstrap 的 js 插件"></a><em>bootstrap</em> 的 js 插件</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ul><li><p>引入全部JS插件</p><p>我们在使用 <em>bootstrap</em> 库时，引入的文件 <em>bootstrap.js</em> 或者 <em>bootstrap.min.js</em> 就是 <em>bootstrap</em> 的插件文件，这两种文件都集成了 <em>bootstrap</em> 的所有插件，区别在于 *<em>.min.js</em> 是压缩后的版本。</p><p>我们在使用 b<em>o</em>otstrap 的 <code>js</code>插件时不需要做更多的工作，只需要引入这两个文件中的一个就可以了，另外重要的信息是 <em>bootstrap</em> 的所有插件都依赖于 <em>jquery</em> 库，<strong>所以在引入 <em>bootstrap</em> 的插件时，必须先引入 <em>jquery</em> 库。</strong></p></li><li><p>引入单个<code>JS</code>插件</p><p>如果只使用 <em>bootstrap</em>库的 某个插件，所以不想引入全部插件时，可以选择单独引入某个插件。此种方法需要你有要使用的插件的单独文件，<em>bootstrap</em> 官方共有 12 个 <em>js</em> 插件，你可以到 <a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">github此处 </a>下载使用每个插件的单独文件。</p></li></ul><p>另外 bootstrap 有以下 12 个插件，大家可以大概做个了解：</p><ul><li>动画过渡（Transitions）: <code>transition.js</code></li><li>模态弹窗（Modal）: <code>modal.js</code></li><li>下拉菜单（Dropdown）： <code>dropdown.js</code></li><li>滚动侦测（Scrollspy）： <code>scrollspy.js</code></li><li>选项卡（Tab）： <code>tab.js</code></li><li>提示框（Tooltips）： <code>tooltop.js</code></li><li>弹出框（Popover）： <code>popover.js</code></li><li>警告框（Alert）： <code>alert.js</code></li><li>按钮（Buttons）： <code>button.js</code></li><li>折叠/手风琴（Collapse）： <code>collapse.js</code></li><li>图片轮播（Carousel）： <code>carousel.js</code></li><li>自动定位浮标（Affix）： <code>affix.js</code></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>通过 <code>data</code> 属性 <em>API</em></p><p><em>bootstrap</em> 提供了一个非常方便的 <em>API</em> 来调用插件，那就是 <code>data</code> 属性 。我们不需要写很多 <em>js</em> 代码，只需要为 <em>HTML</em> 标签增加 <code>data-*</code> 属性，就可以调用 <code>js</code>插件实现各种效果 。</p><p>例如我们想为按钮绑定 下拉菜单效果，只需要为按钮添加 <code>data-toggle=&quot;dropdown&quot;</code> 属性，在点击按钮时，就会调用 <em>dropdown</em> 插件了。</p></li><li><p>通过 <code>JS API</code></p><p>当然我们也可以使用 <em>bootstrap</em> 提供的 纯<em>javascript</em> <em>API</em> 来调用插件，例如为 i<em>d</em> 为 <em>test</em> 的 按钮绑定调用 <em>dropdown</em> 插件操作，可以使用如下的 <em>js</em> 代码：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>).dropdown(option) <span class="comment">//可带选项参数option</span></span><br></pre></td></tr></table></figure><h3 id="模态框插件详解"><a href="#模态框插件详解" class="headerlink" title="模态框插件详解"></a>模态框插件详解</h3><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><em>bootstrap</em> 模态框插件是 <code>modal.js</code> 。使用的代码结构类如下：</p><ul><li><code>.modal</code> 模态框</li><li><code>.modal-dialog</code> 模态框主体</li><li><code>.modal-content</code> 模态框内容</li><li><code>.modal-header</code> 模态框内容头部（标题）</li><li><code>.modal-title</code> 模态框标题</li><li><code>.modal-body</code> 模态框内容主要内容部分</li><li><code>.modal-footer</code> 模态框内容底部 （可放置操作按钮等）</li></ul><p>一个模态框的结构类似如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>模态框是个值得学习的好效果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击显示模态框按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">data-target</span>=<span class="string">"#modalone"</span> <span class="attr">data-show</span>=<span class="string">"false"</span>&gt;</span>come on!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 模态框HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span> <span class="attr">id</span>=<span class="string">"modalone"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!-- 模态框的header--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 模态框的关闭按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span>&amp;times;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span>&gt;</span>模态弹出窗标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 模态框主体 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>模态框主体<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 模态框footer --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"display: inline-block;"</span>&gt;</span>模态框底部<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-info"</span>&gt;</span>done<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="data-属性-API"><a href="#data-属性-API" class="headerlink" title="data 属性 API"></a><code>data</code> 属性 <em>API</em></h4><ul><li><p>必须的 <code>data</code> 属性</p><p>点击出现模态框按钮的 <code>data-toggle=&quot;#modalone&quot;</code> 属性表示 此按钮为模态框的触发器按钮，点击时弹出模态框。另外也可以使用 链接标签 <a>的 <em>href</em> 属性代替 <code>data-toggle</code> 将链接<a> 作为触发器，但不推荐点击链接时出现模态框。</a></a></p><p><code>data-target=&quot;#modalone&quot;</code> 属性表示 触发的模态框窗口 ID 为 modalone 。一个页面可以有多个模态窗口触发器，但是一个触发器只能触发此属性对应的模态框，不能触发多个模态框。</p></li></ul><blockquote><p><em>.fade 格式化类可以为模态框弹出添加过渡效果。</em></p></blockquote><blockquote><p><em>.close 格式化类 和 <code>data-dismiss</code> 属性配合可以为模态框添加关闭按钮。</em></p></blockquote><ul><li><p>可选的 <code>data</code> 属性</p><p>另外还有一些其他可选的 <code>data</code> 属性，可以增强模态框的表现效果。如下：</p><ul><li><code>data-backdrop</code> 是否包含一个背景 DIV 从而在单击背景时关闭模态框，属性值为 <em>true</em> 时 包含， 为 <em>static</em> 时不包含。</li></ul><ul><li><code>data-keyboard</code> 为 <em>true</em> 时按下键盘 <em>ESC</em> 时模态框关闭，false时不关闭</li><li><code>data-show</code> 为<em>true</em>时页面加载后不显示，为<em>false</em>时显示</li></ul></li></ul><h4 id="JS-API"><a href="#JS-API" class="headerlink" title="JS  API"></a><code>JS</code> <em>API</em></h4><p>通过<code>JS</code> 代码调用插件初始化模态框也可以达到与设置<code>data</code>属性达到相同的效果，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".btn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"#modalone"</span>).modal(&#123;</span><br><span class="line">            backdrop: <span class="literal">false</span>, <span class="comment">// 相当于data-backdrop</span></span><br><span class="line">            keyboard: <span class="literal">false</span>, <span class="comment">// 相当于data-keyboard</span></span><br><span class="line">            show: <span class="literal">true</span>, <span class="comment">// 相当于data-show</span></span><br><span class="line">            remote: <span class="string">""</span> <span class="comment">// 相当于a标签作为触发器的href</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>最后，以上模态框代码效果如下：</p><p>未点击按钮时：</p><p><img src="https://s1.ax1x.com/2018/04/15/CZLjmV.png" alt="img"></p><p>点击后：</p><p><img src="https://s1.ax1x.com/2018/04/15/CZOSkF.png" alt="img"></p><p>一个简单的模态框效果就制作完成了。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="JS-API-方法"><a href="#JS-API-方法" class="headerlink" title="JS API 方法"></a><code>JS API</code> 方法</h4><p>JS 代码调用插件， <code>$(&#39;#myModal&#39;).modal()</code>方法的参数除了使用 <code>option</code> 参数初始化模态框外，还有以下几个方法：</p><ul><li><code>$(&#39;#modalone&#39;).modal(&#39;toggle&#39;)</code> 切换模态框显示隐藏</li><li><code>$(&#39;#modalone&#39;).modal(&#39;show&#39;)</code> 打开模态框</li><li><code>$(&#39;#modalone&#39;).modal(&#39;hide&#39;)</code> 手动关闭模态框</li></ul><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>同时，模态框插件还提供了以下几个钩子事件函数，可以在<code>JS</code>代码中使用来达到丰富模态框效果或添加更多功能的目的。</p><p>使用方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#modalone'</span>).on(<span class="string">'hidden.bs.modal'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>show.bs.modal</th><th>在show方法调用时立即触发（尚未显示之前）；如果单击了一个元素，那么该元素将作为事件relatedTarget事件</th></tr></thead><tbody><tr><td>shown.bs.modal</td><td>该事件在模态窗完全显示给用户之后（并且等CSS动画完成之后）触发；如果单击了一个元素，那么该元素将作为事件relatedTarget事件</td></tr><tr><td>hide.bs.modal</td><td>在hide方法调用时（但还未关闭隐藏）立即触发</td></tr><tr><td>hidden.bs.modal</td><td>该事件在模态弹出窗完全隐藏之后（并CSS动画漂亮完成之后）触发</td></tr></tbody></table><p>以上就是 <em>bootstrap</em> 的模态框插件的相关知识，希望大家喜欢。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图片模态框效果实现(一)：JS实现</title>
      <link href="/2017/06/11/%E5%9B%BE%E7%89%87%E6%A8%A1%E6%80%81%E6%A1%86%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%B8%80/"/>
      <url>/2017/06/11/%E5%9B%BE%E7%89%87%E6%A8%A1%E6%80%81%E6%A1%86%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>很多时候我们在浏览图片时，会发现<strong>点击图片后，会弹出一个被点击图片的放大图片浮在页面上，占满整个窗口。</strong>这就是图片模态框效果。</p><p>这个效果可以使用某些<code>js</code>库实现，如<strong><em>bpopupJs</em></strong>。但是在这里我们使用纯<code>js</code>实现，能够更好理解效果原理和实现方法。</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们点击小图片之后,图片模态框出现，同时图片模态框上有一个关闭按钮和图片的标题。</p><p>因此，我们的实现思路就是：</p><ol><li>图片模态框有大图片，关闭按钮，图片标题三部分。</li><li>将图片模态框隐藏，在点击小图片之后，模态框出现。</li><li>点击关闭按钮后，模态框隐藏。</li></ol><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><code>HTML</code></h3><p>首先，我们的原始页面上有一个图片如下：</p><p><img src="https://img.catqu.com/images/2018/04/15/mo11.png" alt="img"></p><p>HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>图片点击弹出模态框效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>图片模态框很不错，是个值得学习的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"star.jpeg"</span> <span class="attr">id</span>=<span class="string">"real"</span> <span class="attr">alt</span>=<span class="string">"model test picture"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模态框的HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"motai"</span> <span class="attr">id</span>=<span class="string">"mo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>×<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"motaiimg"</span> <span class="attr">id</span>=<span class="string">"moimg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"caption"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><code>CSS</code></h3><p>我们需要通过css设置模态框中各元素的表现效果同时将其隐藏起来，具体有如下几步：</p><h4 id="模态框"><a href="#模态框" class="headerlink" title="模态框"></a>模态框</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#mo</span>&#123;</span><br><span class="line">       <span class="attribute">display</span>: none;<span class="comment">/*隐藏模态框*/</span></span><br><span class="line">       <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">       <span class="attribute">position</span>: fixed;<span class="comment">/*定位方式为固定定位*/</span></span><br><span class="line">       <span class="attribute">overflow</span>: auto;<span class="comment">/*不滚动*/</span></span><br><span class="line">       <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,0.7);</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">       <span class="attribute">z-index</span>: <span class="number">1</span>;<span class="comment">/*置于页面图层之上*/</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="关闭按钮"><a href="#关闭按钮" class="headerlink" title="关闭按钮"></a>关闭按钮</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.close</span>&#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: bold;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">14%</span>;</span><br><span class="line">      <span class="attribute">color</span>:<span class="number">#f1f1f1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.close</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.close</span><span class="selector-pseudo">:focus</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>:<span class="number">#bbb</span>;</span><br><span class="line">      <span class="attribute">cursor</span>:pointer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="模态框中图片"><a href="#模态框中图片" class="headerlink" title="模态框中图片"></a>模态框中图片</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#moimg</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: block;<span class="comment">/*图片表现为块*/</span></span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">25px</span> auto;<span class="comment">/*图片居中对齐*/</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">750px</span>;<span class="comment">/*自适应布局*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="图片标题"><a href="#图片标题" class="headerlink" title="图片标题"></a>图片标题</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#caption</span>&#123;</span><br><span class="line">        <span class="attribute">text-align</span>: center;<span class="comment">/*文本居中*/</span></span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">15px</span> auto;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">        <span class="attribute">max-height</span>: <span class="number">750px</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">        <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h4><p>如果想实现点击后扩大的动画效果，可以增加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#moimg</span>,<span class="selector-id">#caption</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: popup <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">-o-animation</span>: popup <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">animation</span>: popup <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> popup&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>: <span class="built_in">scale</span>(0.1);&#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>: <span class="built_in">scale</span>(1);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，我们已经制作好了模态框页面。在使用js来完成交互效果就可以了。</p><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a><code>JS</code></h3><p><code>js</code>代码主要是图片和关闭按钮的点击交互，需要注意的是<code>js</code>代码须位于模态框<code>HTML</code>代码之后，<code>js</code>具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> motai=<span class="built_in">document</span>.getElementById(<span class="string">'mo'</span>)</span><br><span class="line"><span class="keyword">var</span> moimg=<span class="built_in">document</span>.getElementById(<span class="string">"moimg"</span>)</span><br><span class="line"><span class="keyword">var</span> realimg=<span class="built_in">document</span>.getElementById(<span class="string">"real"</span>)</span><br><span class="line"><span class="keyword">var</span> caption=<span class="built_in">document</span>.getElementById(<span class="string">"caption"</span>)</span><br><span class="line"></span><br><span class="line">realimg.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    motai.style.display=<span class="string">"block"</span></span><br><span class="line">    moimg.src=<span class="keyword">this</span>.src</span><br><span class="line">    caption.innerHTML=<span class="keyword">this</span>.alt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> span=<span class="built_in">document</span>.getElementById(<span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">span.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    motai.style.display=<span class="string">"none"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，图片的模态框效果就实现了，</p><p><img src="https://img.catqu.com/images/2018/04/15/mo2.png" alt="img"></p><p>最后总的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>close<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#real</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/*点击弹出模态框的图片*/</span></span></span><br><span class="line"><span class="undefined">        margin: 30px;</span></span><br><span class="line"><span class="undefined">        width: 250px;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-radius</span><span class="selector-pseudo">:6px</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#real</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">opacity</span>: 0<span class="selector-class">.6</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#mo</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span>: <span class="selector-tag">none</span>;<span class="comment">/*隐藏*/</span></span></span><br><span class="line"><span class="undefined">        width: 100%;</span></span><br><span class="line"><span class="undefined">        height: 100%;</span></span><br><span class="line"><span class="undefined">        position: fixed;</span></span><br><span class="line"><span class="undefined">        overflow: auto;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.7</span>);</span></span><br><span class="line"><span class="undefined">        top: 0px;</span></span><br><span class="line"><span class="undefined">        left: 0px;</span></span><br><span class="line"><span class="undefined">        z-index: 1;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#moimg</span>&#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span><span class="selector-pseudo">:25px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="undefined">        width: 60%;</span></span><br><span class="line"><span class="undefined">        max-width: 750px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#caption</span>&#123;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">        margin: 15px auto;</span></span><br><span class="line"><span class="undefined">        width: 60%;</span></span><br><span class="line"><span class="undefined">        max-height: 750px;</span></span><br><span class="line"><span class="undefined">        font-size: 20px;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>:<span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#moimg</span>,<span class="selector-id">#caption</span>&#123;</span></span><br><span class="line"><span class="undefined">        -webkit-animation: first 1s;</span></span><br><span class="line"><span class="undefined">        -o-animation: first 1s;</span></span><br><span class="line"><span class="undefined">        animation: first 1s;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    @<span class="keyword">keyframes</span> first&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>: <span class="built_in">scale</span>(0.1);&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>: <span class="built_in">scale</span>(1);&#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.close</span>&#123;</span></span><br><span class="line"><span class="undefined">        font-size: 40px;</span></span><br><span class="line"><span class="undefined">        font-weight: bold;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        top: 20px;</span></span><br><span class="line"><span class="undefined">        right: 14%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>:<span class="selector-id">#f1f1f1</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.close</span><span class="selector-pseudo">:hover</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.close</span><span class="selector-pseudo">:focus</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>:<span class="selector-id">#bbb</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">cursor</span><span class="selector-pseudo">:pointer</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    @<span class="keyword">media</span> only screen and(max-width:<span class="number">750px</span> ) &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#moimg</span>&#123;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>图片点击弹出模态框效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>图片模态框很不错，是个值得学习的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"star.jpeg"</span> <span class="attr">id</span>=<span class="string">"real"</span> <span class="attr">alt</span>=<span class="string">"model test picture"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--图片模态框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"motai"</span> <span class="attr">id</span>=<span class="string">"mo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">id</span>=<span class="string">"close"</span>&gt;</span>×<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"motaiimg"</span> <span class="attr">id</span>=<span class="string">"moimg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"caption"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> motai=<span class="built_in">document</span>.getElementById(<span class="string">'mo'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> moimg=<span class="built_in">document</span>.getElementById(<span class="string">"moimg"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> realimg=<span class="built_in">document</span>.getElementById(<span class="string">"real"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> caption=<span class="built_in">document</span>.getElementById(<span class="string">"caption"</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    realimg.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        motai.style.display=<span class="string">"block"</span></span></span><br><span class="line"><span class="javascript">        moimg.src=<span class="keyword">this</span>.src</span></span><br><span class="line"><span class="javascript">        caption.innerHTML=<span class="keyword">this</span>.alt</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> span=<span class="built_in">document</span>.getElementById(<span class="string">"close"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    span.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        motai.style.display=<span class="string">"none"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS动画效果及其回调</title>
      <link href="/2017/05/16/CSS%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%8F%8A%E5%85%B6%E5%9B%9E%E8%B0%83/"/>
      <url>/2017/05/16/CSS%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%8F%8A%E5%85%B6%E5%9B%9E%E8%B0%83/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>用纯<code>JS</code>实现动画效果代码量大,计算复杂.因此现在前端页面的动画效果一般都采用<code>CSS</code>来实现.</p><p><code>CSS</code>动画实现简单高效,但是在处理动画,控制动画过程上却缺少一些有效手段.</p><p>例如我们想在动画效果完成时调用回调函数来处理一些事务,会发现CSS并没有提供直接的方法来让我们使用.</p><p>本文主要对<code>CSS</code>的动画做一个简单介绍，并说明一下动画的回调效果如何实现。</p></blockquote><a id="more"></a><h3 id="css动画简介"><a href="#css动画简介" class="headerlink" title="css动画简介"></a>css动画简介</h3><p>css动画效果有两种,即<strong>过渡</strong>和<strong>动画</strong>.</p><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>当元素从一种样式转变为另一种样式,我们为这种转变添加动画效果,这种效果就称作过渡.</p><p><code>CSS</code>的过渡是通过 <code>transtion</code> 属性实现的.</p><p><code>transtion</code>属性必须包含以下两个值:</p><ul><li>要添加过渡效果的样式属性名</li><li>过渡效果持续时间</li></ul><p>另外还有两个可选的属性值:</p><ul><li>过渡效果的速度时间曲线函数</li><li>过渡效果的延迟时间</li></ul><p>下面是一个CSS过渡效果的例子:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">-webkit-transtion</span>:width <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.hover</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当鼠标移动到<code>div</code>上时,此<code>div</code>宽度会增加200px.</p><p>我们通过<code>css</code>为宽度变化添加上了 2s 过渡效果。</p><style>div#test{width:100px;height:100px;background:red;transition:width 2s;-webkit-transition:width 2s}div#test:hover{width:300px}</style><div id="test"></div><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>在实现比较复杂的动画时,单纯使用过渡已经无法达到目的,可以选择使用<code>CSS</code>的<code>animation</code>属性来定义动画效果.</p><p>要想使用<code>animation</code>属性,我们必须先了解一下<code>CSS3</code>加入的<code>@keyframes</code>规则.</p><p><code>@keyframes</code>规则用于创建动画,可以从动画运动状态的帧来定义动画.</p><p>如下即<code>@kayframes</code>定义动画的例子:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> show</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> show /* Safari 与 Chrome */</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@keyframes</code>我们可以定义动画从开始到结束的样式变化 .</p><p>我们也可以通过定义动画效果的百分比状态来定义动画样式,如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> show</span><br><span class="line">&#123;</span><br><span class="line">    0%   &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">color</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> show /* Safari 与 Chrome */</span><br><span class="line">&#123;</span><br><span class="line">    0%   &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">color</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>@keyframes</code>定义了动画效果之后,我们可以通过 <code>animation</code> 来将动画效果绑定到元素,如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:show <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如下：</p><p></p><style>@keyframes show{0%{color:red}25%{color:#ff0}50%{color:#00f}100%{color:green}}@-webkit-keyframes show{0%{color:red}25%{color:#ff0}50%{color:#00f}100%{color:green}}div.s:hover{animation:show 4s}</style><p></p><div class="s" style="margin-top:-20px;margin-bottom:10px;width:200px;height:50px;border:1px solid #c40000;text-align:center"><p style="line-height:50px">动画文字</p></div><p>以上就是CSS动画的简单介绍,另外CSS3还添加了<code>transform</code>属性,用于2D和3D转换,也被经常用来作为动画使用.</p><h3 id="CSS动画的回调函数"><a href="#CSS动画的回调函数" class="headerlink" title="CSS动画的回调函数"></a><code>CSS</code>动画的回调函数</h3><p>像以上的<code>CSS</code>动画,如果想使用回调函数来控制动画完成后的事务处理,是比较麻烦的.</p><h4 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h4><p>很多人使用<code>JS</code>的延时函数 <code>setTimtout()</code> 来解决<code>CSS</code>动画的回调问题,类似如下的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimtout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    dosomething()  <span class="comment">//动画的回调函数</span></span><br><span class="line">&#125;, delaytime);      <span class="comment">//动画的持续时间</span></span><br></pre></td></tr></table></figure><p>但是这种方法由于并不是真正意义的回调,会造成以下几个问题:</p><ul><li>由于动画和延时函数并不一定是同一时间开始,导致函数和动画不同步</li><li>会造成JS代码和CSS代码相互关联耦合,修改和维护比较麻烦</li><li>存在多个动画需要回调时会造成代码混乱和臃肿</li><li>在多个动画效果同时结束时会引起回调函数冲突</li></ul><p>因此,不建议使用延时函数作为动画的回调函数.</p><h4 id="JS事件"><a href="#JS事件" class="headerlink" title="JS事件"></a><code>JS</code>事件</h4><p>其实,<code>JS</code>提供了两个事件,可以完美的解决动画的回调函数问题,那就是 <code>transtionend</code>和 <code>animationend</code>,当过渡或动画完成时,即会触发对应的事件.</p><p>我们可以通过这两个事件轻松优雅的为动画添加回调函数.</p><p>具体用法如下:</p><ul><li><code>transtionend</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myFunction即为动画回调函数</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDIV"</span>)</span><br><span class="line">        .addEventListener(<span class="string">"transitionend"</span>, myFunction);</span><br></pre></td></tr></table></figure><ul><li><code>animationend</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myFunction即为回调函数</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDIV"</span>)</span><br><span class="line">        .addEventListener(<span class="string">"animationend"</span>, myFunction);</span><br></pre></td></tr></table></figure><p>我们通过以下这个例子来体验这两个事件的具体使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-id">#test</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">transition</span><span class="selector-pseudo">:width</span> 2<span class="selector-tag">s</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">-webkit-transition</span><span class="selector-pseudo">:width</span> 2<span class="selector-tag">s</span>; <span class="comment">/* Safari */</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span><span class="selector-id">#test</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span></span><br><span class="line"><span class="javascript">        .addEventListener(<span class="string">"transitionend"</span>, myFunction);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.innerHTML = <span class="string">"回调函数触发div变为粉色"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"pink"</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><style>div#alili{width:100px;height:100px;background:red;transition:width 2s;-webkit-transition:width 2s}div#alili:hover{width:300px}</style><p></p><div id="alili"></div><p></p><script type="text/javascript">function myFunction(){this.innerHTML="回调函数触发div变为粉色",this.style.backgroundColor="pink",setTimeout(function(){var n=document.getElementById("alili");n.innerHTML="",n.style.backgroundColor="red"},5e3)}document.getElementById("alili").addEventListener("transitionend",myFunction)</script><h4 id="JQuery方法"><a href="#JQuery方法" class="headerlink" title="JQuery方法"></a><code>JQuery</code>方法</h4><p>当然也可以使用Jquery库的动画回调函数,很简单,代码类似如下,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#item"</span>).animate(&#123;<span class="attr">height</span>:<span class="string">"200px"</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上就是关于CSS动画回调函数的一些知识,希望对你有帮助.</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>获取短信验证码按钮的功能实现</title>
      <link href="/2017/05/16/%E8%8E%B7%E5%8F%96%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8C%89%E9%92%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2017/05/16/%E8%8E%B7%E5%8F%96%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E6%8C%89%E9%92%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p>在web网页中,用户的一些行为,例如注册,登录,付款,修改密码等,都需要网站通过手机验证码来确认其行为身份,从而保证用户账户和网站自身的安全。</p><p>本文主要介绍了获取短信验证码按钮的前端实现和一些需要注意的地方。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网页中的验证码一般都是采用点击获取的方式,在实现页面的获取手机验证码按钮时,着重需要考虑的是以下几点:</p><ul><li>保证在手机号码填写符合规范的情况下才可以点击按钮或者发送请求</li><li>点击按钮后需要在一段时间内禁用按钮,以防止用户不断点击产生大量请求</li><li>保证在网页刷新后验证码计时不会清零</li></ul><p>在这里我们主要来实现前两项效果.</p><p>保证网页刷新后验证码倒计时不清零需要使用<code>cookie</code>实现,为了避免篇幅过长,内容杂乱,不做赘述.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>按钮可以用以下两种获取验证码的实现方法:</p><ol><li>当手机号输入格式正确时,按钮才处于可点击状态</li><li>按钮一直处于可点击状态,只是当手机号格式错误时,点击后会向用户提示错误,不向服务器发送请求</li></ol><p>这两种方法虽然代码可能不同,但是基本原理是差不多的,这里我们就只使用第一种方法来进行说明.</p><p>一般验证码的页面HTML结构类似如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> &gt;</span>请输入手机号:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"phone"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>验证码:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取验证码"</span> <span class="attr">name</span>=<span class="string">"yzm"</span> <span class="attr">class</span>=<span class="string">"yzm"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面如图:</p><p><img src="https://img.catqu.com/images/2018/04/15/phonecode.png" alt="img"></p><p>在输入正确格式的手机号码后,获取验证码按钮取消禁用状态,可点击.</p><p>点击后按钮再次进入禁用状态并开始倒计时,倒计时完毕后再次进入可点击状态.</p><p>具体实现流程还是比较简单的.代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ordertime=<span class="number">20</span>   <span class="comment">//设置再次发送验证码等待时间</span></span><br><span class="line">    <span class="keyword">var</span> timeleft=ordertime</span><br><span class="line">    <span class="keyword">var</span> btn=$(<span class="string">".yzm"</span>)</span><br><span class="line">    <span class="keyword">var</span> phone=$(<span class="string">".phone"</span>)</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/^1[0-9]&#123;10&#125;$/</span>;  <span class="comment">//电话号码的正则匹配式</span></span><br><span class="line"></span><br><span class="line">    phone.keyup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (reg.test(phone.val()))&#123;</span><br><span class="line">          btn.removeAttr(<span class="string">"disabled"</span>)  <span class="comment">//当号码符合规则后发送验证码按钮可点击</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          btn.attr(<span class="string">"disabled"</span>,<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计时函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timeCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       timeleft-=<span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> (timeleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           btn.val(timeleft+<span class="string">" 秒后重发"</span>);</span><br><span class="line">           setTimeout(timeCount,<span class="number">1000</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           btn.val(<span class="string">"重新发送"</span>);</span><br><span class="line">           timeleft=ordertime   <span class="comment">//重置等待时间</span></span><br><span class="line">           btn.removeAttr(<span class="string">"disabled"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件处理函数</span></span><br><span class="line">    btn.on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).attr(<span class="string">"disabled"</span>,<span class="literal">true</span>); <span class="comment">//防止多次点击</span></span><br><span class="line">        <span class="comment">//此处可添加 ajax请求 向后台发送 获取验证码请求</span></span><br><span class="line">        timeCount();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ajax请求格式大概如下,可以用于向服务器请求发送验证码到制定手机</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     　　type: <span class="string">"POST"</span>, <span class="comment">//用POST方式传输</span></span><br><span class="line">     　　dataType: <span class="string">"text"</span>, <span class="comment">//数据格式:JSON</span></span><br><span class="line">     　　url: <span class="string">'Login.ashx'</span>, <span class="comment">//目标地址</span></span><br><span class="line">    　　  data: <span class="string">"dealType="</span> + dealType +<span class="string">"&amp;uid="</span> + uid + <span class="string">"&amp;code="</span> + code, <span class="comment">//post携带数据</span></span><br><span class="line">    　　  error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;, <span class="comment">//请求错误时的处理函数</span></span><br><span class="line">     　　success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; &#125;, <span class="comment">//请求成功时执行的函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在实际开发中,除了上述的基本实现外，还需要有与服务器验证用户填写验证码是否正确的<code>ajax</code>请求, 使用<code>cookie</code>防止刷新页面导致倒计时失效的代码,实际开发的代码量会比上面多很多.</p><p>但是只要我们掌握基本原理和实现思路,就可以很容易的实现项目要求.</p><p>希望这篇文章对你有帮助.</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(五):类</title>
      <link href="/2017/05/13/TypeScript(%E4%BA%94)%E7%B1%BB/"/>
      <url>/2017/05/13/TypeScript(%E4%BA%94)%E7%B1%BB/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>Ts</code> 的类，大部分特性都是很多其他语言也有的相似范式特性，与<code>Es6</code>中新提出的类实现也非常类似。因此，如果接触过编程中类的一些基础概念的话，应该非常容易理解。</p><p>本篇博客就来主要介绍一下，<code>Ts</code>的类的一些基本知识。</p></blockquote><a id="more"></a><h3 id="类的基本实现"><a href="#类的基本实现" class="headerlink" title="类的基本实现"></a>类的基本实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;  </span><br><span class="line">    color: <span class="built_in">string</span> ;  </span><br><span class="line">    size: <span class="built_in">string</span> = <span class="string">'big'</span> ;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">color: <span class="built_in">string</span></span>)&#123;  </span><br><span class="line">      <span class="keyword">this</span>.color = color</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    bark () &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blackDog = <span class="keyword">new</span> Dog(<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>costructor</code>　是类的构造函数</li><li><code>this</code> 是类实例的引用</li><li>通过<code>new</code>关键字来创建一个类的实例</li><li>实例属性可以在构造函数中初始化，也可以在声明时直接赋值。</li></ul><h3 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h3><p>与大部分具有类的语言一样，在<code>Ts</code>中，也存在<code>public</code>,<code>protected</code>,<code>private</code>三种修饰符用来指定类成员的可见性。</p><ul><li><code>public</code>, 表示成员对所有人都是可见的。类成员默认都是<code>public</code>的。</li><li><code>protected</code>, 表示成员仅在当前类及其子类中可被访问。</li><li><code>privated</code>, 表示成员仅在被定义的类中可被访问，不能通过类的实例或子类访问。</li></ul><p>特别的，类属性也可以加上<code>readonly</code>修饰符，来将其限定为只读。<br>设置了只读的属性必须在属性声明或构造函数中被初始化。</p><h4 id="修饰符和构造函数"><a href="#修饰符和构造函数" class="headerlink" title="修饰符和构造函数"></a>修饰符和构造函数</h4><p>为构造函数加上<code>protected</code>修饰符，则其只能在类的子类中被访问，也就是相当于将类限定为了只能被继承的基类。<br>为构造函数加上<code>privated</code>修饰符，则相当于将类限定为了即不能被继承，也不能被实例化的类（可以称其为没什么用类。</p><p>通过为类的构造函数参数加上修饰符，可以方便的将它们声明为类的实例属性。例如上面类的定义中的<code>Dog</code>类，我们可以这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;  </span><br><span class="line">    size:<span class="built_in">string</span> = <span class="string">'big'</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> color: <span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    bark () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>即美观又优雅，省去了很多代码。</p><h3 id="getter-setter-属性"><a href="#getter-setter-属性" class="headerlink" title="getter/setter 属性"></a>getter/setter 属性</h3><p>可以通过<code>getter/setter</code>存取器来代理对属性的访问。<br>如下，我们自定义了对<code>Dog</code>类中属性<code>name</code>的访问和赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;  </span><br><span class="line">    <span class="keyword">get</span> name (): <span class="built_in">string</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'afei'</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> name (theName: <span class="built_in">string</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = theName </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>getter/setter</code>有以下两点需要注意:</p><ul><li>此项特性不能被编译为<code>ES3</code>，最低需要编译输出为<code>ES5</code></li><li>只有<code>getter</code>的属性，会被<code>TS</code>类型推断为<code>readonly</code></li></ul><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>可以通过<code>static</code>关键字，将属性声明为类的静态属性和方法。<br>类似于通过<code>this</code>来访问实例属性，可以通过类名来访问类的静态属性和方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BigDog &#123;  </span><br><span class="line">    <span class="keyword">static</span> DogName: <span class="built_in">string</span> = <span class="string">'--Big'</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">theName: <span class="built_in">string</span></span>) &#123;    </span><br><span class="line">        <span class="keyword">this</span>.theName = theName + BigDog.DogName  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>通过<code>extends</code>关键字来进行类的继承。并可以在子类中重写父类的方法。<br><code>typescript</code>规定，子类如果定义了构造函数，必须在其中通过<code>super</code>来调用一次父类的构造函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;  </span><br><span class="line">    color: <span class="built_in">string</span>  <span class="keyword">constructor</span> (<span class="params">color: <span class="built_in">string</span></span>) &#123;   </span><br><span class="line">        <span class="keyword">this</span>.color = color </span><br><span class="line">    &#125;  </span><br><span class="line">    bark () &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> JiWaWa <span class="keyword">extends</span> Dog &#123; </span><br><span class="line">    name: <span class="built_in">string</span>  </span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'JiWaWa　Run'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bark　() &#123;    </span><br><span class="line">        <span class="keyword">this</span>.run()  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'wang wang wang'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>通过在类声明前加上<code>abstract</code>来将类声明为一个抽象类, 抽象类无法被实例化（但继承抽象类的子类可以）。<br>抽象类与接口类似，但相对于接口而言，抽象类可以包含成员的具体实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Dog &#123; </span><br><span class="line">    color: <span class="built_in">string</span> </span><br><span class="line">    bark ():<span class="built_in">void</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dog bark'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>通过在抽象类的方法声明前加上<code>abstract</code>来将方法声明为一个抽象方法。<br>抽象方法与函数类型的接口类似，只需要定义方法的签名，不需要方法的具体实现。<br>在抽象方法前同样可以添加<code>parvate</code>等访问修饰。<br>在继承抽象类的子类中，必须实现抽象方法，否则就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Dog &#123; </span><br><span class="line">    color: <span class="built_in">string</span> </span><br><span class="line">    bark ():<span class="built_in">void</span> &#123;   </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dog bark'</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> run (): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(四):函数</title>
      <link href="/2017/05/10/TypeScript(%E5%9B%9B)%E5%87%BD%E6%95%B0/"/>
      <url>/2017/05/10/TypeScript(%E5%9B%9B)%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>函数作为编程语言的基本组成部分，<code>Ts</code>也提供了相当完备并且具有较高自由度的类型规则。</p><p>这篇博客，就介绍一下<code>Ts</code>中与函数有关的一些知识。</p></blockquote><a id="more"></a><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>一个完整的<code>Ts</code>函数定义包括参数的类型声明和返回值的类型声明。如下:<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果函数没有返回值，我们可以定义返回值类型为`void`。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubule</span>(<span class="params">x: <span class="built_in">string</span></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  x += x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这种定义类型的方式，函数的参数和返回值的类型声明都是可选的。</p><p>还可以通过箭头函数的方式定义函数类型。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure><p></p><p>这种情况下，箭头和返回值类型都是不可省略的。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在<code>Js</code>中，传入函数的参数个数并不需要跟定义的参数个数一致。<br>在<code>Ts</code>中，传入函数的参数个数必须和函数期望的参数个数一致，不能不传或者多传。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>通过<code>?</code>来定义可选参数。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可选参数必须位于必选参数之后。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>为参数提供默认值可将其设置为默认参数，在参数未传递值或传递了<code>undefined</code>时会使用默认值。</p><p>在必选参数前的默认参数不可省略，必须明确传入<code>undefined</code>值来获得参数默认值。</p><p>在必选参数后的默认参数默认都是可选的，并被当做类型是默认参数默认值类型的可选参数来进行类型检查。<br></p><figure class="highlight typescript"><figcaption><span>TypeScriptTypeScript TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x:<span class="built_in">number</span>, y = 3, z: <span class="built_in">number</span>, v = 5</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有以下几种调用方式</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在<code>Js</code>中，可以通过<code>arguments</code>来获得所有的传入参数。<br>在<code>Ts</code>中，可以通过<code>...</code>符号来将所有剩余参数收集到一个变量中。如下：</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, ...rest: <span class="built_in">string</span>[]</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>rest</code>变量就成为了一个参数数组，包含所有的剩余参数。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在<code>Js</code>中，普通函数的<code>this</code>是在运行时确定的，指向它运行时的调用者。箭头函数的<code>this</code>则是声明时确定的，指向函数创建时的<code>this</code>值。</p><p>可以通过在定义普通函数时向其传入一个<code>this</code>值作为参数，来进行<code>this</code>的类型声明，避免<code>this</code>的类型为<code>any</code>，从而在<code>--noImplicitThis</code>下不报错。。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  legs: <span class="built_in">number</span>,</span><br><span class="line">  bark():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDoa: Dog = &#123;</span><br><span class="line">  legs: <span class="number">4</span>,</span><br><span class="line">  barK(<span class="keyword">this</span>: Dog) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i have'</span> + <span class="keyword">this</span>.legs + <span class="string">'legs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于箭头函数，因为它并不捕获<code>this</code>，所以并不存在<code>this</code>的类型检查。<br>但缺点是，类的箭头函数属性在每次创建新对象都会创建，而普通方法只会被创建一次，添加到类的原型链上。</p><h3 id="函数的类型重载"><a href="#函数的类型重载" class="headerlink" title="函数的类型重载"></a>函数的类型重载</h3><p>在某些情况下，我们想让函数可以接受不同类型的参数，并根据对应类型的参数返回相应类型的值。<br>对于这种情况，我们可以通过为同一个函数类型提供多个类型声明来进行函数的重载。如下：<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line">  if (typeof x === "string") &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(x)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以上就是<code>Ts</code>中与函数有关的一些知识，感谢阅读。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(三):接口</title>
      <link href="/2017/05/03/TypeScript(%E4%B8%89)%E6%8E%A5%E5%8F%A3/"/>
      <url>/2017/05/03/TypeScript(%E4%B8%89)%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>接口是<code>Ts</code>中的一个重要概念。</p><p>本篇博客主要介绍<code>Ts</code>中接口的基础知识。</p></blockquote><a id="more"></a><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p><strong>接口用于声明对象，函数或类的结构和类型。</strong></p><ul><li>使用 interface 声明口</li><li>使用属性名后的 <code>?</code> 表示属性可选</li><li>使用属性名前的 <code>readonly</code> 表示属性只读。</li></ul><h3 id="对象类型接口"><a href="#对象类型接口" class="headerlink" title="对象类型接口"></a>对象类型接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ApiData &#123;  </span><br><span class="line">    name: <span class="built_in">string</span> </span><br><span class="line">    value: <span class="built_in">number</span>  </span><br><span class="line">    label?: <span class="built_in">string</span>  </span><br><span class="line">    readonly id: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象字面量的特别之处"><a href="#对象字面量的特别之处" class="headerlink" title="对象字面量的特别之处"></a>对象字面量的特别之处</h4><p>一般来说，定义了接口的函数只会检查传递的值是否符合了接口结构，不会再去检查它是否还包含额外的接口未定义的属性。</p><p>但是，当向定义了特定接口的函数传递对象字面量值时，则会对对象字面量做<strong><em>额外的</em></strong>多余属性检查，必须保证对象字面量的结构和接口完全一致，不能有额外的属性，否则就会报编译错误。</p><p>避免以上问题有三种方式:</p><ol><li>将对象字面量赋值给一个变量再传递给函数</li><li>对对象字面量使用类型断言</li><li>使用接口的字符串索引签名来声明接口结构</li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>可以为接口增加可索引类型,包括一个<strong>索引签名</strong>和索引的返回类型。<br>索引签名有两种，<strong>字符串索引签名</strong>和<strong>数字索引签名</strong>，数字索引签名的返回值必须是字符串索引签名返回值的子类型（因为数字索引在<code>js</code>中等同于字符串索引。<br>同样的，索引类型也可以设置为只读来禁止对对象属性的赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NewTime &#123;  </span><br><span class="line">    [index:<span class="built_in">string</span>]: <span class="built_in">any</span>  </span><br><span class="line">    readonly [index:<span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><p>接口除了声明对象的结构，也可以用来声明函数的结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TimeFunc &#123;  </span><br><span class="line">    (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTime: TimeFuncmyTime = <span class="function"><span class="keyword">function</span> (<span class="params">h, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h + <span class="string">':'</span> + m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><p>接口也可以用来约束类的结构和类型，使用<code>implements</code>关键字。<br>接口中的属性声明用来约束类的实例属性，函数声明用来约束类的实例方法。<br>也就是说，接口只能用来约束类的实例属性和方法，无法约束<strong>类自身的构造函数，静态属性和静态方法</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClassInterface &#123;  </span><br><span class="line">    hour: <span class="built_in">number</span>  </span><br><span class="line">    minute: <span class="built_in">number</span>  </span><br><span class="line">    setTime(h: <span class="built_in">number</span>, m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Time <span class="keyword">implements</span> ClassInterface &#123;  </span><br><span class="line">    hour: <span class="built_in">number</span>  </span><br><span class="line">    minute: <span class="built_in">number</span>  </span><br><span class="line">    setTime(h: <span class="built_in">number</span>, m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>接口可以使用<code>extends</code>来继承其他任意个数的接口。通过继承，可以来创建多个接口的合成接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Car &#123;  </span><br><span class="line">    price: <span class="built_in">number</span>  </span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BigCar &#123;  </span><br><span class="line">    wheel: <span class="built_in">number</span>  </span><br><span class="line">    size: <span class="built_in">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bus <span class="keyword">extends</span> Car, BigCar &#123;&#125;</span><br></pre></td></tr></table></figure><p>接口也可以继承类，在继承类时，接口相当于抽象出了类的结构，也包括类的<code>private</code>和<code>protected</code>成员。这两类成员只能被接口所继承类的本身或其子类实现。因此，当接口继承的类有私有成员时，接口也就只能被它所继承的类或其子类实现了。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP的PDO基本使用</title>
      <link href="/2017/04/22/PHP%E7%9A%84PDO%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/22/PHP%E7%9A%84PDO%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>​ PDO是PHP的一个基于面向对象编程思想封装的，使用 C 开发的数据库抽象层。</p><p>​ 本文主要总结了它的使用方法和使用中的一些注意事项。</p></blockquote><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>​ 1.开启 PDO 驱动（扩展）</p><p>​ 2.实例化 PDO 类，然后可以使用类的属性和方法操作数据库。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$dsc = <span class="string">'mysql:host=localhost;dbname=mysql_text'</span>;</span><br><span class="line"></span><br><span class="line">$user = <span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line">$pass = <span class="string">'123'</span>;</span><br><span class="line"></span><br><span class="line">$pdo = <span class="keyword">new</span> PDO($dsc,$user,$pass);</span><br><span class="line"><span class="comment">//实例化一个类的时候，会自动的先调用__construct()构造函数</span></span><br></pre></td></tr></table></figure><h4 id="抽象类PDO的方法"><a href="#抽象类PDO的方法" class="headerlink" title="抽象类PDO的方法"></a>抽象类PDO的方法</h4><h5 id="PDO-exec"><a href="#PDO-exec" class="headerlink" title="PDO:exec( )"></a><code>PDO:exec( )</code></h5><p>​ 执行增删改语句的方法。功返回影响的条数，失败返回false</p><h5 id="PDO-query"><a href="#PDO-query" class="headerlink" title="PDO:query( )"></a><code>PDO:query( )</code></h5><p>​ 执行查询语句的方法。成功返回 <code>PDOStatement</code> 结果集对象，失败返回 <code>false</code></p><h5 id="PDO-prepare"><a href="#PDO-prepare" class="headerlink" title="PDO:prepare( )"></a><code>PDO:prepare( )</code></h5><p>​ 执行预处理语句的方法。</p><p>​ 预处理的步骤：</p><p>​ 一. 将 <code>sql</code> 语句的数据部分和非数据部分分离</p><p>​ 二. 使用 <code>prepare( )</code> 将非数据部分编译</p><pre><code>三. 使用` bindparam( ) `将数据绑定到编译结果上</code></pre><p>​ 四. 使用<code>execute( )</code> 执行编译结果</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预编译：prepare();参数是不带数据的sql语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先将sql语句中的数据部分用占位符代替 :占位符名称</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">'insert intogoods values(null,:name,:price,:number)'</span>;</span><br><span class="line"></span><br><span class="line">$smt = $pdo-&gt;prepare($sql);  <span class="comment">//返回一个PDOStament 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定数据 PDOStament对象的bindParam()来绑定参数：占位符，实际数据</span></span><br><span class="line"></span><br><span class="line">$goods_name= <span class="string">'surface'</span>;</span><br><span class="line"></span><br><span class="line">$goods_price= <span class="string">'3500'</span>;</span><br><span class="line"></span><br><span class="line">$goods_num= <span class="string">'41'</span>;</span><br><span class="line"></span><br><span class="line">$smt-&gt;bindParam(<span class="string">':name'</span>,$goods_name);</span><br><span class="line"></span><br><span class="line">$smt-&gt;bindParam(<span class="string">':price'</span>,$goods_price);</span><br><span class="line"></span><br><span class="line">$smt-&gt;bindParam(<span class="string">':number'</span>,$goods_num);</span><br><span class="line"></span><br><span class="line">$smt-&gt;execute()；</span><br></pre></td></tr></table></figure><h4 id="抽象类-PDOstatement-的方法"><a href="#抽象类-PDOstatement-的方法" class="headerlink" title="抽象类 PDOstatement 的方法"></a>抽象类 PDOstatement 的方法</h4><h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch( )"></a>fetch( )</h5><p>用于获取结果集中的下一行数据。</p><p>方法语法格式如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = <span class="number">0</span> ]]] )</span><br></pre></td></tr></table></figure><p>参数 <code>fetch_style</code>：控制结果集的返回方式，其中可选择的值如下表：</p><table><thead><tr><th>值</th><th>说 明</th></tr></thead><tbody><tr><td>PDO::FETCH_ASSOC</td><td>关联数组形式。</td></tr><tr><td>PDO::FETCH_NUM</td><td>数字索引数组形式。</td></tr><tr><td>PDO::FETCH_BOTH</td><td>两者数组形式都有，这是默认的。</td></tr><tr><td>PDO::FETCH_OBJ</td><td>按照对象的形式，类似于以前的mysql_fetch_object()函数。</td></tr><tr><td>PDO::FETCH_BOUND</td><td>以布尔值的形式返回结果，同时将获取的列值赋给bindParam()方法中指定的变量。</td></tr><tr><td>PDO::FETCH_LAZY</td><td>以关联数组、数字索引数组和对象3种形式返回结果。</td></tr></tbody></table><p>参数 <code>cursor_orientation</code>：<code>PDOStatement</code>对象的一个滚动游标，可以获取指定的一行。</p><p>参数 <code>cursor_offset</code>：游标的偏移量。</p><h5 id="fetchAll"><a href="#fetchAll" class="headerlink" title="fetchAll( )"></a>fetchAll( )</h5><p>获取结果集中的所有行，并赋给返回的数组(二维)</p><p><code>fetchAll()</code>方法的语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, <span class="keyword">array</span> $ctor_args = <span class="keyword">array</span>() ]]] )</span><br></pre></td></tr></table></figure><p>参数 <code>fetch_style</code>：控制结果集中数据的返回方式，可选值如下表：</p><table><thead><tr><th>值</th><th>说 明</th></tr></thead><tbody><tr><td>PDO::FETCH_ASSOC</td><td>关联数组形式</td></tr><tr><td>PDO::FETCH_NUM</td><td>数字索引数组形式</td></tr><tr><td>PDO::FETCH_BOTH</td><td>两者数组形式都有，这是默认的</td></tr><tr><td>PDO::FETCH_OBJ</td><td>按照对象的形式，类似于以前的mysql_fetch_object()</td></tr><tr><td>PDO::FETCH_BOUND</td><td>以布尔值的形式返回结果，同时将获取的列值赋给bindParam()方法中指定的变量</td></tr><tr><td>PDO::FETCH_LAZY</td><td>以关联数组、数字索引数组和对象3种形式返回结果。</td></tr></tbody></table><p>参数 <code>column_index</code>：字段的索引！</p><h5 id="fetchColumn"><a href="#fetchColumn" class="headerlink" title="fetchColumn( )"></a>fetchColumn( )</h5><p>获取结果集中下一行指定列的值，从结果集中的下一行返回单独的一列</p><p><code>fetchColumn()</code>方法的语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string PDOStatement::fetchColumn ([ int $column_number = <span class="number">0</span> ] )</span><br></pre></td></tr></table></figure><p>从结果集中的下一行返回单独的一列，如果无，则返回 FALSE 。</p><p>可选参数 <code>column_number</code>设置行中列的索引值，该值从0开始，如果省略该参数那么就会从第 1 列开始取值。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 语言 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(二):枚举</title>
      <link href="/2017/04/18/TypeScript(%E4%BA%8C)%E6%9E%9A%E4%B8%BE/"/>
      <url>/2017/04/18/TypeScript(%E4%BA%8C)%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>枚举也是<code>Ts</code>从静态类型语言中吸收的一个重要语言特性。作为一种基本的数据类型，枚举的应用场景还是比较多的，在我们需要一组固定的名称时，使用枚举即符合语义，又十分方便。</p><p>下面我对<code>Ts</code>中枚举的相关概念和知识做一个简单的介绍。</p></blockquote><a id="more"></a><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>数字枚举可以为一组数字赋予友好的名称。<br>既可以通过数字值得到名称，也可以通过名称得到数字。<br>枚举默认从 0 开始自动增长计数。但也可以手动指定初始值或各枚举属性的具体值。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    <span class="string">'oneDay'</span>,</span><br><span class="line">    <span class="string">'twoDay'</span></span><br><span class="line">&#125;</span><br><span class="line">Day[<span class="number">0</span>]   <span class="comment">// 'oneDay'</span></span><br><span class="line">Day.oneDay  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    <span class="string">'oneDay'</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="string">'twoDay'</span></span><br><span class="line">&#125;</span><br><span class="line">Day.twoDay <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    <span class="string">'oneDay'</span> = <span class="number">5</span>, </span><br><span class="line">    <span class="string">'twoDay'</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">Day[<span class="number">5</span>]   <span class="comment">// 'oneDay'</span></span><br><span class="line">Day.twoDay  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p></p><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>可以使用字符串字面量作为枚举属性的值，字符串枚举是没有自增长行为的。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    up = <span class="string">'UP'</span>,</span><br><span class="line">    down = <span class="string">'DOWN'</span>,</span><br><span class="line">    left = <span class="string">'LEFT'</span>,</span><br><span class="line">    right = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当然枚举也可以混合字符串和数字值，但并没有什么实用意义。</p><h3 id="枚举成员值"><a href="#枚举成员值" class="headerlink" title="枚举成员值"></a>枚举成员值</h3><p>枚举成员的值，可以是常量或者计算得出。<br>在以下情况时，枚举值被当做常量。</p><ul><li>没有值的枚举第一个成员，默认为 0</li><li>其前一个成员的值为数字常量的，其值为前一成员值加 1</li><li>其值为常数枚举表达式的，会在编译阶段求值，所以也是常量。有以下几种情况：<ul><li>成员值为字符串或数字字面量</li><li>其值为之前定义的常量枚举成员的引用（可以在另外的枚举中</li><li>其值为常数枚举表达式的四则运算和位运算。</li></ul></li></ul><h3 id="枚举成员类型"><a href="#枚举成员类型" class="headerlink" title="枚举成员类型"></a>枚举成员类型</h3><p>当枚举成员的值均为字符串字面量或数字字面量时，枚举就拥有了特殊的类型语义。即我们可以声明某值类型只能是枚举成员的值。枚举的类型也即是<strong><em>所有枚举成员的联合类型</em></strong>。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">  <span class="string">'first'</span>,</span><br><span class="line">  <span class="string">'seconed'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Day = <span class="string">'other'</span>  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p></p><h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举成员具有反向映射的能力,可以通过数字值反向得到枚举成员名。<br></p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Enum.A</span><br><span class="line">Enum.a   <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p></p><p>但需要注意，字符串枚举成员是没有反向映射的能力的。</p><h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a><code>const</code> 枚举</h3><p><code>const</code>可以用来定义一个常量枚举，这种方式定义的枚举不同于常规枚举，它不会在编译后产生多余的枚举对象<code>Js</code>代码，而是直接将枚举值内联进编译后的代码。<br><code>const</code>枚举的成员值<strong><em>只能为常量</em></strong>，不能包含计算成员。</p><h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><p>使用<code>declare</code>声明的枚举为外部枚举，用来描述已存在的枚举类型的形状。对于外部枚举来说，比较特殊的一点是，在数字枚举中，当枚举成员无初始值时，则枚举成员就会被当做需要计算的成员，而不会在自动递增从而成为常数成员。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 爬虫小例子</title>
      <link href="/2017/04/01/Python-%E7%88%AC%E8%99%AB%E5%B0%8F%E4%BE%8B%E5%AD%90/"/>
      <url>/2017/04/01/Python-%E7%88%AC%E8%99%AB%E5%B0%8F%E4%BE%8B%E5%AD%90/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>本文是Python 爬虫的一个小demo，通过这个demo ，我们可以对爬虫的一些概念和基本流程有一个大概了解。</p></blockquote><a id="more"></a><p>这道题是一道爬虫练习题，需要爬链接<a href="http://tieba.baidu.com/p/2166231880" target="_blank" rel="noopener">http://tieba.baidu.com/p/2166231880</a>里的所有妹子图片，点进链接看一下，这位妹子是日本著名性感女演员——杉本由美，^_^好漂亮啊，赶紧开始爬吧。</p><p>以下就是我的爬虫步骤：</p><h1 id="爬取图片链接"><a href="#爬取图片链接" class="headerlink" title="爬取图片链接"></a>爬取图片链接</h1><p>虽然<code>request</code>和<code>beautifulsoup</code>模块方便又好用，但是我还是决定使用传统的<code>urllib</code>和<code>urllib2</code>模块，毕竟对这两个模块熟悉之后，就能基本明白爬虫的原理和实现啦。</p><p>首先是导入模块，除了前面提到的两个模块，我们还要导入<code>re</code>模块，使用正则表达式来匹配我们想要的内容。</p><p>导入模块之后，就可以获取页面了。步骤如下：</p><ol><li><p>使用<code>urllib2.Requst( )</code>得到 <code>request</code> 对象。</p><p>这个对象是用于打开一个网页的请求，可以方便的携带一些请求需要的信息，如<code>headers</code>，<code>cookie</code>等数据。</p><p>因为我们打开的网页——百度贴吧不需要登录就可以浏览页面，所以<code>request</code>对象只需要<code>headers</code>对象就可以了。</p></li><li><p>使用<code>urllib2.urlopen( )</code>得到<code>response</code>对象。</p><p>这个对象是爬虫页面的对象，与文件对象类似，你可以使用<code>read( )</code>来得到<code>response</code>页面对象的源码。</p></li><li><p>使用正则匹配要爬的资源链接</p><p>不会正则的同学，可以学一下，很快，一个下午就能学会正则基础啦，至少爬虫使用的正则你就会写啦。我们想要得到页面的所有图片的链接，那就在浏览器中使用<code>CTRL+ALT+c</code>来打开页面查看页面的源码，也就是页面的<code>HTML</code>文本。</p><p>找一下图片的标签在哪里，发现所有要下载的图片标签<code>&lt;img&gt;</code>的类都是<code>BDE_image</code>，标签格式都一样，但是帖子中还有广告楼层里面的图片标签也是也是这个类。我可不想下载下来之后浏览美女图片，突然跳出来一个广告图片。</p><p>那再仔细看一下页面，发现只要点击只看楼主选项，广告楼层就不见了，同时页面url后面多了几个字符是<code>?see_lz=1</code> 。好，那我们直接在我们的请求url后加上这几个字符就行啦，至于其他的楼层，没有了更好^_^，反正其他楼层都是灌水。</p><p>ok，那就开始匹配我们想要的链接吧。使用<code>re.compile( )</code>来编译匹配模式，再使用<code>re.findall( )</code>得到所有的图片的src属性，也就是链接的列表。</p><p>这就完成了我们爬虫最重要的一步啦。</p></li></ol><h1 id="下载图片到本机"><a href="#下载图片到本机" class="headerlink" title="下载图片到本机"></a>下载图片到本机</h1><p>下载链接要使用<code>urllib.urlretrieve( )</code>,这个函数可以将你的链接资源下载到本地，如果指定目录的话会下载到目录，否则下载为临时文件。</p><p>那就直接迭代我们第一步得到的图片链接列表，一个个全下载下来吧。</p><p>到这里，爬这个页面的小练习，就完成啦。</p><p>我的代码在这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib,urllib2</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#头信息</span></span><br><span class="line">header=&#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:44.0) Gecko/20100101 Firefox/44.0'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_url</span><span class="params">(page_url)</span>:</span><span class="comment">#得到页面所有图片的链接</span></span><br><span class="line"></span><br><span class="line">    request=urllib2.Request(page_url,headers=header) <span class="comment">#生成request对象</span></span><br><span class="line">    reference=urllib2.urlopen(request)    <span class="comment">#获取页面对象</span></span><br><span class="line">    page=reference.read()            <span class="comment">#读取页面</span></span><br><span class="line"></span><br><span class="line">    regex=re.compile(<span class="string">r'&lt;img.*?class="BDE_Image" src="(.*?)".*?&gt;'</span>) <span class="comment">#编译正则匹配模式字符串</span></span><br><span class="line">    img_url_list=re.findall(regex,page)       <span class="comment">#匹配所有图片链接生成列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img_url_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_img</span><span class="params">(url_list,img_path)</span>:</span>  <span class="comment">#从图片链接下载图片并存放在指定文件夹</span></span><br><span class="line">    <span class="keyword">for</span> img_url <span class="keyword">in</span> url_list:</span><br><span class="line">        urllib.urlretrieve(img_url,<span class="string">'%s/%s.jpg'</span>%(img_path,img_url[<span class="number">-8</span>:<span class="number">-5</span>])) <span class="comment">#下载图片</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://tieba.baidu.com/p/2166231880?see_lz=1'</span> <span class="comment">#爬虫页面</span></span><br><span class="line">path=<span class="string">'/home/afei/picture'</span>  <span class="comment">#存放路径</span></span><br><span class="line">urllist=get_img_url(url)</span><br><span class="line">download_img(urllist,path)</span><br></pre></td></tr></table></figure><p>wow，杉本由美真的好漂亮啊，有鼻子有眼的。</p><p><img src="https://s1.ax1x.com/2018/04/15/CZNifP.png" alt="img"></p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python的MySQLdb模块在linux环境下的安装</title>
      <link href="/2017/03/29/Python%E7%9A%84MySQLdb%E6%A8%A1%E5%9D%97%E5%9C%A8linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2017/03/29/Python%E7%9A%84MySQLdb%E6%A8%A1%E5%9D%97%E5%9C%A8linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>开始学习<em>python</em>数据库编程后，在了解了基本概念，打算上手试验一下时，卡在了<em>MySQLdb</em>包的安装上，折腾了半天才解决。记录一下我在<em>linux</em>中安装此包遇到的问题和解决方法。</p><p>系统是<em>ubuntn15.04</em>。</p></blockquote><a id="more"></a><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>第一个问题是<em>pycharm</em>软件的模块安装功能<em>Project Interpreter</em>无法自动下载安装<em>MYSQLdb</em>包，显示</p><p><code>Error occurred when installling package</code></p><p>那没办法了，只好手动下载了。MYSQLdb包linux系统的下载的地址是</p><p><a href="http://sourceforge.net/projects/mysql-python/file/mysql-python/" target="_blank" rel="noopener">http://sourceforge.net/projects/mysql-python/file/mysql-python/</a></p><p>在页面内选择你想要安装的版本下载即可，我下载的版本是<code>1.2.4b4</code></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>下载之后，打开终端，切换到自己的下载文件目录，在我的电脑上是目录/home/hai/download，之后解压下载的文件，即在终端输入:</p><p><code>tar xfz MySQL-python-1.2.4b4.tar.gz</code></p></li><li><p>使用命令</p><p><code>cd MySQL-python-1.2.4b4</code></p><p>切换到解压后的目录。</p></li><li><p>编译MYSQLdb包</p><p>输入命令</p><p><code>python setup.py build</code></p><p>此时遇到问题，报错信息是</p><p><code>mysql_config not found</code></p><p>google之后发现要修改<em>MYSQLdb</em>解压之后目录中的 <em>setup_posix.py</em> 第26行，此行的内容是</p><p><code>mysql_config.path = &quot;mysql_config&quot;</code></p><p><code>mysql_config</code>是<em>mysql</em>安装目录中的一个文件的名称，需要将26行变量的值改为此文件的绝对路径。<br>使用 <code>whereis mysql</code></p><p>查看数据库安装目录，进入安装目录。但是发现安装目录中并没有<code>mysql_config</code>文件，啊，好气啊。<br>再继续 <em>google</em>，发现是没有安装<code>libmysqlclient-dev</code>，那就安装！使用命令：</p><p>​ <code>sudo apt-get install libmysqlclient-dev</code></p><p>安装这个东西，之后使用命令：</p><p>​ <code>file -name mysql_config</code></p><p>查看<code>mysql_config</code>的路径，ok，有了。</p><p>将<code>setup_posix.py</code>文件修改后，再使用<code>python setup-python-1.2.4b4</code>安装，又遇到问题了，错误信息：</p><p>​ <code>error: command &#39;i686-linux-gnu-gcc&#39; failed with exit status 1</code></p><p>啊啊啊。<br>继续<em>google</em>，原来是没有安装<code>python-dev</code>，好的，那就安装.使用命令：</p><p>​ <code>sudo apt-get install python-dev</code></p><p>安装完成后，再使用输入了N次的命令<code>python setup.py build</code>,好，终于没有报错了，现在就差一步就安装成功了。</p></li><li><p>输入命令<code>sudo python setup.py install</code></p><p>好，终于安装上了，在<code>python</code>中实验一下，导入一下<em>MYSQLdb</em>模块，</p><p>​ <code>import MYSQLdb</code></p><p>没有消息，恩，没有消息就是最好的消息，安装成功！</p></li></ol><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>另外在<em>google</em>过程中，还看到了好几个错误报警，虽然我没有遇到，还是在这里提一下。</p><p>第一个是如果没有安装<em>steuptools</em>，在第三步编译时会报错<em>ImportError: No module named setuptools</em>，那就去安装<em>setuptools</em>，至于<em>setuptools</em>的安装，那就是另外的问题了，就不多说了。<br>第二个是关于<em>python.h</em>文件报错，这是<em>python</em>版本的问题，需要处理一下<em>python</em>版本，也不再多说。</p><p>第三个是/usr/bin/ld:cannot find -lmysqlclient_r报错，这是由于配置文件没有生效。找到<em>mysql</em>的配置文件，使用<code>:ldconfig</code>命令刷新使其生效即可。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebPack 学习笔记</title>
      <link href="/2017/03/22/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/03/22/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>随着前端项目和开发环境的日益复杂和庞大，前端模块化的发展也日益精进。</p><p>作为最著名的一套解决方案，<code>webpack</code>现在已经成为前端工程师必须熟练掌握和使用的一个基本技能。</p><p>本篇博客主要介绍了<code>webpack</code>的核心概念和使用方法。</p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>模块化：将复杂的程序细化为很多模块化的文件</li><li>拓展语言的编译：如使用TS开发，并将其转换为浏览器可以识别的JS</li><li><code>Scss</code>，<code>less</code> 等 <code>CSS</code> 的预处理器</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack  //全局安装</span><br><span class="line">npm install --save-dev webpack //安装到项目目录</span><br></pre></td></tr></table></figure><h4 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h4><p>​ webpack 的几乎所有功能都可以在命令行完成，但是比较繁琐和易出错，因此一般使用配置文件完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> &#123; entry file &#125; 填写入口文件的路径</span><br><span class="line"><span class="meta">#</span> &#123; destination for bundled file &#125; 填写打包文件的路径</span><br><span class="line"><span class="meta">#</span> 填写路径时不需要添加 &#123; &#125;</span><br><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​ 配置文件一般为 <code>webpack.config.js</code> ,其实是一个简单的 <code>JavaScript</code> 模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: __dirname + <span class="string">"/app/main.js"</span> <span class="comment">//入口文件，以此为起点构建依赖图</span></span><br><span class="line">    output:&#123;</span><br><span class="line">    path: __dirname + <span class="string">"／public"</span>, <span class="comment">//打包后文件的保存位置</span></span><br><span class="line">    filename:<span class="string">"bundle.js"</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“__dirname” 是 node.js 中的一个全局变量，指向当前执行脚本所在的目录</p></blockquote><blockquote><p>使用配置文件后，只需要在命令行中使用 webpack 即可执行配置文件中的打包操作。</p><p>也可以将 webpack 使用 npm 引导执行，对 npm 的 package.json 中的 script 对象进行设置即可。</p></blockquote><h4 id="生成-Source-Maps"><a href="#生成-Source-Maps" class="headerlink" title="生成 Source Maps"></a>生成 Source Maps</h4><p>​ <code>Source Maps</code> 可以解决打包后文件的调试问题，使我们更快的找到 出问题的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool:<span class="string">'eval-source-map'</span>, <span class="comment">//有多种模式，各模式存在打包效率和打包后文件执行问题的优劣</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般情况下，cheap-module-eval-source-map都是比较好的选择</span></span><br></pre></td></tr></table></figure><p>配置项：</p><ul><li><code>eval</code>： 使用eval包裹模块代码，不产生 <code>.map</code> 文件</li><li><code>source-map</code>： 产生<code>.map</code>文件</li><li><code>cheap</code>： 不包含列信息，即只能定位到行，也不包含<code>loader</code>的<code>sourcemap</code></li><li><code>module</code>： 包含<code>loader</code>的<code>sourcemap</code>（比如<code>jsx to js</code> ，<code>babel</code>的<code>sourcemap</code>）</li><li><p><code>inline</code>： 将<code>.map</code>作为DataURI嵌入，不单独生成<code>.map</code>文件（这个配置项比较少见</p><p>​ <code>eval</code>性能最好，<code>source-map</code>性能最低，</p></li></ul><h4 id="构建本地服务器"><a href="#构建本地服务器" class="headerlink" title="构建本地服务器"></a>构建本地服务器</h4><h5 id="安装-webpack-dev-server"><a href="#安装-webpack-dev-server" class="headerlink" title="安装 webpack-dev-server"></a>安装 <code>webpack-dev-server</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><h5 id="在配置文件中添加配置"><a href="#在配置文件中添加配置" class="headerlink" title="在配置文件中添加配置"></a>在配置文件中添加配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:<span class="string">"./public"</span>,  <span class="comment">//本地服务器要加载的页面所在位置</span></span><br><span class="line">        port:<span class="string">"8081"</span>, <span class="comment">//默认 8080</span></span><br><span class="line">        historyApiFallback:<span class="literal">true</span>, <span class="comment">//在开发单页面应用时，可使所有路径都指向index.html</span></span><br><span class="line">        inline：<span class="literal">true</span><span class="comment">//源文件变化时自动刷新页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --open</span><br></pre></td></tr></table></figure><blockquote><p>也可将此命令加入 npm 的 package.json 的 script 对象中，引导启动。</p></blockquote><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>​ 通过使用不同的 <code>loader</code>, <code>webpack</code> 有能力调用外部的脚本和工具，实现不同格式的文件的处理。例如将 <code>scss</code> 转换为 <code>css</code>，将 <code>ES6</code>，<code>ES7</code>转换为 <code>ES5</code>，将 <code>React</code> 的 <code>JSX</code> 文件转换为 <code>JS</code> 文件。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​ <code>Loader</code>需要单独安装并且需要在 <code>webpack.config.js</code> 中的 <code>modules</code> 中配置。</p><p>配置主要包括</p><ul><li><code>test</code> : 一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须）</li><li><code>loader</code>： loader 的名称（必须）</li><li><code>include/excluder</code>: 手动添加必须处理的文件／屏蔽不必要的文件 （可选）</li><li><code>query</code> : 为 <code>loaders</code> 提供额外的设置选项</li></ul><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p><code>Babel</code> 是一个编译 JavaScript 的平台。可以将 <code>ES6，ES7</code> 转换为 <code>ES5</code>，将 <code>React</code> 的 <code>JSX</code> 文件转换为 <code>JS</code> 文件。</p><h5 id="Babel的安装"><a href="#Babel的安装" class="headerlink" title="Babel的安装"></a><code>Babel</code>的安装</h5><p><code>Babel</code> 其实是几个模块化的包，核心功能位于 <code>babel-core</code> 的 npm 包中。</p><p><code>babel-preset-env</code>用于解析 ES6</p><p><code>babel-preset-react</code> 用于解析 JSX</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</span><br></pre></td></tr></table></figure><h5 id="Babel的配置"><a href="#Babel的配置" class="headerlink" title="Babel的配置"></a>Babel的配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:<span class="string">"babel-loader"</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        presets:[</span><br><span class="line">                            <span class="string">"env"</span>,<span class="string">"react"</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以将 Babel 的配置文件放在一个单独的 <code>.babelrc</code> 的文件中，webpack会自动读取。</p></blockquote><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>​ webpack 提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code></p><p>​ <code>css-loader</code> 使你能够使用类似 <code>@import</code> 和 <code>url(...)</code> 实现类似 <code>require()</code>的功能</p><p>​ <code>style-loader</code> 将所有计算后的样式加入页面内。</p><p>​ <code>webpack</code> 将 Css 文件也视作模块，可以通过 <code>import</code> 导入到入口文件</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装</span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">"style-loader"</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: <span class="string">"css-loader"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h5><p>被称为<code>CSS modules</code>的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">"style-loader"</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: <span class="string">"css-loader"</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: <span class="literal">true</span>, <span class="comment">// 指定启用css modules</span></span><br><span class="line">                            localIdentName: <span class="string">'[name]__[local]--[hash:base64:5]'</span> <span class="comment">// 指定css的类名格式</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="CSS预处理"><a href="#CSS预处理" class="headerlink" title="CSS预处理"></a>CSS预处理</h4><p>以下是常用的CSS 处理<code>loaders</code>:</p><ul><li><code>Less Loader</code></li><li><code>Sass Loader</code></li><li><code>Stylus Loader</code></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。</p><p>与在打包构建过程中用来处理源文件的 Loader 不同，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'版权所有，翻版必究'</span>) <span class="comment">//此插件用于添加文件末尾版权标志</span></span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h4><ul><li><code>HtmlWebpackPlugin</code> :依据一个简单的<code>index.html</code>模板，生成一个自动引用你打包后的JS文件的新<code>index.html</code>。在每次生成的js文件名称不同时非常有用</li><li><code>Hot Module Replacement</code> : 它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</li><li><code>OccurenceOrderPlugin</code> :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li><li><code>UglifyJsPlugin</code>：压缩JS代码；</li><li><code>ExtractTextPlugin</code>：分离CSS和JS文件</li><li><code>clean-webpack-plugin</code> : 去除<code>build</code>文件中的残余文件</li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript(一):基础类型</title>
      <link href="/2017/03/22/TypeScript(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/03/22/TypeScript(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>TS</code>作为<code>JS</code>的超集，引入了许多静态语言中的一些特性。这些特性，在大型的项目开发中，还是比较有用的。作为冉冉升起的明星语言，在前端迭代越来越快的今天，还是非常值得学习一下的。</p><p>本篇博客主要介绍了<code>Ts</code>的基础类型。</p><p>持续更新。</p></blockquote><a id="more"></a><h3 id="安装编译和构建"><a href="#安装编译和构建" class="headerlink" title="安装编译和构建"></a>安装编译和构建</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用<code>npm</code>包管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h4 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc file.ts</span><br></pre></td></tr></table></figure><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>相对与<code>JavaScript</code>，<code>Ts</code>又新增了<strong>元组</strong> ,<strong>只读数组</strong>，<strong>Never</strong>，<strong>Any</strong> 类型。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li><code>0x</code> 16进制字面量</li><li><code>0o</code> 8进制字面量</li><li><code>0b</code> 2进制字面量</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'abc'</span></span><br></pre></td></tr></table></figure><p><strong><em>模板字符串</em></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;1+2&#125;</span> abc <span class="subst">$&#123;3+5&#125;</span>`</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="常规定义"><a href="#常规定义" class="headerlink" title="常规定义"></a>常规定义</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h5 id="数组泛型定义"><a href="#数组泛型定义" class="headerlink" title="数组泛型定义"></a>数组泛型定义</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="只读数组"><a href="#只读数组" class="headerlink" title="只读数组"></a>只读数组</h4><p>使用<code>ReadonlyArray&lt;T&gt;</code>来声明一个所有可变方法都被去掉的只读数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]arr[<span class="number">0</span>] = <span class="number">10</span>   <span class="comment">//errorarr.push(4)   //errorarr.length = 100 //error</span></span><br></pre></td></tr></table></figure><p>只读数组只能通过类型断言来赋值给普通数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = arr <span class="keyword">as</span> <span class="built_in">number</span>[]</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>访问元组越界元素，会使用联合类型。</p></blockquote><h4 id="Null-amp-amp-Undefined"><a href="#Null-amp-amp-Undefined" class="headerlink" title="Null &amp;&amp; Undefined"></a>Null &amp;&amp; Undefined</h4><p>在 Ts 中为两种类型，这两种类型是其他所有类型的子类型，可以赋值给任意类型(除了<code>never</code>类型。</p><blockquote><p>使用<code>--strictNullChecks</code>标记，则 <code>null</code> 和 <code>undefined</code> 只能赋值给自身或赋值给 <code>void</code></p></blockquote><h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>表示无任何类型，通常用于无返回值函数的返回值定义，只能被赋值<code>undefined</code>和<code>null</code>。</p><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><ul><li><code>any</code>表示任意类型，可以赋任意值。</li><li>与<code>Object</code>类型不同的是，<code>any</code>也可以调用任意方法。</li><li>可以用来声明一个包含不同类型的数组, 如<code>let arr: any[] = [1, &#39;2&#39;, true]</code></li></ul><h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p>表示永不存在的值类型，如总是抛出异常的函数的返回值, 或者永不为真的变量值等。<br><code>never</code>是任何类型的子类型，可以赋值给任意类型。<br><code>never</code>不能被任意类型赋值，除了自身。即便<code>any</code>也不行。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL 的基本语法</title>
      <link href="/2017/03/22/SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/03/22/SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>作为前端，基本的<code>SQL</code>语句还是要会一些的嘛(虽然我并想去学那些听起来就很麻烦的存储过程视图什么的。。摔</p></blockquote><a id="more"></a><h3 id="SELECT-选取"><a href="#SELECT-选取" class="headerlink" title="SELECT 选取"></a>SELECT 选取</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country <span class="keyword">FROM</span> web; //选择对应列</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web;      //选择所有列</span><br></pre></td></tr></table></figure><h4 id="DISTINCT-去重"><a href="#DISTINCT-去重" class="headerlink" title="DISTINCT 去重"></a>DISTINCT 去重</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> country <span class="keyword">FROM</span> web; //返回唯一不同的值（即去重）;</span><br></pre></td></tr></table></figure><h4 id="WHERE-限定条件"><a href="#WHERE-限定条件" class="headerlink" title="WHERE 限定条件"></a>WHERE 限定条件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> country=<span class="string">'CN'</span>; //选取满足条件的记录</span><br></pre></td></tr></table></figure><blockquote><p>WHERE 字句中可以使用的运算符</p><p>= &gt; &lt; &gt;= &lt;= !=(&lt;&gt;)</p><p>AND 同时满足条件</p><p>OR 满足其中一个条件</p><p>NOT 不满足条件</p><p>BETWEEN 在某个范围内 (可为数字值范围或字母表字母范围)(mysql 包含边界)</p><p>LIKE 符合某种模式</p><p>IN 是多个可能值其中的一个</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*AND,OR,NOT 逻辑运算*：</span><br><span class="line">//优先级 ：（） NOT AND OR</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> sal&gt;<span class="number">2000</span> <span class="keyword">AND</span> sal&lt;<span class="number">3000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> sal&gt;<span class="number">2000</span> <span class="keyword">OR</span> sal&lt;<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> <span class="keyword">NOT</span> sal&gt;<span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">*IS NULL 空值判断*：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> sal <span class="keyword">IS</span> <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line">*<span class="keyword">BETWEEN</span> <span class="keyword">AND</span> 在两值之间*</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> sal <span class="keyword">BETWEEN</span> <span class="number">1500</span> <span class="keyword">AND</span> <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">*IN  多个值中的一个*</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> sal <span class="keyword">IN</span> (<span class="number">5000</span>,<span class="number">3000</span>,<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">*LIKE 模糊查询*</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'M%'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>模糊查询</p><p>% 表示多个字值，</p><p>M% 表示模糊查询以 M 开头的记录</p><p>%M% 表示包含 M 的所有内容</p><p>%M_ 表示模糊查询 M在倒数第二位的所有内容</p><p>_下划线表示一个字符;</p><p>REGEXP 或 NOT REGEXP 运算符来操作正则表达式（RLIKE &amp; NOT RLIKE也可以)</p><p>[charlist] 字符列中的任何单一字符</p><p>[!charlist] 不在字符列中的任何单一字符</p></blockquote><h4 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h4><blockquote><p>按照一个列或多个列对结果集进行排序。</p><p>默认 ASC 升序，可以使用 DESC 进行降序排列</p><p>多个列根据顺序排序，从前到后。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal;  //默认升序排序</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span>;//降序排列</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>,sal; //先根据 id排序，id 相同的再根据 sal 排序。</span><br></pre></td></tr></table></figure><h4 id="SELECT-TOP-限定返回数目"><a href="#SELECT-TOP-限定返回数目" class="headerlink" title="SELECT TOP 限定返回数目"></a>SELECT TOP 限定返回数目</h4><blockquote><p>select top 用于规定要返回的记录数目</p><p>oracle 不支持SELECT TOP，他使用 ORDER BY 加 限定 ROWNUM</p><p>mysql 和 postgres 不支持 SELECT TOP，他们使用 limit。</p></blockquote><h5 id="limit-限定返回数目"><a href="#limit-限定返回数目" class="headerlink" title="limit 限定返回数目"></a>limit 限定返回数目</h5><blockquote><blockquote><p>可给定一个或两个参数。</p><p>一个参数表示返回的最大记录行数。</p><p>两个参数，第一个参数表示偏移行数，第二个参数表示返回行数</p></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">LIMIT</span> <span class="number">10</span>; //限定返回前10行</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">10</span>; //限定返回 6-15行</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> web <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">-1</span>; //限定返回第 6 行以后的所有行</span><br></pre></td></tr></table></figure><h3 id="INSERT-INTO-插入"><a href="#INSERT-INTO-插入" class="headerlink" title="INSERT INTO 插入"></a>INSERT INTO 插入</h3><blockquote><p>向表中插入新纪录</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*两种插入语句编写形式</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> web <span class="keyword">VALUES</span> (<span class="string">'goo'</span>,<span class="string">'www'</span>,<span class="number">144</span>,<span class="string">'CN'</span>);//只提供插入值的形式（需要列出行的每一列数据）</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> web (<span class="keyword">name</span>,<span class="keyword">url</span>,alexa,country) <span class="keyword">VALUES</span> (<span class="string">'goo'</span>,<span class="string">'www'</span>,<span class="number">1444</span>,<span class="string">'CN'</span>);//提供列名和插入值的形式</span><br></pre></td></tr></table></figure><h3 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h3><blockquote><p>更新表中已存在的记录</p><p>如果省略了 UPDATE 的 WHERE 子句，表中对应的所有字段都会被更新。因此在使用 无 WHERE 子句的 UPDATE 时 应千万慎重。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> web <span class="keyword">SET</span> sal=<span class="string">"500"</span>,country=<span class="string">"USA"</span>;//不带WHERE字句的 UPDATAE 语句，会更新所有的 sal 和 country 字段，使用时需要十分小心</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> web <span class="keyword">SET</span> sal=<span class="string">'500'</span>,country=<span class="string">"USA"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>  //带 <span class="keyword">WHERE</span> 子句的 <span class="keyword">UPDATE</span> 语句，只更新对应行字段</span><br></pre></td></tr></table></figure><blockquote></blockquote><h3 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE 删除"></a>DELETE 删除</h3><blockquote><p>删除表中的记录</p><p>如果省略了 DELETE 的 WHERE 子句，表中对应的所有字段都会被删除。因此在使用 无 WHERE 子句的 DELETE 时 应千万慎重。</p><p>删除无法还原，因此应慎重</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> web；//删除表中所有的行。表结构，属性，索引会保持不变</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> web <span class="keyword">where</span> sal = <span class="number">6000</span> ; //删除对应的行</span><br></pre></td></tr></table></figure><h3 id="AS-别名"><a href="#AS-别名" class="headerlink" title="AS 别名"></a>AS 别名</h3><blockquote><p>为表名称和列名称指定别名，提高可读性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//为列使用别名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">AS</span> n <span class="keyword">FROM</span> web;</span><br><span class="line"></span><br><span class="line">//将多列聚合到一起并使用别名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span> (<span class="string">'name'</span>,<span class="string">','</span>,<span class="string">'url'</span>,<span class="string">','</span>,<span class="string">'sal'</span>) <span class="keyword">AS</span> site_info <span class="keyword">FROM</span> web;</span><br><span class="line"></span><br><span class="line">//为表使用别名</span><br><span class="line"><span class="keyword">SELECT</span> w.name,a.date <span class="keyword">FROM</span> web <span class="keyword">AS</span> w,access_log <span class="keyword">AS</span> a <span class="keyword">WHERE</span> a.site_id = w.id;</span><br></pre></td></tr></table></figure><h3 id="JOIN-结合来自多个表的行"><a href="#JOIN-结合来自多个表的行" class="headerlink" title="JOIN 结合来自多个表的行"></a>JOIN 结合来自多个表的行</h3><blockquote><p>JOIN 分为 INNER JOIN，LEFT JOIN ，RIGHT JOIN，FULL JOIN。</p><p>注意合并条件需要使用关键字 ON 而不是 WHERE</p><p>INNER JOIN：返回完全匹配的行 （等同于 JOIN）</p><p>LEFT JOIN：返回左表所有行，其中 在 右表 无匹配的行中对应右表值为 NULL。</p><p>RIGHT JOIN ：返回右表所有的行，其中在 左表 无匹配的行对应左表值为NULL。</p><p>FULL JOIN：返回左右两表所有的行，在另一表中无匹配的行 对应表值为NULL (MYSQL 不支持)</p></blockquote><h3 id="UNION-合并结果"><a href="#UNION-合并结果" class="headerlink" title="UNION 合并结果"></a>UNION 合并结果</h3><blockquote><p>UNION 用于 合并两个或多个 SELECT 语句的结果集。两个结果集必须有相同数量的列，列数据类型相似且顺序相同。</p><p>UNION操作符选取不同的值，UNION ALL 允许重复的值。</p><p>结果集中的列名总是等于 第一个 SELECT 语句中的列名</p><p>只能在最后使用一个ORDER BY 命令，也就是合并查询结果后再进行排序，不能写</p></blockquote><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用python解数独</title>
      <link href="/2017/03/19/%E4%BD%BF%E7%94%A8python%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
      <url>/2017/03/19/%E4%BD%BF%E7%94%A8python%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>偶然发现<em>linux</em>系统附带的一个数独游戏，打开玩了几把。无奈是个数独菜鸟，以前没玩过，根本就走不出几步就一团浆糊了。</p><p>于是就打算借助计算机的强大运算力来暴力解数独，还是很有乐趣的。</p><p>本篇博客就记录一下我使用<code>python</code>写解数独程序的一些思路和心得。</p></blockquote><a id="more"></a><h3 id="数独游戏的基本解决方法"><a href="#数独游戏的基本解决方法" class="headerlink" title="数独游戏的基本解决方法"></a>数独游戏的基本解决方法</h3><p>编程笼统的来说,就是个方法论。不论什么程序，都必须将问题的解决过程分解成计算机可以实现的若干个简单方法。俗话说，大道至简。对于只能明白0和1的计算机来说，就更需要细分步骤，一步一步的解决问题了。</p><p>首先来思考一下解数独的基本概念。</p><p>数独横九竖九共八十一个格子，同时又分为9个九宫格。规则很简单——需要每一个格中的数字，都保证与其所在横排和竖排以及九宫格内无相同数字。</p><p>所以我们的大概思路就是，从第一个空格开始试着填数，从 1 开始填，如果 1 不满足横排竖排九宫格无重复的话，就再填入 2 ，以此类推，直到填入一个暂时满足规则的数，中断此格，移动到下一个空格重复这个过程。</p><p>如果到达某个空格发现已经无数可选了，说明前面某一格填错了，那就返回上一格，从上一格的中断处继续往 9 尝试，直到这样回朔到填错的那一格。</p><p>这样的话，我们就可以整理出重要的步骤了：</p><ul><li>寻找到下一个空格</li><li>轮流填入格中数字 1 到 9</li><li>递归判断填入数是否符合规则</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先测试数独使用的是芬兰数学家因卡拉花费3个月时间设计出的世界上迄今难度最大的数独。如下:</p><p><img src="https://s1.ax2x.com/2018/04/15/k0xDJ.png" alt="a.png"></p><p>将空格用 0 表示，同时将数独表示成嵌套的列表，这样每格的行数和列数就正好是列表中每个对应数的索引。</p><p>程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,board)</span>:</span></span><br><span class="line">        self.b = board</span><br><span class="line">        self.t = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self,x,y,value)</span>:</span><span class="comment">#检查每行每列及每宫是否有相同项</span></span><br><span class="line">        <span class="keyword">for</span> row_item <span class="keyword">in</span> self.b[x]:</span><br><span class="line">            <span class="keyword">if</span> row_item == value:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> row_all <span class="keyword">in</span> self.b:</span><br><span class="line">            <span class="keyword">if</span> row_all[y] == value:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        row,col=x/<span class="number">3</span>*<span class="number">3</span>,y/<span class="number">3</span>*<span class="number">3</span></span><br><span class="line">        row3col3=self.b[row][col:col+<span class="number">3</span>]+self.b[row+<span class="number">1</span>][col:col+<span class="number">3</span>]+self.b[row+<span class="number">2</span>][col:col+<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> row3col3_item <span class="keyword">in</span> row3col3:</span><br><span class="line">            <span class="keyword">if</span> row3col3_item == value:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self,x,y)</span>:</span><span class="comment">#得到下一个未填项</span></span><br><span class="line">        <span class="keyword">for</span> next_soulu <span class="keyword">in</span> range(y+<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> self.b[x][next_soulu] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x,next_soulu</span><br><span class="line">        <span class="keyword">for</span> row_n <span class="keyword">in</span> range(x+<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> col_n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> self.b[row_n][col_n] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> row_n,col_n</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>,<span class="number">-1</span>  <span class="comment">#若无下一个未填项，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_it</span><span class="params">(self,x,y)</span>:</span><span class="comment">#主循环</span></span><br><span class="line">        <span class="keyword">if</span> self.b[x][y] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):<span class="comment">#从1到9尝试</span></span><br><span class="line">                self.t+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.check(x,y,i):<span class="comment">#符合 行列宫均无条件 的</span></span><br><span class="line">                    self.b[x][y]=i <span class="comment">#将符合条件的填入0格</span></span><br><span class="line">                    next_x,next_y=self.get_next(x,y)<span class="comment">#得到下一个0格</span></span><br><span class="line">                    <span class="keyword">if</span> next_x == <span class="number">-1</span>: <span class="comment">#如果无下一个0格</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment">#返回True</span></span><br><span class="line">                    <span class="keyword">else</span>:        <span class="comment">#如果有下一个0格，递归判断下一个0格直到填满数独</span></span><br><span class="line">                        end=self.try_it(next_x,next_y)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> end:   <span class="comment">#在递归过程中存在不符合条件的，即 使try_it函数返回None的项</span></span><br><span class="line">                        self.b[x][y] = <span class="number">0</span>    <span class="comment">#回朔到上一层继续</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        begin = datetime.datetime.now()</span><br><span class="line">        <span class="keyword">if</span> self.b[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            self.try_it(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x,y=self.get_next(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">            self.try_it(x,y)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.b:</span><br><span class="line">            <span class="keyword">print</span> i</span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'\ncost time:'</span>, end - begin</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'times:'</span>,self.t</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s=solution([[<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="number">73</span> s.start()</span><br></pre></td></tr></table></figure><p>值得注意的是使用的递归判断能够很巧妙的在走错分支时回朔到上一层。具体实现是通过 for 循环来从 1 到 9 不断填入数字同时达到记录中断点的作用。通过下一层的返回值来确定是否回朔。</p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[8, 1, 2, 7, 5, 3, 6, 4, 9]</span><br><span class="line">[9, 4, 3, 6, 8, 2, 1, 7, 5]</span><br><span class="line">[6, 7, 5, 4, 9, 1, 2, 8, 3]</span><br><span class="line">[1, 5, 4, 2, 3, 7, 8, 9, 6]</span><br><span class="line">[3, 6, 9, 8, 4, 5, 7, 2, 1]</span><br><span class="line">[2, 8, 7, 1, 6, 9, 5, 3, 4]</span><br><span class="line">[5, 2, 1, 9, 7, 4, 3, 6, 8]</span><br><span class="line">[4, 3, 8, 5, 2, 6, 9, 1, 7]</span><br><span class="line">[7, 9, 6, 3, 1, 8, 4, 5, 2]</span><br><span class="line"></span><br><span class="line">cost time: 0:00:00.060687</span><br><span class="line">times: 45360</span><br></pre></td></tr></table></figure><p>可以看到程序虽然运算次数比较多，但是速度还是很快的。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Angular 框架的一些知识点</title>
      <link href="/2017/01/22/Angular%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2017/01/22/Angular%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>本篇博客主要介绍了在手动进行<code>Angular</code>的新建模块，组件，服务等操作时一些需要注意的地方，例如添加特定位置的声明，使用从何模块导入的装饰器等。</p><p>比较细碎，不成系统，权当笔记。</p></blockquote><a id="more"></a><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>1.需要使用 @NgModule 装饰器函数传入模块的相关信息来定义模块</p><p>2.HTTP模块，Route模块等类似模块，可以导入到根模块中，也可以导入到自定义的模块中。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>1.需要在 <code>AppModule</code> 的 <code>declarations</code> 属性 中声明</p><p>2.需要使用 <code>Component</code> 装饰器函数传入组件的相关信息。</p><p>3.若有输入属性，需要使用 <code>Input</code> 装饰器(从<code>@angular</code>中导入)装饰属性</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>1.需要使用 <code>Injectable</code> 装饰器 （从 <code>angualr/core</code> 中导入）定义</p><p>3.需要在 <code>AppModule</code> 的 <code>providers</code>属性 中声明</p><p>4.通过组件的构造函数向组件中引入服务。</p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>1.需要从 <code>@angular/forms</code>中导入 <code>FormsModule</code> 到 <code>AppModule</code>的 <code>imports</code> 属性中。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>1.需要从 <code>@angular/router</code> 中导入 <code>RouterModule</code></p><p>2.使用 <code>RouterModule.forRoot()</code>配置路由信息，并将其返回值在 <code>AppModule</code> 或单独的路由模块中 的 imports 属性中声明。</p><p>3.<code>ActivatedRoute</code>包含很多有用的路由信息。另外这些信息大部分是 <strong>可观察对象</strong>。</p><p>3.导航标签可使用指令 <code>routerLink = “所定义path”</code>进行导航定义,也可以使用命令式的</p><p><code>Router.navigate(),routerLinkActive</code>可用于定义激活链接的css类。</p><p>4.<code>&lt;router-outlet&gt;&lt;router-outlet&gt;</code>标签用于定义导航组件的显示位置。</p><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><p>1.需要从 <code>@angular/http</code> 中导入 <code>HttpModule</code></p><p>2.<code>Http</code>服务中的 方法都返回一个 <code>Response</code> 对象的可观察对象。可将其转换为 <code>Promise</code> 对象用于返回，也可直接使用。</p><p>3.可观察对象主要用于持续多次发送请求的场景比如搜索推荐等。</p><p>4.组件模块中进行请求数据的整理和返回结果的处理，在 服务模块里 进行 数据请求动作。也可以通过再加一层 服务 来模块化相关的数个请求，将此模块作为专门的数据接口模块。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>比特和字节，带宽和网速</title>
      <link href="/2017/01/05/%E6%AF%94%E7%89%B9%E5%92%8C%E5%AD%97%E8%8A%82%EF%BC%8C%E5%B8%A6%E5%AE%BD%E5%92%8C%E7%BD%91%E9%80%9F/"/>
      <url>/2017/01/05/%E6%AF%94%E7%89%B9%E5%92%8C%E5%AD%97%E8%8A%82%EF%BC%8C%E5%B8%A6%E5%AE%BD%E5%92%8C%E7%BD%91%E9%80%9F/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>最近几天家里网不太好，在观察网速时，发现网速和带宽常用的单位与存储常用的单位其实是不一样的。</p><p>在这篇博客中，就来整理一下存储单位和网速的一些知识。</p></blockquote><a id="more"></a><h1 id="存储单位的bit-和-Byte"><a href="#存储单位的bit-和-Byte" class="headerlink" title="存储单位的bit 和 Byte"></a>存储单位的bit 和 Byte</h1><h2 id="bit（比特）"><a href="#bit（比特）" class="headerlink" title="bit（比特）"></a>bit（比特）</h2><p><em>bit</em>也就是我们不一定听说过的比特，大名鼎鼎的比特币就是以此命名的。它的简写为小写字母 “<em>b</em>” 。</p><p><em>作为</em>信息技术的最基本存储单元，因为比特实在太小了，所以大家生活中并不是经常听到。那么 <em>bit</em> 是什么呢？</p><p>电脑是以二进制存储以及发送接收数据的。二进制的一位，就叫做 1 <em>bit</em>。也就是说 <em>bit</em> 的含义就是二进制数中的一个数位，即 “0” 或者 “1”。</p><h2 id="Byte（字节）"><a href="#Byte（字节）" class="headerlink" title="Byte（字节）"></a>Byte（字节）</h2><p><em>Byte</em> 是字节的英文写法。它的简写为大写字母 “<em>B</em>“。</p><p>既然名字叫字节，那肯定跟字符有关系。是的。英文字符通常是一个字节，也就是 <em>1B</em>，中文字符通常是两个字节，也就是 <em>2B</em>。</p><p>字节 <em>Byte</em> 和比特 <em>bit</em> 的换算关系是 <em>1</em> <em>Byte</em> <em>=</em> <em>8</em> <em>bit</em> 。</p><h2 id="KB-（千字节）"><a href="#KB-（千字节）" class="headerlink" title="KB （千字节）"></a>KB （千字节）</h2><p>需要了解的是，1 <em>KB</em> 并不是一千字节，因为计算机只认识二进制，所以在这里的 <em>KB</em>，是 2 的 10 次方，也就是 1024 个字节。</p><p>另外很多表示存储单位的地方都把 <em>B</em> 写成 <em>b</em>，造成了大家认知的混乱。其实在存储单位计量中出现 <em>b</em> 的地方，它的意思仍然是 <em>B</em>，不要因为 bit 的缩写是 b 就被误导了，在存储计量中是不会用 比特，千比特 这种单位的。但是在网速计量中，<em>b</em>的真实意思就是指 比特 了，这个我们下面再说。</p><h2 id="换算"><a href="#换算" class="headerlink" title="换算"></a>换算</h2><p>存储单位换算关系如下</p><table><thead><tr><th>1 Byte = 8 bit</th><th></th></tr></thead><tbody><tr><td>1 KB= 1024 B</td><td></td></tr><tr><td>1 MB = 1024 KB</td><td></td></tr><tr><td>1 GB = 1024 MB</td><td></td></tr><tr><td>1 TB = 1024 GB</td></tr></tbody></table><h1 id="带宽和网速"><a href="#带宽和网速" class="headerlink" title="带宽和网速"></a>带宽和网速</h1><p>网络线路的计量单位，也就是我们通常说的 <em>2M</em> 宽带，<em>10 M</em> 宽带的单位，是 比特每秒（<em>bits per second</em>）。比特每秒 的缩写为 <em>bps</em>，意思是每秒接收的平均比特数。更大的单位是 千比特每秒（<em>Kbps</em>）或 兆比特每秒（<em>Mbps</em>）。<em>2M</em>宽带，意味着每秒平均可以接受 <em>2Mb</em> 的数据，也就是二百万左右比特的数据，在这里，小写 <em>b</em> 的意思就是比特了。</p><p>而通常我们说的下载速度，也就是网速，是每秒下载的字节数。比如网速是 5 <em>KB</em>（这网速可是够慢的），意思就是每秒接收的数据是 五千字节。</p><p>那我们根据 一字节 等于 8 比特的 换算方法，就可以得出以下结论。</p><p>下载速度从理论上来说，应该是 带宽的 八分之一。</p><p><em>2M</em> 宽带理论下载速度是 <em>256 KB</em></p><p><em>10M</em> 宽带理论下载速度是 <em>1280 KB</em></p><p>实际上由于我们还需要接受一些下载需要的一些信息，如 <em>IP</em> 信息，<em>HTTP</em> 信息，再加上服务器传输速度，电脑配置等原因，网速会比理论慢一些。</p><p>由于很多人都会混淆 字节的大写 <em>B</em> 和比特的小写 <em>b</em>，造成各种混乱。所以在书写单位缩写时，一定要注意 字节 和 比特 的单位的大小写 。</p><p>总结一下，有以下几个要点需要注意：</p><ul><li><strong>存储单位和网速的单位，不管是 <em>B</em> 还是 <em>b</em>，代表的都是 字节 <em>Byte</em>。</strong></li><li><strong>带宽的单位，不管是 <em>B</em> 还是 <em>b</em>，代表的都是 比特 <em>bit</em> 。</strong></li></ul><p>只要记住这两点，就算别人写混淆了，我们也是可以明白单位的具体含义的。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery中append(),prepend()与after(),before()的区别</title>
      <link href="/2016/11/11/jQuery%E4%B8%ADappend(),prepend()%E4%B8%8Eafter(),before()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016/11/11/jQuery%E4%B8%ADappend(),prepend()%E4%B8%8Eafter(),before()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在jQuery中，添加元素有<code>append()</code>,<code>prepend</code>和 <code>after()</code>,<code>before()</code>两种共四个。对于很多初学者来说，还是很容易混淆他们的作用和使用方式的。</p><p>在此对于这四个方法的使用和注意事项进行了一些总结。</p></blockquote><a id="more"></a><p>根据字面意思，我们可以看出这四种方法的含义分别是追加，添加和之前，之后，意思相近。同时他们又都有添加元素的作用，容易混淆。</p><p>要想搞清楚他们之间的区别。首先我们要明白这几个函数各自的作用。</p><h3 id="append-和prepend"><a href="#append-和prepend" class="headerlink" title="append()和prepend()"></a>append()和prepend()</h3><p>append()用于在<strong>被选元素的结尾</strong>插入元素。</p><p>prepend()用于在<strong>被选元素的开头</strong>插入元素。</p><p>重点在于黑体字——<strong>被选元素的，</strong></p><p>也就是说这两个函数的添加都是添加到元素的内部的。</p><p><em>看下面的HTML代码</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>使用 append( ) 和 prepend( )添加元素</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test"</span>).append(<span class="string">"&lt;p&gt;b&lt;/p&gt;"</span>) <span class="comment">//使用append()添加 b 段落</span></span><br><span class="line">    $(<span class="string">"#test"</span>).prepend(<span class="string">"&lt;p&gt;c&lt;/p&gt;"</span>) <span class="comment">//使用 prepend()添加 c 段落</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><em>效果如下</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>c<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面可以得知，当我们使用 <code>append()</code> 和 <code>prepend()</code>往 <code>id</code> 为 <code>test</code> 的 <code>div</code> 块添加元素时，是添加到 <code>div</code> 内部的。</p><p>也就是说，我们添加的元素，<strong>成为了 被添加元素 的 子元素</strong>。</p><h3 id="after-和-before"><a href="#after-和-before" class="headerlink" title="after() 和 before()"></a>after() 和 before()</h3><p>after()用于在被选<strong>元素之后</strong>插入内容。</p><p>before()用于在被选<strong>元素之前</strong>插入内容。</p><p>重点在于黑体字元素之前 ，元素之后。</p><p>这意味着这两个函数是往元素外部的前后添加的。</p><p>还是刚刚的HTML代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 after() 和 before()添加元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test"</span>).after(<span class="string">"&lt;p&gt;b&lt;/p&gt;"</span>)</span><br><span class="line">    $(<span class="string">"#test"</span>).before(<span class="string">"&lt;p&gt;c&lt;/p&gt;"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;c&lt;/p&gt;</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;</span><br><span class="line">    &lt;p&gt;a&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;b&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>从结果可知，<code>after( )</code> 和 <code>before( )</code> 往 <code>id=”test“</code> 的 <code>div</code>块添加元素时，是添加到块外部的。</p><p>也就是说，添加的元素，成为了 <strong>被添加元素的 兄弟元素。</strong></p><h3 id="区别和总结"><a href="#区别和总结" class="headerlink" title="区别和总结"></a>区别和总结</h3><p>通过上面两个例子，我们可以清楚的看到四个函数 append 和 prepend 与 after和before 的区别。</p><p>只要明白 <strong>往元素内的前后添加</strong> 和 <strong>往元素外的前后添加</strong> 的区别，就很容易区分了。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 的几种数组去重方法</title>
      <link href="/2016/09/18/JavaScript%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2016/09/18/JavaScript%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>JS</code> 的数组去重，作为经常遇到的场景，有很多种实现方式。</p><p>本篇博客主要总结了常见常用的一些<code>js</code>数组去重方法。</p></blockquote><a id="more"></a><h5 id="最基本的数组去重"><a href="#最基本的数组去重" class="headerlink" title="最基本的数组去重"></a>最基本的数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = [];   <span class="comment">//初始值也可为 arr[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j =<span class="number">0</span>;j &lt; b.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == b[j])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;   </span><br><span class="line">                <span class="comment">//可在此处直接break跳出本层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            b.push(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Object"><a href="#使用Object" class="headerlink" title="使用Object"></a>使用<code>Object</code></h5><p>通过<code>Object</code>的<code>key</code>来进行筛选去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!hash[arr[i]])&#123;</span><br><span class="line">          hash[arr[i]] = <span class="literal">true</span>;</span><br><span class="line">          b.push(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用indexOf-方法"><a href="#使用indexOf-方法" class="headerlink" title="使用indexOf() 方法"></a>使用<code>indexOf()</code> 方法</h5><p>​ 思路类似第一种方法，但是使用 indexOf( ) 方法（需注意此方法不支持IE6-8）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = [arr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b.indexOf(arr[i]) === <span class="number">-1</span>)&#123;b.push(arr[i]);&#125;</span><br><span class="line">        <span class="comment">//上一行也可以用如下写法</span></span><br><span class="line">        <span class="comment">// (b.indexOf(arr[i]) === -1)&amp;&amp;(b.push(arr[i]))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-indexOf-方法和-filter-方法"><a href="#使用-indexOf-方法和-filter-方法" class="headerlink" title="使用 indexOf() 方法和 filter 方法"></a>使用 <code>indexOf()</code> 方法和 <code>filter</code> 方法</h5><pre><code>更进一步，不仅使用了 indexOf() 方法，还使用了 filter</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">        <span class="comment">//元素首次出现的位置是否为元素当前位置</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="排序后去重"><a href="#排序后去重" class="headerlink" title="排序后去重"></a>排序后去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr.sort()</span><br><span class="line">    <span class="keyword">var</span> b = [arr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != b[b.length<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="comment">//排序后查看数组的元素是否与结果数组中最后一个元素相同即可判断是否重复</span></span><br><span class="line">            b.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="排序后去重的简略写法"><a href="#排序后去重的简略写法" class="headerlink" title="排序后去重的简略写法"></a>排序后去重的简略写法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !index || item != array[index<span class="number">-1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ES6-的数组去重"><a href="#ES6-的数组去重" class="headerlink" title="ES6 的数组去重"></a>ES6 的数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Set对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Ｓｅｔ对象的另一种方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>（<span class="title">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Map对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>（<span class="title">arr</span>）</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !res.has(a) &amp;&amp; res.set(a,<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 的原生 Ajax 请求</title>
      <link href="/2016/08/22/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%94%9FAjax%E8%AF%B7%E6%B1%82/"/>
      <url>/2016/08/22/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%94%9FAjax%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>在实际项目中，还是比较少使用 <code>JS</code>的原生 <code>ajax</code> 请求的，一般都是使用 <code>jQuery</code>的<code>$.ajax</code> 等 <em>api</em>。</p><p>但遇到需要自行定制封装<code>ajax</code>请求的情况时，就需要对原生 <code>ajax</code>请求有一定了解才行了。</p><p>本篇博客主要介绍了<code>js</code> 原生 <code>ajax</code> 请求的一些概念和基本使用方法。</p></blockquote><a id="more"></a><h4 id="Javascript-的原生ajax请求"><a href="#Javascript-的原生ajax请求" class="headerlink" title="Javascript 的原生ajax请求"></a><code>Javascript</code> 的原生<code>ajax</code>请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 ajax 对象</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每当readyState改变时，都会调用 onreadystatechange 函数</span></span><br><span class="line"><span class="comment">当请求为异步时调用readyState，请求为同步时直接将业务代码放在send()函数之后即可。</span></span><br><span class="line"><span class="comment">readyState:</span></span><br><span class="line"><span class="comment">存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</span></span><br><span class="line"><span class="comment">  0: 请求未初始化</span></span><br><span class="line"><span class="comment">  1: 服务器连接已建立</span></span><br><span class="line"><span class="comment">  2: 请求已接收</span></span><br><span class="line"><span class="comment">  3: 请求处理中</span></span><br><span class="line"><span class="comment">  4: 请求已完成，且响应已就绪</span></span><br><span class="line"><span class="comment">status:</span></span><br><span class="line"><span class="comment">  http响应码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line">    <span class="comment">/* responseText 获得字符串形式的响应数据 */</span></span><br><span class="line">    <span class="comment">/* responseXML 获得XML形式的响应数据 */</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//规定请求的类型，url，异步或非异步</span></span><br><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"/try/ajax/demo_post2.php"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//添加请求头</span></span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">//当post请求时可以携带字符串参数</span></span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML中 meta 标签说明</title>
      <link href="/2016/07/02/HTML%E4%B8%ADmeta%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/07/02/HTML%E4%B8%ADmeta%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>HTML 中的 <code>meta</code>标签，作为非常常见的标签，它的很多作用和使用方法很少被我们触及。</p><p>为了在后续使用<code>meta</code>标签时不必总是去搜索。特在此篇博客中总结了<code>meta</code>标签的各项使用方式和具体作用，基本涵盖了<code>meta</code>标签的所有使用方式。</p></blockquote><a id="more"></a><h4 id="声明文档使用的字符编码"><a href="#声明文档使用的字符编码" class="headerlink" title="声明文档使用的字符编码"></a>声明文档使用的字符编码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="浏览器兼容模式"><a href="#浏览器兼容模式" class="headerlink" title="浏览器兼容模式"></a>浏览器兼容模式</h4><p>​ 指示 IE 以目前可用的最高模式显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="为移动设备添加-viewport"><a href="#为移动设备添加-viewport" class="headerlink" title="为移动设备添加 viewport"></a>为移动设备添加 viewport</h4><p>​ 主要用于设置视口缩放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,inital-sacle=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>content</code> 参数解释：</p><ul><li><code>width</code> 视口宽度，可设置为 数值 或 <code>device-width（屏幕宽度）</code>S<br><code>height</code> 视口高度，可设置为 数值 或 <code>device-width（屏幕宽度）</code><pre><code>`initial-scale`    初始缩放比例`maxium-scale`    最大缩放比例`minimum-scale`    最小缩放比例`user-scalable`     是否允许用户缩放( yes / no ) ` minimal-ui`     ios中的属性，用于在页面加载时最小化上下状态栏，为布尔值，直接 `content=‘minimal-ui’`使用即可</code></pre></li></ul><h4 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">页面描述</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"不超过150个字符"</span> /&gt;</span></span><br><span class="line">页面关键词</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"html5, css3, 关键字"</span>/&gt;</span></span><br><span class="line">定义网页作者</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"zuozhe"</span> /&gt;</span></span><br><span class="line">定义网页搜索引擎索引方式，robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ios相关"><a href="#ios相关" class="headerlink" title="ios相关"></a>ios相关</h4><h5 id="ios-设备"><a href="#ios-设备" class="headerlink" title="ios 设备"></a>ios 设备</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">添加到主屏后的标题（iOS 6 新增）</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"标题"</span>&gt;</span></span><br><span class="line">是否启用 WebApp 全屏模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span> /&gt;</span></span><br><span class="line">设置状态栏的背景颜色</span><br><span class="line">只有在 "apple-mobile-web-app-capable" content="yes" 时生效</span><br><span class="line">content 参数：</span><br><span class="line">    default 默认值。</span><br><span class="line">    black 状态栏背景是黑色。</span><br><span class="line">    black-translucent 状态栏背景是黑色半透明。</span><br><span class="line">设置为 default 或 black ,网页内容从状态栏底部开始。</span><br><span class="line">设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black-translucent"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="ios-图标-rel-参数"><a href="#ios-图标-rel-参数" class="headerlink" title="ios 图标 rel 参数"></a>ios 图标 rel 参数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apple-touch-icon 图片自动处理成圆角和高光等效果。</span><br><span class="line">apple-touch-icon-precomposed 禁止系统自动添加效果，直接显示设计原图。</span><br><span class="line">iPhone 和 iTouch，默认 57x57 像素，必须有</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-57x57-precomposed.png"</span> /&gt;</span></span><br><span class="line">iPad，72x72 像素，可以没有，但推荐有</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"72x72"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-72x72-precomposed.png"</span> /&gt;</span></span><br><span class="line">Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"114x114"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-114x114-precomposed.png"</span> /&gt;</span></span><br><span class="line">Retina iPad，144x144 像素，可以没有，推荐大家使用</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"144x144"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-144x144-precomposed.png"</span> /&gt;</span></span><br><span class="line">title最好限制在六个中文长度内，超长的内容会被隐藏，添加到主屏后的标题（iOS 6 新增）</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"标题"</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="启动画面"><a href="#启动画面" class="headerlink" title="启动画面"></a>启动画面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">iPad 的启动画面是不包括状态栏区域的。</span><br><span class="line">iPad 竖屏 768 x 1004（标准分辨率）</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"768x1004"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-768x1004.png"</span> /&gt;</span></span><br><span class="line">iPad 竖屏 1536x2008（Retina）</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"1536x2008"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-1536x2008.png"</span> /&gt;</span></span><br><span class="line">iPad 横屏 1024x748（标准分辨率）</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"1024x748"</span> <span class="attr">href</span>=<span class="string">"/Default-Portrait-1024x748.png"</span> /&gt;</span></span><br><span class="line">iPad 横屏 2048x1496（Retina）</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"2048x1496"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-2048x1496.png"</span> /&gt;</span></span><br><span class="line">iPhone 和 iPod touch 的启动画面是包含状态栏区域的。</span><br><span class="line">iPhone/iPod Touch 竖屏 320x480 (标准分辨率)</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-320x480.png"</span> /&gt;</span></span><br><span class="line">iPhone/iPod Touch 竖屏 640x960 (Retina)</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"640x960"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-640x960.png"</span> /&gt;</span></span><br><span class="line">iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina)</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"640x1136"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-640x1136.png"</span> /&gt;</span></span><br><span class="line">当用户点击主屏图标打开 WebApp 时，系统会展示启动画面，在未设置情况下系统会默认显示该网站的首页截图，当然这个体验不是很好</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">href</span>=<span class="string">"Startup.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="windows-8"><a href="#windows-8" class="headerlink" title="windows 8"></a>windows 8</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows 8 磁贴颜色</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-TileColor"</span> <span class="attr">content</span>=<span class="string">"#000"</span>/&gt;</span> </span><br><span class="line">Windows 8 磁贴图标</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-TileImage"</span> <span class="attr">content</span>=<span class="string">"icon.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="sns社交标签"><a href="#sns社交标签" class="headerlink" title="sns社交标签"></a>sns社交标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:type"</span> <span class="attr">content</span>=<span class="string">"类型"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:url"</span> <span class="attr">content</span>=<span class="string">"URL地址"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:title"</span> <span class="attr">content</span>=<span class="string">"标题"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image"</span> <span class="attr">content</span>=<span class="string">"图片"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:description"</span> <span class="attr">content</span>=<span class="string">"描述"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将-http-请求-自动转换为-https"><a href="#将-http-请求-自动转换为-https" class="headerlink" title="将 http 请求 自动转换为 https"></a>将 http 请求 自动转换为 https</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"upgrade-insecure-requests"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">添加 RSS 订阅</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">type</span>=<span class="string">"application/rss+xml"</span> <span class="attr">title</span>=<span class="string">"RSS"</span> <span class="attr">href</span>=<span class="string">"/rss.xml"</span> /&gt;</span></span><br><span class="line">添加 favicon icon</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">type</span>=<span class="string">"image/ico"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span> /&gt;</span></span><br><span class="line">禁止数字识自动别为电话号码</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br><span class="line">不让android识别邮箱</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span> /&gt;</span></span><br><span class="line">启用360浏览器的极速模式(webkit)</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line">避免IE使用兼容模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"HandheldFriendly"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">微软的老式浏览器</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"MobileOptimized"</span> <span class="attr">content</span>=<span class="string">"320"</span>&gt;</span></span><br><span class="line">QQ强制竖屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">UC强制全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">QQ强制全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">UC应用模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"browsermode"</span> <span class="attr">content</span>=<span class="string">"application"</span>&gt;</span></span><br><span class="line">QQ应用模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-page-mode"</span> <span class="attr">content</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">禁止百度转码</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-siteapp"</span> /&gt;</span></span><br><span class="line">windows phone 点击无高光</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span>&gt;</span></span><br><span class="line">关键字</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span>  </span><br><span class="line">描述</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span> </span><br><span class="line">标题</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">作者</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"-06"</span> /&gt;</span>  </span><br><span class="line">公司</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"Copyright"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span>  </span><br><span class="line">让IE浏览器用最高级内核渲染页面 还有用 Chrome 框架的页面用webkit 内核 </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span> </span><br><span class="line">IOS6全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">Chrome高版本全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">让360双核浏览器用webkit内核渲染页面</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span> </span><br><span class="line">添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-itunes-app"</span> <span class="attr">content</span>=<span class="string">"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>条件注释判断 IE 浏览器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE]&gt;条件注释区分非IE浏览器</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 7 ]&gt;&lt;html class="oldie ie ie6"&gt; &lt;![endif]--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--[if IE 7 ]&gt;&lt;html class="oldie ie ie7"&gt; &lt;![endif]--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--[if IE 8 ]&gt;&lt;html class="ie ie8"&gt; &lt;![endif]--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--[if (gte IE 9)|!(IE)]&gt;&lt;!--&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!--&lt;![endif]--&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;  &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sublime text3 的设置项中文翻译</title>
      <link href="/2016/03/20/sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/03/20/sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p><code>sublime text3</code> 编辑器的所有设置项的中文翻译。</p><p>方便查阅和配置。</p></blockquote><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line"> // While you can edit this file, it's best to put your changes in</span><br><span class="line">// "User/Preferences.sublime-settings", which overrides the settings in here.</span><br><span class="line">//</span><br><span class="line">// Settings may also be placed in file type specific options files, for</span><br><span class="line">// example, in Packages/Python/Python.sublime-settings for python files.</span><br><span class="line">&#123;</span><br><span class="line">// Sets the colors used within the text area</span><br><span class="line">// 主题文件的路径</span><br><span class="line">"color_scheme": "Packages/Color Scheme - Default/Monokai.tmTheme",</span><br><span class="line"></span><br><span class="line">// Note that the font_face and font_size are overriden in the platform</span><br><span class="line">// specific settings file, for example, "Preferences (Linux).sublime-settings".</span><br><span class="line">// Because of this, setting them here will have no effect: you must set them</span><br><span class="line">// in your User File Preferences.</span><br><span class="line">// 设置字体和大小，必须在Settings-User里重写，这里设置没有任何效果</span><br><span class="line">"font_face": "Consolas",</span><br><span class="line">"font_size": 12,</span><br><span class="line"></span><br><span class="line">// Valid options are "no_bold", "no_italic", "no_antialias", "gray_antialias",</span><br><span class="line">// "subpixel_antialias" and "no_round" (OS X only)</span><br><span class="line">// 字体选项：no_bold不显示粗体字，no_italic不显示斜体字，no_antialias和no_antialias关闭反锯齿</span><br><span class="line">// subpixel_antialias和no_round是OS X系统独有的</span><br><span class="line">"font_options": [],</span><br><span class="line"></span><br><span class="line">// Characters that are considered to separate words</span><br><span class="line">// 在文字上双击会全选当前的内容，如果里面出现以下字符，就会被截断</span><br><span class="line">"word_separators”: “./()\”‘-:,.;~!@#$%^&amp;*|+=[]&#123;&#125;`~?",</span><br><span class="line"></span><br><span class="line">// Set to false to prevent line numbers being drawn in the gutter</span><br><span class="line">// 是否显示行号</span><br><span class="line">"line_numbers": true,</span><br><span class="line"></span><br><span class="line">// Set to false to hide the gutter altogether</span><br><span class="line">// 是否显示行号边栏</span><br><span class="line">"gutter": true,</span><br><span class="line"></span><br><span class="line">// Spacing between the gutter and the text</span><br><span class="line">// 行号边栏和文字的间距</span><br><span class="line">"margin": 4,</span><br><span class="line"></span><br><span class="line">// Fold buttons are the triangles shown in the gutter to fold regions of text</span><br><span class="line">// 是否显示代码折叠按钮</span><br><span class="line">"fold_buttons": true,</span><br><span class="line"></span><br><span class="line">// Hides the fold buttons unless the mouse is over the gutter</span><br><span class="line">// 不管鼠标在不在行号边栏，代码折叠按钮一直显示</span><br><span class="line">"fade_fold_buttons": true,</span><br><span class="line"></span><br><span class="line">// Columns in which to display vertical rulers</span><br><span class="line">//列显示垂直标尺，在中括号里填入数字，宽度按字符计算</span><br><span class="line">"rulers": [],</span><br><span class="line"></span><br><span class="line">// Set to true to turn spell checking on by default</span><br><span class="line">// 是否打开拼写检查</span><br><span class="line">"spell_check": false,</span><br><span class="line"></span><br><span class="line">// The number of spaces a tab is considered equal to</span><br><span class="line">// Tab键制表符宽度</span><br><span class="line">"tab_size": 4,</span><br><span class="line"></span><br><span class="line">// Set to true to insert spaces when tab is pressed</span><br><span class="line">// 设为true时，缩进和遇到Tab键时使用空格替代</span><br><span class="line">"translate_tabs_to_spaces": false,</span><br><span class="line"></span><br><span class="line">// If translate_tabs_to_spaces is true, use_tab_stops will make tab and</span><br><span class="line">// backspace insert/delete up to the next tabstop</span><br><span class="line">// translate_tabs_to_spaces设置为true，Tab和Backspace的删除/插入作用于制表符宽度</span><br><span class="line">// 否则作用于单个空格</span><br><span class="line">"use_tab_stops": true,</span><br><span class="line"></span><br><span class="line">// Set to false to disable detection of tabs vs. spaces on load</span><br><span class="line">// false时禁止在载入的时候检测制表符和空格</span><br><span class="line">"detect_indentation": true,</span><br><span class="line"></span><br><span class="line">// Calculates indentation automatically when pressing enter</span><br><span class="line">// 按回车时，自动与制表位对齐</span><br><span class="line">"auto_indent": true,</span><br><span class="line"></span><br><span class="line">// Makes auto indent a little smarter, e.g., by indenting the next line</span><br><span class="line">// after an if statement in C. Requires auto_indent to be enabled.</span><br><span class="line">//针对C语言的</span><br><span class="line">"smart_indent": false,</span><br><span class="line"></span><br><span class="line">// Adds whitespace up to the first open bracket when indenting. Requires</span><br><span class="line">// auto_indent to be enabled.</span><br><span class="line">// 需要启用auto_indent，第一次打开括号缩进时插入空格？（没测试出来效果...）</span><br><span class="line">"indent_to_bracket": true,</span><br><span class="line"></span><br><span class="line">// Trims white space added by auto_indent when moving the caret off the</span><br><span class="line">// line.</span><br><span class="line">// 显示对齐的白线是否根据回车、tab等操作自动填补</span><br><span class="line">"trim_automatic_white_space": true,</span><br><span class="line"></span><br><span class="line">// Disables horizontal scrolling if enabled.</span><br><span class="line">// May be set to true, false, or "auto", where it will be disabled for</span><br><span class="line">// source code, and otherwise enabled.</span><br><span class="line">// 是否自动换行，如果选auto，需要加双引号</span><br><span class="line">"word_wrap": false,</span><br><span class="line"></span><br><span class="line">// Set to a value other than 0 to force wrapping at that column rather than the</span><br><span class="line">// window width</span><br><span class="line">// 设置窗口内文字区域的宽度</span><br><span class="line">"wrap_width": 0,</span><br><span class="line"></span><br><span class="line">// Set to false to prevent word wrapped lines from being indented to the same</span><br><span class="line">// level</span><br><span class="line">// 防止被缩进到同一级的字换行</span><br><span class="line">"indent_subsequent_lines": true,</span><br><span class="line"></span><br><span class="line">// Draws text centered in the window rather than left aligned</span><br><span class="line">// 如果没有定义过，则文件居中显示（比如新建的文件）</span><br><span class="line">"draw_centered": false,</span><br><span class="line"></span><br><span class="line">// Controls auto pairing of quotes, brackets etc</span><br><span class="line">// 自动匹配引号，括号等</span><br><span class="line">"auto_match_enabled": true,</span><br><span class="line"></span><br><span class="line">// Word list to use for spell checking</span><br><span class="line">// 拼写检查的单词列表路径</span><br><span class="line">"dictionary": "Packages/Language - English/en_US.dic",</span><br><span class="line"></span><br><span class="line">// Set to true to draw a border around the visible rectangle on the minimap.</span><br><span class="line">// The color of the border will be determined by the "minimapBorder" key in</span><br><span class="line">// the color scheme</span><br><span class="line">// 代码地图的可视区域部分是否加上边框，边框的颜色可在配色方案上加入minimapBorder键</span><br><span class="line">"draw_minimap_border": false,</span><br><span class="line"></span><br><span class="line">// If enabled, will highlight any line with a caret</span><br><span class="line">// 突出显示当前光标所在的行</span><br><span class="line">"highlight_line": false,</span><br><span class="line"></span><br><span class="line">// Valid values are "smooth", "phase", "blink", "wide" and "solid".</span><br><span class="line">// 设置光标闪动方式</span><br><span class="line">"caret_style": "smooth",</span><br><span class="line"></span><br><span class="line">// Set to false to disable underlining the brackets surrounding the caret</span><br><span class="line">// 是否特殊显示当前光标所在的括号、代码头尾闭合标记</span><br><span class="line">"match_brackets": true,</span><br><span class="line"></span><br><span class="line">// Set to false if you'd rather only highlight the brackets when the caret is</span><br><span class="line">// next to one</span><br><span class="line">// 设为false时，只有光标在括号或头尾闭合标记的两端时，match_brackets才生效</span><br><span class="line">"match_brackets_content": true,</span><br><span class="line"></span><br><span class="line">// Set to false to not highlight square brackets. This only takes effect if</span><br><span class="line">// match_brackets is true</span><br><span class="line">// 是否突出显示圆括号，match_brackets为true生效</span><br><span class="line">"match_brackets_square": false,</span><br><span class="line"></span><br><span class="line">// Set to false to not highlight curly brackets. This only takes effect if</span><br><span class="line">// match_brackets is true</span><br><span class="line">// 是否突出显示大括号，match_brackets为true生效</span><br><span class="line">"match_brackets_braces": false,</span><br><span class="line"></span><br><span class="line">// Set to false to not highlight angle brackets. This only takes effect if</span><br><span class="line">// match_brackets is true</span><br><span class="line">// 是否突出显示尖括号，match_brackets为true生效</span><br><span class="line">"match_brackets_angle": false,</span><br><span class="line"></span><br><span class="line">// Enable visualization of the matching tag in HTML and XML</span><br><span class="line">// html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等</span><br><span class="line">"match_tags": true,</span><br><span class="line"></span><br><span class="line">// Highlights other occurrences of the currently selected text</span><br><span class="line">// 全文突出显示和当前选中字符相同的字符</span><br><span class="line">"match_selection": true,</span><br><span class="line"></span><br><span class="line">// Additional spacing at the top of each line, in pixels</span><br><span class="line">// 设置每一行到顶部，以像素为单位的间距，效果相当于行距</span><br><span class="line">"line_padding_top": 1,</span><br><span class="line"></span><br><span class="line">// Additional spacing at the bottom of each line, in pixels</span><br><span class="line">// 设置每一行到底部，以像素为单位的间距，效果相当于行距</span><br><span class="line">"line_padding_bottom": 1,</span><br><span class="line"></span><br><span class="line">// Set to false to disable scrolling past the end of the buffer.</span><br><span class="line">// On OS X, this value is overridden in the platform specific settings, so</span><br><span class="line">// you'll need to place this line in your user settings to override it.</span><br><span class="line">// 设置为false时，滚动到文本的最下方时，没有缓冲区</span><br><span class="line">"scroll_past_end": true,</span><br><span class="line"></span><br><span class="line">// This controls what happens when pressing up or down when on the first</span><br><span class="line">// or last line.</span><br><span class="line">// On OS X, this value is overridden in the platform specific settings, so</span><br><span class="line">// you'll need to place this line in your user settings to override it.</span><br><span class="line">// 设置成true，当光标已经在第一行时，再Up则到行首，如果光标已经在最后一行，再Down则跳到行尾</span><br><span class="line">"move_to_limit_on_up_down": false,</span><br><span class="line"></span><br><span class="line">// Set to "none" to turn off drawing white space, "selection" to draw only the</span><br><span class="line">// white space within the selection, and "all" to draw all white space</span><br><span class="line">// 按space或tab时，实际会产生白色的点（一个空格一个点）或白色的横线（tab_size设置的制表符的宽度），选中状态下才能看到</span><br><span class="line">// 设置为none时，什么情况下都不显示这些点和线</span><br><span class="line">// 设置为selection时，只显示选中状态下的点和线</span><br><span class="line">// 设置为all时，则一直显示</span><br><span class="line">"draw_white_space": "selection",</span><br><span class="line"></span><br><span class="line">// Set to false to turn off the indentation guides.</span><br><span class="line">// The color and width of the indent guides may be customized by editing</span><br><span class="line">// the corresponding .tmTheme file, and specifying the colors "guide",</span><br><span class="line">// "activeGuide" and "stackGuide"</span><br><span class="line">// 制表位的对齐白线是否显示，颜色可在主题文件里设置（guide，activeGuide，stackGuide）</span><br><span class="line">"draw_indent_guides": true,</span><br><span class="line"></span><br><span class="line">// Controls how the indent guides are drawn, valid options are</span><br><span class="line">// "draw_normal" and "draw_active". draw_active will draw the indent</span><br><span class="line">// guides containing the caret in a different color.</span><br><span class="line">// 制表位的对齐白线，draw_normal为一直显示，draw_active为只显示当前光标所在的代码控制域</span><br><span class="line">"indent_guide_options": ["draw_normal"],</span><br><span class="line"></span><br><span class="line">// Set to true to removing trailing white space on save</span><br><span class="line">// 为true时，保存文件时会删除每行结束后多余的空格</span><br><span class="line">"trim_trailing_white_space_on_save": false,</span><br><span class="line"></span><br><span class="line">// Set to true to ensure the last line of the file ends in a newline</span><br><span class="line">// character when saving</span><br><span class="line">// 为true时，保存文件时光标会在文件的最后向下换一行</span><br><span class="line">"ensure_newline_at_eof_on_save": false,</span><br><span class="line"></span><br><span class="line">// Set to true to automatically save files when switching to a different file</span><br><span class="line">// or application</span><br><span class="line">// 切换到其它文件标签或点击其它非本软件区域，文件自动保存</span><br><span class="line">"save_on_focus_lost": false,</span><br><span class="line"></span><br><span class="line">// The encoding to use when the encoding can't be determined automatically.</span><br><span class="line">// ASCII, UTF-8 and UTF-16 encodings will be automatically detected.</span><br><span class="line">// 编码时不能自动检测编码时，将自动检测ASCII, UTF-8 和 UTF-16</span><br><span class="line">"fallback_encoding": "Western (Windows 1252)",</span><br><span class="line"></span><br><span class="line">// Encoding used when saving new files, and files opened with an undefined</span><br><span class="line">// encoding (e.g., plain ascii files). If a file is opened with a specific</span><br><span class="line">// encoding (either detected or given explicitly), this setting will be</span><br><span class="line">// ignored, and the file will be saved with the encoding it was opened</span><br><span class="line">// with.</span><br><span class="line">// 默认编码格式</span><br><span class="line">"default_encoding": "UTF-8",</span><br><span class="line"></span><br><span class="line">// Files containing null bytes are opened as hexadecimal by default</span><br><span class="line">// 包含空字节的文件被打开默认为十六进制</span><br><span class="line">"enable_hexadecimal_encoding": true,</span><br><span class="line"></span><br><span class="line">// Determines what character(s) are used to terminate each line in new files.</span><br><span class="line">// Valid values are 'system' (whatever the OS uses), 'windows' (CRLF) and</span><br><span class="line">// 'unix' (LF only).</span><br><span class="line">// 每一行结束的时候用什么字符做终止符</span><br><span class="line">"default_line_ending": "system",</span><br><span class="line"></span><br><span class="line">// When enabled, pressing tab will insert the best matching completion.</span><br><span class="line">// When disabled, tab will only trigger snippets or insert a tab.</span><br><span class="line">// Shift+tab can be used to insert an explicit tab when tab_completion is</span><br><span class="line">// enabled.</span><br><span class="line">// 设置为enabled时，在一个字符串间按Tab将插入一个制表符</span><br><span class="line">// 设置为true时，按Tab会根据前后环境进行代码自动匹配填补</span><br><span class="line">"tab_completion": true,</span><br><span class="line"></span><br><span class="line">// Enable auto complete to be triggered automatically when typing.</span><br><span class="line">// 代码提示</span><br><span class="line">"auto_complete": true,</span><br><span class="line"></span><br><span class="line">// The maximum file size where auto complete will be automatically triggered.</span><br><span class="line">// 代码提示的大小限制</span><br><span class="line">"auto_complete_size_limit": 4194304,</span><br><span class="line"></span><br><span class="line">// The delay, in ms, before the auto complete window is shown after typing</span><br><span class="line">// 代码提示延迟显示</span><br><span class="line">"auto_complete_delay": 50,</span><br><span class="line"></span><br><span class="line">// Controls what scopes auto complete will be triggered in</span><br><span class="line">// 代码提示的控制范围</span><br><span class="line">"auto_complete_selector": "source - comment",</span><br><span class="line"></span><br><span class="line">// Additional situations to trigger auto complete</span><br><span class="line">// 触发代码提示的其他情况</span><br><span class="line">"auto_complete_triggers": [ &#123;"selector": "text.html", "characters": "&lt;"&#125; ],</span><br><span class="line"></span><br><span class="line">// By default, auto complete will commit the current completion on enter.</span><br><span class="line">// This setting can be used to make it complete on tab instead.</span><br><span class="line">// Completing on tab is generally a superior option, as it removes</span><br><span class="line">// ambiguity between committing the completion and inserting a newline.</span><br><span class="line">// 设为false时，选择提示的代码按回车或点击可以输出出来，但选择true时不会输出而是直接换行</span><br><span class="line">"auto_complete_commit_on_tab": false,</span><br><span class="line"></span><br><span class="line">// Controls if auto complete is shown when snippet fields are active.</span><br><span class="line">// Only relevant if auto_complete_commit_on_tab is true.</span><br><span class="line">// auto_complete_commit_on_tab必须为true，控制代码提示的活跃度（没明白...）</span><br><span class="line">"auto_complete_with_fields": false,</span><br><span class="line"></span><br><span class="line">// By default, shift+tab will only unindent if the selection spans</span><br><span class="line">// multiple lines. When pressing shift+tab at other times, it'll insert a</span><br><span class="line">// tab character - this allows tabs to be inserted when tab_completion is</span><br><span class="line">// enabled. Set this to true to make shift+tab always unindent, instead of</span><br><span class="line">// inserting tabs.</span><br><span class="line">// 设置为false，使用Shift + tab总是插入制表符</span><br><span class="line">"shift_tab_unindent": true,</span><br><span class="line"></span><br><span class="line">// If true, the selected text will be copied into the find panel when it's</span><br><span class="line">// shown.</span><br><span class="line">// On OS X, this value is overridden in the platform specific settings, so</span><br><span class="line">// you'll need to place this line in your user settings to override it.</span><br><span class="line">// 选中的文本按Ctrl + f时，自动复制到查找面板的文本框里</span><br><span class="line">"find_selected_text": true,</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// User Interface Settings</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// The theme controls the look of Sublime Text's UI (buttons, tabs, scroll bars, etc)</span><br><span class="line">// DataPackagesTheme - DefaultDefault.sublime-theme控制软件的主题</span><br><span class="line">"theme": "Default.sublime-theme",</span><br><span class="line"></span><br><span class="line">// Set to 0 to disable smooth scrolling. Set to a value between 0 and 1 to</span><br><span class="line">// scroll slower, or set to larger than 1 to scroll faster</span><br><span class="line">// 滚动的速度</span><br><span class="line">"scroll_speed": 1.0,</span><br><span class="line"></span><br><span class="line">// Controls side bar animation when expanding or collapsing folders</span><br><span class="line">// 左边边栏文件夹动画</span><br><span class="line">"tree_animation_enabled": true,</span><br><span class="line">// 标签页的关闭按钮</span><br><span class="line">"show_tab_close_buttons": true,</span><br><span class="line"></span><br><span class="line">// OS X 10.7 only: Set to true to disable Lion style full screen support.</span><br><span class="line">// Sublime Text must be restarted for this to take effect.</span><br><span class="line">// 针对OS X</span><br><span class="line">"use_simple_full_screen": false,</span><br><span class="line"></span><br><span class="line">// Valid values are "system", "enabled" and "disabled"</span><br><span class="line">// 水平垂直滚动条：system和disabled为默认显示方式，enabled为自动隐藏显示</span><br><span class="line">"overlay_scroll_bars": "system",</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Application Behavior Settings</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// Exiting the application with hot_exit enabled will cause it to close</span><br><span class="line">// immediately without prompting. Unsaved modifications and open files will</span><br><span class="line">// be preserved and restored when next starting.</span><br><span class="line">//</span><br><span class="line">// Closing a window with an associated project will also close the window</span><br><span class="line">// without prompting, preserving unsaved changes in the workspace file</span><br><span class="line">// alongside the project.</span><br><span class="line">// 热推出功能！退出时不会提示是否保存文件，而是直接退出</span><br><span class="line">// 下次打开软件时，文件保持退出前的状态，没来得及保存的内容都在，但并没有真实的写在原文件里</span><br><span class="line">"hot_exit": true,</span><br><span class="line"></span><br><span class="line">// remember_open_files makes the application start up with the last set of</span><br><span class="line">// open files. Changing this to false will have no effect if hot_exit is</span><br><span class="line">// true</span><br><span class="line">// 软件使用最后的设定打开文件，hot_exit为true时没有效果</span><br><span class="line">"remember_open_files": true,</span><br><span class="line"></span><br><span class="line">// OS X only: When files are opened from finder, or by dragging onto the</span><br><span class="line">// dock icon, this controls if a new window is created or not.</span><br><span class="line">// 针对OS X</span><br><span class="line">"open_files_in_new_window": true,</span><br><span class="line"></span><br><span class="line">// Set to true to close windows as soon as the last file is closed, unless</span><br><span class="line">// there's a folder open within the window. This is always enabled on OS X,</span><br><span class="line">// changing it here won't modify the behavior.</span><br><span class="line">// 针对OS X</span><br><span class="line">"close_windows_when_empty": true,</span><br><span class="line">// 哪些文件会被显示到边栏上</span><br><span class="line">// folder_exclude_patterns and file_exclude_patterns control which files</span><br><span class="line">// are listed in folders on the side bar. These can also be set on a per-</span><br><span class="line">// project basis.</span><br><span class="line">"folder_exclude_patterns": [".svn", ".git", ".hg", "CVS"],</span><br><span class="line">"file_exclude_patterns": ["*.pyc", "*.pyo", "*.exe", "*.dll", "*.obj","*.o", "*.a", "*.lib", "*.so", "*.dylib", "*.ncb", "*.sdf", "*.suo", "*.pdb", "*.idb", ".DS_Store", "*.class", "*.psd", "*.db"],</span><br><span class="line">// These files will still show up in the side bar, but won't be included in</span><br><span class="line">// Goto Anything or Find in Files</span><br><span class="line">"binary_file_patterns": ["*.jpg", "*.jpeg", "*.png", "*.gif", "*.ttf", "*.tga", "*.dds", "*.ico", "*.eot", "*.pdf", "*.swf", "*.jar", "*.zip"],</span><br><span class="line"></span><br><span class="line">// List any packages to ignore here. When removing entries from this list,</span><br><span class="line">// a restart may be required if the package contains plugins.</span><br><span class="line">// 删除你想要忽略的插件，需要重启</span><br><span class="line">"ignored_packages": ["Vintage"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决sublime text3在ubutun下的中文输入问题</title>
      <link href="/2016/03/19/%E8%A7%A3%E5%86%B3sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2016/03/19/%E8%A7%A3%E5%86%B3sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:08 GMT+0800 (CST) --><blockquote><p><code>sublime-text-3</code> 编辑器性感而敏捷，却让人感慨有其长必有其短。</p><p>有些缺点都可以通过插件解决。但是在<code>ubutun</code>环境下，要解决输入中文问题却很复杂，不能输入中文实在是太痛苦了。</p><p>我在做一个有很多文字的<code>html</code>页面，在无数次复制粘贴后，我终于决定看一下有没有好的解决办法能解决这个问题。</p><p>在试了有十几个教程都失败时，我几乎要放弃了。搜索出来的教程大部分都不起作用，有的连库文件的语法都是错误的，更别说编译到subl 里了。</p><p>最终我决定去官方网站逛逛，发现官网论坛的管理员提供了一个方法，很简单。试了一下，竟然很顺畅的成功了。</p><p>那就记录一下这个方法，希望对于解决大家头疼的subl不能输入中文问题有一些帮助。</p></blockquote><a id="more"></a><p><strong>以下方法在 ubutun15.04 中亲测可行，subl版本为 3126 。</strong></p><p>具体分为下面几个步骤：</p><h1 id="下载源文件"><a href="#下载源文件" class="headerlink" title="下载源文件"></a>下载源文件</h1><p>源文件github链接地址为</p><p><a href="https://github.com/jfcherng/my_scripts" target="_blank" rel="noopener">https://github.com/jfcherng/my_scripts</a></p><p>点击页面右侧的 <em>clone and download</em> 按钮下载源文件的 <em>zip</em> 包，</p><p>下载完成后解压到任意文件夹即可。</p><h1 id="安装fcitx输入法"><a href="#安装fcitx输入法" class="headerlink" title="安装fcitx输入法"></a>安装fcitx输入法</h1><p>打开终端，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y fcitx fcitx-im</span><br></pre></td></tr></table></figure><p>安装 fcitx 输入法框架,安装此框架后，框架下的输入法就都可以在 subl 中使用了。</p><h1 id="安装编译库"><a href="#安装编译库" class="headerlink" title="安装编译库"></a>安装编译库</h1><p>先更新软件库，在终端输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>再安装编译库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y build-essential libgtk2.0-dev</span><br></pre></td></tr></table></figure><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><p>首先在终端中切换到第一步中下载解压后的文件夹，再进入 文件夹中的 <em>sublime_text_fcitx</em> 子文件夹中。</p><p>在切换到文件夹后，在终端中输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Os -shared -o libsublime-imfix.so sublime_imfix.c $(pkg-config --libs --cflags gtk+-2.0) -fPIC</span><br></pre></td></tr></table></figure><p>完成编译</p><h1 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h1><p>依次在命令行中输入以下命令(<code>/opt//sublime_text</code>为<em>subl</em>的默认安装目录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -f libsublime-imfix.so /opt/sublime_text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f subl &quot;$(which subl)&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f sublime_text.desktop /usr/share/applications/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f sublime_text.desktop /opt/sublime_text</span><br></pre></td></tr></table></figure><p>完成。</p><p>打开<em>sublime</em>，你会发现，在你切换到<em>fcitx</em>输入法后，就可以在输入中文了。这也是我在实验了网络上数十几个不同教程后，发现唯一简单且有效的方法。</p><p>不用复制粘贴大堆的代码，不用改系统的各种文件，只需要输入几条命令就可以输入中文了。</p><p>当然，不管那种方法，可以输入中文后存在不能在subl打开中插件包目录的问题，要想完美解决，只能等官方动作了。（虽然我在官网论坛中并没有发现官方有这种想法^_^!）。</p><p>以上就是<em>sublime-text-3</em> 设置可输入中文的方法。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sublime text3在ubutun下的安装和配置</title>
      <link href="/2016/03/19/sublime%20text3%E5%9C%A8Ubutun%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/03/19/sublime%20text3%E5%9C%A8Ubutun%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<!-- build time:Sun Sep 16 2018 01:52:07 GMT+0800 (CST) --><blockquote><p>最近在折腾<em>ubutun</em>系统，打算作为平常使用的主系统，就想在 <em>ubuntu</em> 上找个写 <em>html</em> 和 <em>Javascript</em> 的编辑器。</p><p>在<em>win</em>上使用的 <em>javascript</em> 编辑器用的是 <em>notepad++</em>，但是 <em>linux</em> 上好像是没有的，那只有再找一个了。</p><p>我的需求是 <strong>一个轻量级的 javascript 编辑器</strong>，只需要编辑器有基本功能如语法高亮，语法检查就行，最好安装简单，不要太浪费时间配置。</p><p>最终选择了<code>Sublime text3</code>，这篇博客就是对其的安装配置过程的记录和介绍。</p></blockquote><a id="more"></a><h3 id="试用bluefish编辑器"><a href="#试用bluefish编辑器" class="headerlink" title="试用bluefish编辑器"></a>试用bluefish编辑器</h3><p>首先找到的是一款叫 <em>bluefish</em> 的编辑器，这款编辑器的优点是启动快，界面美观大方。而且安装简单，同时自带中文，哈哈，看起来很适合我这种菜鸡啊。那就先装上试试吧。</p><p>打开终端输入命令：</p><p><code>sudo apt-get install bluefish</code></p><p>好啦，等待安装完成吧。</p><p>安装完成后，打开先写点代码试试，在熟悉了一下编辑器功能后，发现有两个我无法接受的缺点：</p><ul><li>不支持使用 <em>vim</em> 模式 （这让我怎么写代码？）</li><li>不支持安装 <em>emmet</em> 插件 （啊，我写代码要打一堆尖括号啊？不能忍啊！）</li></ul><p>好吧，你被我<em>ban</em>了,<del>bluefish</del>。</p><h3 id="安装sublime"><a href="#安装sublime" class="headerlink" title="安装sublime"></a>安装<em>sublime</em></h3><p>只能再找一个编辑器了。</p><p><em>google</em>一下，发现好多人推荐 <em>sublime text</em> 啊，启动速度快，能自己拓展，那装一个试试吧。</p><p><em>linux</em>的<em>ubuntu</em>系统下<em>sublime text 3</em>（以下简称subl） 的安装有两种方法：</p><h4 id="通过下载软件包安装"><a href="#通过下载软件包安装" class="headerlink" title="通过下载软件包安装"></a>通过下载软件包安装</h4><p>1.到subl官网下载软件安装包，这是<a href="http://www.sublimetext.com/2" target="_blank" rel="noopener">sublime下载官网</a></p><p>2.直接双击下载的软件包即可安装 。</p><h4 id="通过终端安装"><a href="#通过终端安装" class="headerlink" title="通过终端安装"></a>通过终端安装</h4><ol><li><p>打开终端，首先安装 subl3 的软件库，使用命令</p><p><code>sudo add-apt-repository ppa:webupd8team/sublime-text-3</code></p><p>中间会询问是否添加仓库，点击<code>enter</code>即可。</p></li><li><p>刷新软件库，使用命令</p><p><code>sudo apt-get update</code></p></li><li><p>安装<em>subl3</em>,使用命令</p><p><code>sudo apt-get install sublime-text-installer</code></p></li></ol><p>通过以上三步，<em>subl</em>就安装完成了，安装完成会自动启动，把软件图标锁定到侧边启动栏，以后就直接可以点击图标启动了。</p><p>然后就是最基本的配置了。</p><h3 id="使用前配置"><a href="#使用前配置" class="headerlink" title="使用前配置"></a>使用前配置</h3><h4 id="安装package-control-插件"><a href="#安装package-control-插件" class="headerlink" title="安装package control 插件"></a>安装package control 插件</h4><p>这个插件相当于其他所有插件的接口，通过 package control 插件，我们可以方便 直观 只需点一点 的安装其他插件（简直是execting）。</p><p>这个插件的安装方法也很简单。</p><p>首先打开 <em>subl</em> 的命令行，使用快捷键 <em>ctrl +`</em>（就是<code>～</code>那个键），或者点击菜单 <em>view</em> 选项卡里的那个 <em>show consoles</em> 选项，调出控制台。</p><p>然后在控制台输入以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os;pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf),<span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure><p>点击菜单栏 <em>Preferences</em> 选项卡，看一下有没有<em>pcakage control</em> 选项，如果有，就说明安装成功。</p><p>如果无法通过命令安装，就只能手动安装了。</p><p>手动安装步骤如下</p><ul><li>1.点击<em>Preferences</em> &gt; <em>Browse Packages</em>菜单</li><li>2.进入打开的目录的上层目录，然后再进入 <em>Installed Packages/</em> 目录</li><li>3.下载 <em>Package Control.sublime-package</em> 并 复制到 Installed Packages/目录</li><li>4.重启<em>Sublime Text3</em>。</li></ul><h4 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h4><p>汉化<em>subl</em>很简单。</p><ul><li>直接点击 <em>Preferences</em> 选项卡的 <em>package control</em> 选项，选择下拉的 <em>install package</em> 选项</li><li>在输入框中输入 <em>localization</em> ，然后点击检索出来的 <em>Chineselocalizetion</em> 插件，等待安装完成</li><li>再看一下界面，已经成中文的了。如果需要切换，点击 帮助 选项卡的 language 选项可以选择你想要的语言。</li></ul><h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><p>其实使用subl也并不是特别需要激活，因为只是会隔几十分钟提示一下你未激活，不影响什么。</p><p>对于强迫症用户，可以选择两种方式激活。</p><ul><li>付费激活，虽然有点贵，大几百，有点肉疼。</li><li>破解（我只提示一下，点开帮助的关于选项卡，看一下版本号，然后去搜激活码，一搜一堆，就不在这贴激活码了，不太好）（毕竟我心里还是比较想支持正版的，穷啊）</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><em>subl</em>的设置跟别的软件不太一样，不是通过一堆选项卡和按钮来设置界面，字体等，而是使用<code>json</code>文件形式。设置使用的 <code>json</code> 文件一式两份，一份默认设置，一份用户设置，用户设置优先，也就是说你在用户的 <code>json</code> 里写了的设置就使用你写的，没写就使用默认的。</p><p>你想设置什么需要自己去写入<code>json</code>文件。点开菜单 首选项 选项卡，选择设置，会打开两个文件，左边的是默认设置，右边的是用户设置。</p><p>当然，作为轻度用户，并不需要设置许多东西。只需要设置一下字体行距就行。</p><p>我的配置如下，可以直接粘贴进你的用户设置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bold_folder_labels"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"color_scheme"</span>: <span class="string">"Packages/Color Scheme - Default/Monokai.tmTheme"</span>,</span><br><span class="line">    <span class="attr">"font_size"</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="attr">"highlight_line"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ignored_packages"</span>:</span><br><span class="line">    [</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"rulers"</span>:</span><br><span class="line">    [</span><br><span class="line">    <span class="number">80</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"save_on_focus_lost"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"scroll_past_end"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"show_encoding"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"show_full_path"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"show_line_endings"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"tab_size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"translate_tabs_to_spaces"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"trim_trailing_white_space_on_save"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时提示一下，如果想详细设置的，可以看<a href="https://gyufei.github.io/2016/03/20/sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">我的另一篇博客</a>，是<em>subl</em>所有默认设置的中文版本翻译，篇幅较长，在这就不贴了。</p><p>着重看一下 配置文件里的这个 <em>“ignored_packages”:</em> 项，这个是忽略的插件的列表。如果你想使用 <code>vim</code> 的话，可以就像我一样，将忽略插件列表里默认有的 <em>vintage</em> 字符删去就可以启用<code>vim</code>模式了。</p><p>在 <em>sublime</em> 的<code>vim</code> 模式下，进入命令模式后，光标是一个闪烁的下滑线，难以辨认，使用也不方便，同时在安装了 高亮括号插件 <em>Brackhigtlight</em> 插件后，界面乱七八糟都是下划线，十分难看。</p><p>如果想要将 <em>sublime</em> 的 <code>vim</code> 命令模式下光标设置为方块，而不是下划线，可以安装 <em>block cursor everywhere插件</em> 实现美观的 方块光标。</p><h3 id="安装-emmet"><a href="#安装-emmet" class="headerlink" title="安装 emmet"></a>安装 <em>emmet</em></h3><p>写 <em>html</em> 怎么能不用 <em>emmet</em> 插件呢，简直是神器啊。可以 <em>google</em> 一下 看一下教程，试用一下，你会发现你已经离不开它了。</p><p>安装 <em>emmet</em> 插件很简单，跟安装汉化差不多，点开选项卡 <em>首选项</em>，在点开 <em>package control</em> ，再点击 install package ，在弹出的搜索框输入 emmet，等待安装完成就可以了。</p><p>需要注意的是，跟别的编辑器的 <em>emmet</em> 插件使用 <em>table</em> 来自动填写不同，<em>sublame text 3</em> 需要使用 <em>ctrl + e</em> 来完成自动填写。你可以试一下，输入 ！，之后按 ctrl + e，一个HTML文件的主体就出现了。</p><p>如果你想在 <em>emmet</em> 使用 <em>tabel</em> 来完成自动填写，那就需要修改 <em>emmet</em> 插件设置了。步骤如下：</p><ul><li>选择菜单栏 <em>首选项</em> 选项卡里的 <em>package setting</em> 选项里的 <em>emmet</em> 选项卡。</li><li>选择 <em>emmet</em> 选项卡中的 <em>key-bind user</em> 选项，在用户设置文件中，输入一下代码。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [</span><br><span class="line">            <span class="string">"tab"</span></span><br><span class="line">        ],</span><br><span class="line">    <span class="attr">"args"</span>: &#123;</span><br><span class="line">        <span class="attr">"action"</span>: <span class="string">"expand_abbreviation"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"run_emmet_action"</span>,</span><br><span class="line">    <span class="attr">"context"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"key"</span>: <span class="string">"emmet_action_enabled.expand_abbreviation"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>ok，现在就可以使用 <em>tabel</em> 来完成自动填写了。</p><h3 id="清空sublime-text-3-配置（还原设置）"><a href="#清空sublime-text-3-配置（还原设置）" class="headerlink" title="清空sublime text 3 配置（还原设置）"></a>清空sublime text 3 配置（还原设置）</h3><p><em>subl</em>的缺点就是有时候出现莫名其妙的<em>bug</em>，卸载重装又很麻烦。</p><p>这时可以通过清空<em>subl</em>的配置文件，来达到还原设置，让 <em>subl</em> 像刚装上一样，清新可人（这是什么形容词啊？）</p><p>清空配置命令如下：</p><p><code>sudo rm -rf /home/$USER/.config/sublime-text-3/</code></p><p>使用后就像恢复出厂设置了一样（不要乱试，后果严重，在你确定需要的时候再使用，否则你要哭出来）</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，我的 <em>sublime text 3</em> 编辑器的配置已经基本完成，基本功能已经完善，可以作为 生产工具 使用了。</p><p>对于<em>subl</em> 的更多配置，就只列出关键要点，由大家自行摸索吧。</p><ul><li><em>sublime text 3</em> 的主题是通过与插件相同的方式安装的，可以自行寻找顺眼的主题安装。</li><li><em>sublime text3</em> 在 <em>ubuntu</em> 需要经过配置才能输入中文，但是软件是可以直接显示中文的。（输入中文的配置过程比较麻烦，请思考对中文是否有特别需求，若无可以无视，去配置纯属浪费时间）,输入中文设置见<a href="https://gyufei.github.io/2016/03/19/%E8%A7%A3%E5%86%B3sublime-text3%E5%9C%A8ubutun%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">我的另一篇博客</a></li><li>在编程中，生产力的提升比生产工具重要的多，所以请谨慎考虑自己的需求，根据需求配置生产环境（意思是不需要装一大堆别人都说好的插件啊！）</li><li><strong>最难的事，是明白自己想要什么啊</strong></li></ul><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
